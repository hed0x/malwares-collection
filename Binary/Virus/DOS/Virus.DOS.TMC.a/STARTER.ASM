           jumps
   code    segment para public use16 'CODE'
           assume  cs:code, ds:code
           org     100h

   JMPS    EQU     0FFFFh          ;pravdepodobnost na rozdelenie kodu

           include macros.inc


   ;  ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿ ÚÄÄÄÄÄÄÄÄÄÄ
   ;                     ÚÙÚÙ
   ;      ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
   start:
           mov     ds:out_block_ofs, offset out_block_table
           mov     ds:data_relo_ofs, offset data_relo_table
           mov     ds:jmp_relo_ofs, offset jmp_relo_table

           mov     si, offset src_startup
           mov     bx, offset free
           call    compile
           mov     si, offset src_vir
           call    compile
           call    link
           mov     word ptr cs:[free + 2], offset free
           jmp     free

                   ;³                    ³;
                   ;³      ANALYZER      ³;
                   ;³                    ³;

   ;³ Input:  SI - source
   ;³         BX - output
   ;³ Output: BX - end of code

   compile:
           cld
           mov     di, offset in_block_table
           xor     ax, ax

   next_in_block:
           add     si, ax
           lodsb
           or      al, al
           jz      end_in_block
           cmp     al, M_CODE
           jae     code_cmd
           cmp     al, MAX_CODE_SIZE
           jbe     next_in_block
           sub     al, MAX_CODE_SIZE
           jmp     next_in_block

   code_cmd:
           cmp     al, M_STOP
           jnz     no_stop
           mov     al, 0
           jmp     next_in_block

   no_stop:
           cmp     al, M_BLOCK
           jnz     no_block
           mov     ax, si
           dec     ax
           stosw
           mov     ax, 0FFFFh
           stosw
           mov     ax, 2
           jmp     next_in_block

   no_block:                               ;M_RELO & M_J*
           mov     al, 2
           jmp     next_in_block

   end_in_block:
           lea     ax, [di + (-(offset in_block_table))]
           shr     ax, 1
           shr     ax, 1
           mov     cs:num_of_blocks, ax
           xor     ax, ax
           stosw

                   ;³                    ³;
                   ;³      COMPILER      ³;
                   ;³                    ³;

           mov     di, offset in_block_table
           mov     si, [di]
           jmp     first_no_find

   next_block:
           mov     bp, cs:num_of_blocks
           call    rnd_max
           shl     ax, 1
           shl     ax, 1
           add     ax, offset in_block_table
           mov     di, ax

   next_search_block:
           add     di, 4
           mov     si, [di]
           or      si, si
           jnz     no_last_block
           mov     di, offset in_block_table
           mov     si, [di]

   no_last_block:
           cmp     byte ptr ds:[si], M_STOP
           jnz     no_stoped
           cmp     di, ax
           jnz     next_search_block
           jmp     no_next_block

   no_stoped:
   first_no_find:
           cmp     word ptr ds:[di+2], 0FFFFh
           jz      no_jmp_constr

           push    di
           mov     di, [di+2]
           mov     al, 0e9h
           stosb
           mov     ax, bx
           dec     ax
           dec     ax
           sub     ax, di
           stosw
           pop     di

   no_jmp_constr:
   next_inst:
           lodsb
           cmp     al, M_STOP
           jz      no_next_inst

           cmp     al, MAX_CODE_SIZE
           ja      no_break

           push    ax
           mov     bp, JMPS
           call    rnd_max
           or      ax, ax
           pop     ax
           jz      no_last_but_end

   no_break:
           cmp     al, M_STOP
           jz      no_next_inst
           cmp     al, M_CODE
           jae     code_cmd1
           cmp     al, MAX_CODE_SIZE
           jbe     no_sub_size_data
           sub     al, MAX_CODE_SIZE

   no_sub_size_data:
           xor     cx, cx
           mov     cl, al
           push    di
           mov     di, bx
           rep     movsb
           mov     bx, di
           pop     di
           jmp     next_inst

   code_cmd1:
           cmp     al, M_RELO
           jnz     no_relo1

           push    di
           mov     di, data_relo_ofs
           mov     ax, bx
           dec     ax
           dec     ax
           stosw
           lodsw
           stosw
           mov     data_relo_ofs, di
           pop     di
           jmp     next_inst

   no_relo1:
           cmp     al, M_BLOCK
           jnz     no_block1

           push    di
           mov     di, out_block_ofs
           mov     ax, bx
           stosw
           lodsw
           stosw
           mov     out_block_ofs, di
           cmp     ax, src_src
           jnz     no_put_src

           push    si
           mov     di, bx
           mov     si, offset src
           mov     cx, offset src_end - offset src
           rep     movsb
           mov     bx, di
           pop     si

   no_put_src:
           pop     di
           lodsb
           jmp     no_break

   no_block1:                              ;M_J*
           push    ax di
           mov     di, jmp_relo_ofs
           mov     ax, bx
           stosw
           lodsw
           stosw
           mov     jmp_relo_ofs, di
           pop     di ax
           mov     [bx], al
           add     bx, 3
           cmp     al, M_J_COND
           jb      next_inst
           inc     bx
           inc     bx
           jmp     next_inst

   no_last_but_end:
           mov     [di+2], bx
           add     bx, 3

   no_next_inst:
           dec     si
           mov     [di], si
           jmp     next_block

   no_next_block:
           ret

                   ;³                      ³;
                   ;³    JUMP RELOCATOR    ³;
                   ;³                      ³;

   link:
           mov     si, offset jmp_relo_table
           mov     cx, jmp_relo_ofs
           sub     cx, si
           shr     cx, 1
           shr     cx, 1

   next_jmp_relo:
           lodsw
           push    ax
           lodsw
           push    cx si

           mov     si, offset out_block_table
           mov     cx, out_block_ofs
           sub     cx, si
           shr     cx, 1
           shr     cx, 1

   next_jmp_in_out:
           cmp     ax, [si + 2]
           jz      jmp_found
           add     si, 4
           loop    next_jmp_in_out

           int 3
           mov     bp, 0DEEDh

           push    cs
           pop     ds
           mov     dx, offset jump_not_found
           mov     ah, 9
           int     21h
           mov     ah, 4ch
           int     21h

   jmp_found:
           mov     dx, [si]
           pop     si cx
           pop     bx
           mov     al, [bx]
           cmp     al, M_J_COND
           jb      jmp1

           sub     byte ptr [bx], 0F0h - 070h
           inc     bx
           push    dx
           sub     dx, bx
           dec     dx
           cmp     dx, 127
           jg      over_jmp
           cmp     dx, -128
           jl      over_jmp
           mov     [bx], dl
           inc     bx
           mov     word ptr [bx], 09090h
           mov     byte ptr [bx+2], 090h
           pop     dx
           jmp     next_j_relo

   over_jmp:
           pop     dx
           dec     bx
           xor     byte ptr [bx], 1
           inc     bx
           mov     byte ptr [bx], 3
           inc     bx
           mov     al, 0E9h

   jmp1:
           mov     byte ptr [bx], al
           inc     bx
           sub     dx, bx
           dec     dx
           dec     dx
           mov     [bx], dx

   next_j_relo:
           loop    next_jmp_relo

                   ;³                      ³;
                   ;³    DATA RELOCATOR    ³;
                   ;³                      ³;

           mov     si, offset data_relo_table
           mov     cx, data_relo_ofs
           sub     cx, si
           shr     cx, 1
           shr     cx, 1

   next_data_relo:
           lodsw
           push    ax
           lodsw
           push    cx si

           mov     si, offset out_block_table
           mov     cx, out_block_ofs
           sub     cx, si
           shr     cx, 1
           shr     cx, 1

   next_data_in_out:
           cmp     ax, [si + 2]
           jz      found
           add     si, 4
           loop    next_data_in_out

           int 3
           mov     bp, 0DEADh

           push    cs
           pop     ds
           mov     dx, offset data_not_found
           mov     ah, 9
           int     21h
           mov     ah, 4ch
           int     21h

   found:
           mov     ax, [si]
           pop     si cx
           pop     bx
           sub     ax, offset free
           mov     [bx], ax
           loop    next_data_relo

           ret


   rnd:
           push    cx
           in      al, 40h
           mov     ah, al
           mov     cl, al
           in      al, 40h
           ror     ax,  cl
           xor     ax, cs:last_rnd
           mov     cs:last_rnd, ax
           pop     cx
           ret

   last_rnd        dw      0DEADh

   rnd_max:
           or      bp, bp
           jz      rnd_max_0
           push    dx
           call    rnd
   ;        mov     ax, 1
           xor     dx, dx
           div     bp
           xchg    ax, dx
           pop     dx
           ret

   rnd_max_0:
           xor     ax, ax
           ret

   num_of_blocks   dw      0
   out_block_ofs   dw      0
   data_relo_ofs   dw      0
   jmp_relo_ofs    dw      0

   data_not_found  db      'Error in link data', 13, 10, '$'
   jump_not_found  db      'Error in link jump', 13, 10, '$'

           include src\main.inc

   in_block_table:
           dd      100h dup(?)
   out_block_table:
           dd      100h dup(?)
   data_relo_table:
           dd      100h dup(?)
   jmp_relo_table:
           dd      100h dup(?)

   free:

   code    ends
           end     start
