<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/1999/REC-html401-19991224/strict.dtd">
<html>
<head>
<META http-equiv=Content-Type content="text/html; charset=windows-1252">
<title>Exported from Notepad++</title>
<style type="text/css">
span {
	font-family: 'Courier New';
	font-size: 10pt;
	color: #000000;
}
.sc0 {
}
</style>
</head>
<body>
<div style="float: left; white-space: pre; line-height: 1; background: #FFFFFF; "><span class="sc0">
                Direct Phantom
                ──────────────
          A includable Simulated Polymorphic Generator
          ────────────────────────────────────────────


 Mutation Engine. Ну вот и я решил попробовать себя в этой области.
 Написал я его под влиянием увиденного в SMEG.Pathogen : cовершенно
 обалдел от безобразия творившегося в декрипторе,и решил что надобно
 написать такой же крутой мусоризатор.

 Да и UEP сзади подпирает (метод заражения сродни Insertion в Zhengxi).
 Ведь без ME его употреблять нет смысла.В связи с этим отмазка : Мусоризатор
 может сгенерить что нибуть типа TEST ES:[BX+SI+9CE1h],1234h - на
 что какой нибудь TBAV начнет ругаться. Но я делал DPH специально дя UEP,
 а там до декриптора добираться как до африки пешком...

 Поскольку никогда с ME дела не имел пришлось разобраться в формате команд.
 Как ни странно Мусоризатор писал особо не разбираясь со SMEG'ом,
 а под впечатением статьи про ME VIRtual_Bomj'a .
 Нашел у себя доку по командам i386 и преобразовал ее в соотватствии
 с групированием команд. Это сильно помогло при написании Мусоризатора.
 С моей точки зрения группирование мусора в SMEG сделано слабее.
 Как таковой генератор декриптора может и не так силен,но в мусоризаторе
 я постарался использовать весь какой только можно мусор (см. TRCOMM.TXT)
 Уж не знаю как получилось, но думаю на Уровне. Только не знаю на каком:

 [ Использование в расшифровщике взамозаменяемых инструкций и "перемешивание"
   инструкций между собой без изменения алгоритма шифрования,а также расшифровщик
   может использовать различные алгоритмы шифрования вирусного кода.]
   (C) кажется ДанилOFF ?

 Direct Phantom - это подключаемый генератор,моделирующий
 полиморфные расшифровщики. Алгоритм шифрования составляется из 13 команд
 на RND(8...16) позиций - от 0.8*10^9 до 6.6*10^17 комбинаций команд.

 Описание архива
 ───────────────

 PHANTOM.TXT - эта дока
 TRCOMM.TXT - все команды более или менее годные для мусора
 COMMANDS.TXT - сгруппированная по КОП'ам система комманд i386

 PHANTOM.ASM - собственно ME         ┐  Это вместе и есть DirectPhantom v2.1
 TRASH.ASM - собственно мусоризатор  ┘

 TRTEST.ASM - тестер для Мусоризатора : создает TRASH.COM файл и набивает
 его мусором,а в конце RET. Сколько не запускал глюков не было.

 PHTEST.ASM - тестер для ME. Создает PHDEMO.COM с декриптором и програмкой
 которая выводит мессагу (зашифровано естественно).

 PHTRIV.ASM - тривиальный DirectPhantom.NOTSR.COM

 Вызов
 ─────

 Нужно заполнить структуру

 (1)
 TARGETPLACE   : SEG:OFFS - место генерения декриптора
 DEST_CODE     : адрес шифруемой области,SEG декриптора
 COUNTER       : длинна области
 LENDECRYPTOR  : длинна декриптора = 0
 RELOFFS       : дополнительное смещение

 (2)
 CALL PHANTOM      - генерация декриптора

 Создает декриптор в указанном месте
 Если DEST_CODE=FFFFh, то после генерации DEST_CODE = TARGETOFFS+LENDECRYPTOR

 CALL JuNK_DOIT    - шифрование области,освобождение стека


 Моделирование
 ─────────────

 При генерации не используется никаких сжатых масок - нет принципиально разных
 частей ,поэтому разные декрипторы в общем должны рассматриваться как
 декрипторы одного типа:

 ────────────────────────────────────────────────────────────────────────────
 (1)
 InitUsedRegisters:
 BASE       = 1000h  В произвольном порядке,
 KEY        = RND    с разными регистрами,
 COUNTER    = 3Dh    и разными способами
 SEGBASE    = ES,DS

 mov    bx,0974F  ; BASE    mov    al,068     ; KEY
 push   cs    ; DSBASE  mov    bp,A014    ; BASE
 pop    ds          mov    bx,cs      ; DSBASE
 mov    si,cs     ; ESBASE  mov    ds,bx
 mov    es,si           mov    dx,0003D   ; COUNTER
 mov    al,038    ; KEY     push   cs     ; ESBASE
                pop    es

 (2)
 LoadByteFromCode:  (Present/Abscent)

 Загрузка байта из криптуемого кода в TMP_REG,
 если криптование непосредственно в память,то ничего нет

 mov    ch,es:[bx+78B1]     ------//------

 (3)
 Arithm&amp;Shift[De]Coding:

 Кодирование байта арифметичаскими и логическими командами в REG/MEM
 От 8 до 16 комманд

 Параллельно в стеке создается EncryptionPart состоящий из
 зеркальных комманд в обратном порядке
 При закодировании используется созданный декриптор,но с вызовом EncryptPart

 rol    ch,64           add    ds:[bp][06FEC],00C ; A014+6FEC=1000h
 add    ch,al           add    es:[bp][06FEC],dh
 sub    ah,2E           add    ds:[bp][06FEC],094
 inc    ch          sub    es:[bp][06FEC],06B
 add    ch,FC           add    ds:[bp][06FEC],0A2
 sub    ch,al           inc    es:[bp][06FEC]
 sub    ch,1C           sub    es:[bp][06FEC],dl  ; С счетчиком
 neg    ch          sub    ds:[bp][06FEC],al  ; С ключем
 rol    ch,1            add    es:[bp][06FEC],al
                neg    es:[bp][06FEC]
                not    es:[bp][06FEC]
                inc    ds:[bp][06FEC]
                rol    ds:[bp][06FEC],024
                add    es:[bp][06FEC],066
                rol    es:[bp][06FEC],1

 (4)
 SaveByteFromCode:  (Present/Abscent)

 Сохранение байта в криптуемый код из TMP_REG,
 если криптование непосредственно в память,то ничего нет

 mov    es:[bx+78B1],ch     ------//------

 (5)
 ChangeCnt,Base&amp;TestLimit

 Продвижение Базы  -  ADD/SUB,SUB/ADD,INC

 Уменьшение счетчика цикла  -  DEC
 (если таковой существует)

 Проверка предела  -  CMP or None
 Результат в ZF
 После проверки предела не присутствует мусор

 sub    bx,4C           inc    bp
 add    bx,4D           dec    dx
 cmp    bx,978C

 (5a)
 ChangeKey (не реализовано)
 Изменение ключа всеми доступными способами

 (6)
 JumpIfNotAll

 Цикл по признаку ZF  -  JNE Rel8 , JNE Rel16
 ────────────────────────────────────────────────────────────────────────────

 HISTORY
 ───────

 Версия 1.0 beta

 + Не найдено ошибок. У-рр-а !!!
 + Возможность использования DEST_CODE = FFFFh
 - Нет мусора - уже написан,но неоптимизен,TRCHAIN = RET
 - Нет базирования PHANTOM (и не будет)
 - Нет антиэвристики (и не будет)
 - i386 only

 Версия 2.0

 + Сделан генератор мусора включающий в себя весь какой только можно мусор
   с любыми режимами адресации (см. TRCOMM.TXT ). Круче SMEG !
   Включает мусорные подпрограммы и вызовы их. Все CALL'ы адресуются назад.

 - Имеется генерация словного мусора адресующегося в память типа mov ax,[bx]
   Отсюда возможна экзотическая ошибка "заворачивание сегмента"
   Это когда BX=0FFFFh,и при mov ax,[bx] вылетает Exeption 12:Invalid opcode
   Вообще сначала я думал что такой глюк будет встречаться крайне редко,
   но к моему огорчению результаты тестов показали обратное - 1/15.
   Видимо придется оставить только байтовую адресацию в память.А жаль.

 - Крайне принципиальная ошибка.
   Мусорные CALL'ы формируются из 4 offset'ной очереди на предшествующие SUB'ы
   в любом месте программы.Но слежение за регистрами осуществляется линейно
   по ходу формирования декриптора.
   Может возникнуть ситуация когда SUB'рутина мусором изменяет нужный регитср,
   когда в том месте откуда она вызывалась этого уже делать нельзя.
   Но когда генерилась процедура этот регистр был еще свободным для мусора

 Версия 2.1

 + Исправлены CALL'ы :
   Теперь адресация CALL'ов сделана только на впередстоящие SUB'рутины.
   То есть в SUB'ах нужные регистры уже учтены.
   Для пользования FREEREG сделан MaskCALLRequest - запрещает генерацию CALL'ов
 + Возможны вложенные CALL'ы : в одном экземпляре у меня наблюлось 8 вложений.
 - Лишняя сотня байт . Итак уже DirectPhantom v2.1 = 2050 байт.
</span></div></body>
</html>
