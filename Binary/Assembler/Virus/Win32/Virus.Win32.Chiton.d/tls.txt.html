<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/1999/REC-html401-19991224/strict.dtd">
<html>
<head>
<META http-equiv=Content-Type content="text/html; charset=windows-1252">
<title>Exported from Notepad++</title>
<style type="text/css">
span {
	font-family: 'Courier New';
	font-size: 10pt;
	color: #000000;
}
.sc0 {
}
</style>
</head>
<body>
<div style="float: left; white-space: pre; line-height: 1; background: #FFFFFF; "><span class="sc0">                             Thread Local Storage
                            The hidden entry point
                              roy g biv / defjam

                                 -= defjam =-
                                  since 1992
                     bringing you the viruses of tomorrow
                                    today!


Prologue:

Please excuse my English.  I'm still learning.


About the author:

Former  DOS/Win16  virus writer, author of several virus  families,  including
Ginger  (see Coderz #1 zine for terrible buggy example, contact me for  better
sources  ;),  and  Virus Bulletin 9/95 for a description of what  they  called
Rainbow.   Co-author  of  world's first virus using circular  partition  trick
(Orsam,  coded  with  Prototype in 1993).  Designer of the world's  first  XMS
swapping  virus (John Galt, coded by RTFishel in 1995, only 30 bytes stub, the
rest  is swapped out).  Author of various retrovirus articles (eg see Vlad  #7
for the strings that make your code invisible to TBScan).  Went to sleep for a
number  of years.  This is my first virus for Win32.  It is the world's  first
virus using Thread Local Storage for replication.  It took me a week to design
it  and a whole day to write it.

I'm also available for joining a group.  Just in case anyone is interested. ;)


What is Thread Local Storage?

This is what Microsoft has to say about it:
"The  .tls  section  provides direct PE/COFF support for static  Thread  Local
Storage  (TLS).   TLS is a special storage class supported by Windows NT.   To
support  this  programming construct, the PE/COFF .tls section  specifies  the
following  information: initialization data, callback routines for  per-thread
initialization and termination, and the TLS index".

So,  Thread Local Storage (TLS) is a Microsoft invention for applications that
need  to  initialise  thread data before main execution begins.  To  do  this,
there  are callback pointers.  These functions execute before the code at  the
main  entry point!  To prove that, load my example code into any debugger  and
see  what happens.  Ho ho, we even fool SoftIce for NT, the god of  debuggers.
Clearly,  this  is a new way for viruses to run and probably the  AVers  don't
know about it yet, or if they do then they don't support it because no viruses
use it (maybe they said that about NTFS alternative streams too).

Some points now:
We  can ignore the reference to .tls because there is a field in the PE header
that  points to this structure anywhere in the file.  Unfortunately, it's true
that  it  works  only under Windows NT/2000/XP.  Under Windows  9x/Me,  simply
nothing  happens  and  those  functions never receive  control.  At  least  it
doesn't  crash. :)  Also,  NT/2000/XP require import section that imports  dll
that uses kernel32 APIs, else a page fault occurs.  This appears to be a bug.

The callback functions have the same parameters as a DLL entry-point function,
except that nothing is returned.  The declaration looks like this:

typedef VOID (NTAPI *PIMAGE_TLS_CALLBACK)
             (PVOID DllHandle, DWORD Reason, PVOID Reserved);

This means that there are three parameters on the stack, so TLS functions must
use RET 000Ch on exit.  The Reason parameter can take the following values:

Setting                 Value   Description
DLL_PROCESS_ATTACH      1       New process has started
DLL_THREAD_ATTACH       2       New thread has been created
DLL_THREAD_DETACH       3       Thread is about to be terminated
DLL_PROCESS_DETACH      0       Process is about to terminate

The DLL_PROCESS_ATTACH and DLL_PROCESS_DETACH messages mean that we are called
for  the  host startup (after CreateProcess() but before process entry  point)
and  shutdown  (from  within  ExitProcess()), and  the  DLL_THREAD_ATTACH  and
DLL_THREAD_DETACH   mean  that  we  are  called  for  thread  startup   (after
CreateThread()  but  before  thread  entry point) and  shutdown  (from  within
ExitThread()).   This  happens for EXEs and also DLLs (but only DLLs that  are
not  loaded with LoadLibrary).  No need to hook ExitProcess() anymore  because
we will be called by ExitProcess() automatically.

It  is important to know that NTDLL.DLL (not KERNEL32.DLL!) calls the callback
functions,  and  that  kernel32.dll is not in the SEH chain  when  the  ATTACH
messages  are sent, only when the DETACH messages are sent.  Thus, if you need
to  call  kernel32.dll APIs from an ATTACH message, then you cannot use a  SEH
walker  to  find kernel32.dll image base.  The good thing is that  the  import
table is filled already, so you can use the host imports.


What does TLS look like?

At offset 0xC0 in the PE header is the pointer to the TLS directory.
According to Microsoft documentation, the TLS directory has the format:

Offset  Size    Field                   Description
0x00    4       Raw Data Start VA       Starting address of the TLS template
0x04    4       Raw Data End VA         Address of last byte of TLS template
0x08    4       Address of Index        Location to receive the TLS index
0x0C    4       Address of Callbacks    Pointer to array of TLS callbacks
0x10    4       Size of Zero Fill       Size of unused data in TLS template
0x14    4       Characteristics         (reserved but not checked)

Notice  that the pointers are all virtual addresses (VA), not relative virtual
addresses  (RVA).   This means that if we add a TLS directory, we should  also
add  relocation items to the .reloc section, or simply remove all relocations.
The reason for this is that if the file is loaded to a different base address,
then  Windows NT/2000 will display the message box "The application failed  to
initialize correctly" and the file will not execute anymore.


What do the TLS fields mean?

The  TLS template contains data that are copied whenever a thread is  created.
These  data  can  also  be executable codes.  If the template  exists  (it  is
optional  and  so  the fields can be null) then when the  application  starts,
Windows  will allocate an array for the TLS pointers and store this pointer at
fs:0x2c.   For  each  thread  that is created, the size  of  the  template  is
allocated  from  the local heap, the data are copied to there, the pointer  is
stored  in the array, and the array index is stored in the TLS index field.  A
thread can get its pointer by this formula:
dword at (dword at fs:[0x2c] + (TLS index * 4))
Or some code:
mov eax, dword ptr fs:[2ch]             ;get pointer to array of TLS pointers
mov ecx, dword ptr [offset TLSIndex]    ;get TLS index
mov eax, dword ptr [ecx * 4 + eax]      ;get pointer to TLS data
then access data at [eax + offset]

The  Address  of  Callbacks  field contains the Virtual Address  of  an  null-
terminated  array of functions that receive the ATTACH/DETACH messages.  It is
valid  to have no entries in this array.  In that case, the field is  supposed
to point to four zero bytes, however the actual field can also be null.


How to use TLS?

There are a few simple ways to use TLS to infect a file:
add a callback pointer to existing array (or create new array)
alter one of the host callback pointers
alter the code in one of the callbacks
create a new TLS directory
hijack the TLS template and alter some code somewhere in the file

If  you  want to use the TLS method to infect a file, firstly check if  a  TLS
directory  exists already.  If it does, then you can pick at random a callback
routine  pointer and change it to point to your code.  If there is no existing
TLS  directory,  then  add one by setting correctly the pointers in  your  own
version.   The template addresses can be set to null and the index pointer can
point to any writable dword (including the Characteristics field because it is
not  used).  The callback pointer will point to the array of callback  routine
pointers,  one of which will be the virus entry point.  When this entry  point
receives control, the file is loaded fully into memory and the import table is
fixed  up.  This means that we can do anything that we would do normally, like
go  resident  or  call  API functions and spread to  other  files.   The  main
difference  is  that  we are guaranteed to be called at least twice,  once  on
startup  and  once on shutdown, and twice more for every thread that the  host
uses.   This means that we must be careful to avoid recursion because we  will
also be called if we use threads in our virus code.

Hijacking  the  TLS template is a technique that I discovered some time  later
during  my  research.  The idea is to make a copy of the TLS template and  add
the  virus code to it.  When the process starts (or a thread is created), then
the  virus code is copied by Windows into the heap.  This means that the  code
is  automatically placed into a executable and writable memory space,  without
any  call to malloc or memcopy.  The only thing that is required after that is
to  transfer  control to the code on the heap.  That is done by using the  TLS
index to get the heap pointer.

The transfer of control code would look something like this:
this code is in the file:
fib:
push    eax
push    ecx
mov     eax, dword ptr fs:[2ch]
mov     ecx, dword ptr [offset tls_index]
mov     eax, dword ptr [ecx * 4 + eax]
add     eax, size of original TLS template
call    eax
fie:

this code is on the heap:
pop     eax             ;get return address
pop     ecx             ;restore original ecx
sub     eax, fie - fib  ;point to first byte of code in file
xchg    eax, [esp]      ;store real return address and restore original eax
pushad                  ;now save all original registers
;rest of code is here.  do not forget to restore host bytes
popad                   ;restore all registers
ret                     ;return to host


Epilogue:

Now  you  want to look at my example code and then to make your own  examples.
There   are  many  possibilities  with  this  technique  that  make  it   very
interesting.  It is easy when you know how.  Just use your imagination.

TLSDemo1 has an inserted TLS directory and code that displays message box.
This code runs before main entry point.

TLSDemo2 has a hijacked TLS template and code that displays message box.
This code jumps from main entry point to heap without malloc or memcopy.


Greets to the old Defjam crew:

Prototype, RTFishel, Obleak, and The Gingerbread Man


rgb/dj jan 2001
iam_rgb@hotmail.com</span></div></body>
</html>
